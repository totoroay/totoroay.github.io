<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://totoroay.github.io/</id>
    <title>totoroay</title>
    <updated>2020-05-09T13:15:02.482Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://totoroay.github.io/"/>
    <link rel="self" href="https://totoroay.github.io/atom.xml"/>
    <subtitle>每天学习5小时！！！</subtitle>
    <logo>https://totoroay.github.io/images/avatar.png</logo>
    <icon>https://totoroay.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, totoroay</rights>
    <entry>
        <title type="html"><![CDATA[ SpringBoot07：Thymeleaf模板引擎]]></title>
        <id>https://totoroay.github.io/post/springboot07thymeleaf-mo-ban-yin-qing/</id>
        <link href="https://totoroay.github.io/post/springboot07thymeleaf-mo-ban-yin-qing/">
        </link>
        <updated>2020-05-09T13:11:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="thymeleaf">Thymeleaf</h2>
<p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p>
<p>jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，<strong>他现在默认是不支持jsp的</strong>。</p>
<p>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？</p>
<p><strong>SpringBoot推荐你可以来使用模板引擎：</strong></p>
<p>模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图：</p>
<p><img src="https://totoroay.github.io//post-images/1589030049112.png" alt="" loading="lazy"><br>
模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。</p>
<p>我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。</p>
<h2 id="引入thymeleaf">引入Thymeleaf</h2>
<p>怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：</p>
<p>Thymeleaf 官网：https://www.thymeleaf.org/</p>
<p>Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf</p>
<p>Spring官方文档：找到我们对应的版本</p>
<p>https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</p>
<p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p>
<pre><code class="language-xml">&lt;!--thymeleaf--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Maven会自动下载jar包，我们可以去看下下载的东西；</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589030040046.png" alt="" loading="lazy"></figure>
<h2 id="thymeleaf分析">Thymeleaf分析</h2>
<p>前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？</p>
<p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。</p>
<p>我们去找一下Thymeleaf的自动配置类：ThymeleafProperties</p>
<pre><code class="language-java">@ConfigurationProperties(
    prefix = &quot;spring.thymeleaf&quot;
)
public class ThymeleafProperties {
    private static final Charset DEFAULT_ENCODING;
    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;
    public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
    private boolean checkTemplate = true;
    private boolean checkTemplateLocation = true;
    private String prefix = &quot;classpath:/templates/&quot;;
    private String suffix = &quot;.html&quot;;
    private String mode = &quot;HTML&quot;;
    private Charset encoding;
}
</code></pre>
<p>我们可以在其中看到默认的前缀和后缀！</p>
<p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p>
<p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p>
<h2 id="测试">测试</h2>
<p>1、编写一个TestController</p>
<pre><code class="language-java">@Controller
public class TestController {
    
    @RequestMapping(&quot;/t1&quot;)
    public String test1(){
        //classpath:/templates/test.html
        return &quot;test&quot;;
    }
    
}
</code></pre>
<p>2、编写一个测试页面  test.html 放在 templates 目录下</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;测试页面&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、启动项目请求测试</p>
<h2 id="thymeleaf-语法学习">Thymeleaf 语法学习</h2>
<p>要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下；</p>
<p>Thymeleaf 官网：https://www.thymeleaf.org/ ， 简单看一下官网！我们去下载Thymeleaf的官方文档！</p>
<p><strong>我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示</strong></p>
<p>1、修改测试请求，增加数据传输；</p>
<pre><code class="language-java">@RequestMapping(&quot;/t1&quot;)
public String test1(Model model){
    //存入数据
    model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);
    //classpath:/templates/test.html
    return &quot;test&quot;;
}
</code></pre>
<p>2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。</p>
<p>我们可以去官方文档的#3中看一下命名空间拿来过来：</p>
<pre><code> xmlns:th=&quot;http://www.thymeleaf.org&quot;
</code></pre>
<p>3、我们去编写下前端页面</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;test&lt;/h1&gt;
&lt;!--所有的html元素都可以被thymeleaf替换:   th:元素名--&gt;
&lt;!--th:text就是将div中的内容设置为它指定的值，和Vue一样--&gt;
&lt;div th:text=&quot;${msg}&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4、启动测试</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589030024666.png" alt="" loading="lazy"></figure>
<p><strong>OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！</strong></p>
<p><strong>1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！</strong></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589030016433.jpg" alt="" loading="lazy"></figure>
<p><strong>2、我们能写哪些表达式呢？</strong></p>
<pre><code>Simple expressions:（表达式语法）
Variable Expressions: ${...}：获取变量值；OGNL；
    1）、获取对象的属性、调用方法
    2）、使用内置的基本对象：#18
         #ctx : the context object.
         #vars: the context variables.
         #locale : the context locale.
         #request : (only in Web Contexts) the HttpServletRequest object.
         #response : (only in Web Contexts) the HttpServletResponse object.
         #session : (only in Web Contexts) the HttpSession object.
         #servletContext : (only in Web Contexts) the ServletContext object.

    3）、内置的一些工具对象：
　　　　　　#execInfo : information about the template being processed.
　　　　　　#uris : methods for escaping parts of URLs/URIs
　　　　　　#conversions : methods for executing the configured conversion service (if any).
　　　　　　#dates : methods for java.util.Date objects: formatting, component extraction, etc.
　　　　　　#calendars : analogous to #dates , but for java.util.Calendar objects.
　　　　　　#numbers : methods for formatting numeric objects.
　　　　　　#strings : methods for String objects: contains, startsWith, prepending/appending, etc.
　　　　　　#objects : methods for objects in general.
　　　　　　#bools : methods for boolean evaluation.
　　　　　　#arrays : methods for arrays.
　　　　　　#lists : methods for lists.
　　　　　　#sets : methods for sets.
　　　　　　#maps : methods for maps.
　　　　　　#aggregates : methods for creating aggregates on arrays or collections.
==================================================================================

  Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；
  Message Expressions: #{...}：获取国际化内容
  Link URL Expressions: @{...}：定义URL；
  Fragment Expressions: ~{...}：片段引用表达式

Literals（字面量）
      Text literals: 'one text' , 'Another one!' ,…
      Number literals: 0 , 34 , 3.0 , 12.3 ,…
      Boolean literals: true , false
      Null literal: null
      Literal tokens: one , sometext , main ,…
      
Text operations:（文本操作）
    String concatenation: +
    Literal substitutions: |The name is ${name}|
    
Arithmetic operations:（数学运算）
    Binary operators: + , - , * , / , %
    Minus sign (unary operator): -
    
Boolean operations:（布尔运算）
    Binary operators: and , or
    Boolean negation (unary operator): ! , not
    
Comparisons and equality:（比较运算）
    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )
    Equality operators: == , != ( eq , ne )
    
Conditional operators:条件运算（三元运算符）
    If-then: (if) ? (then)
    If-then-else: (if) ? (then) : (else)
    Default: (value) ?: (defaultvalue)
    
Special tokens:
    No-Operation: _
</code></pre>
<p><strong>练习测试：</strong></p>
<p>1、 我们编写一个Controller，放一些数据</p>
<pre><code class="language-java">@RequestMapping(&quot;/t2&quot;)
public String test2(Map&lt;String,Object&gt; map){
    //存入数据
    map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;);
    map.put(&quot;users&quot;, Arrays.asList(&quot;qinjiang&quot;,&quot;kuangshen&quot;));
    //classpath:/templates/test.html
    return &quot;test&quot;;
}
</code></pre>
<p>2、测试页面取出数据</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;test&lt;/h1&gt;

&lt;div th:text=&quot;${msg}&quot;&gt;&lt;/div&gt;
&lt;!--不转义--&gt;
&lt;div th:utext=&quot;${msg}&quot;&gt;&lt;/div&gt;

&lt;!--遍历数据--&gt;
&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;
&lt;h4 th:each=&quot;user :${users}&quot; th:text=&quot;${user}&quot;&gt;&lt;/h4&gt;

&lt;h4&gt;
    &lt;!--行内写法：官网#12--&gt;
    &lt;span th:each=&quot;user:${users}&quot;&gt;[[${user}]]&lt;/span&gt;
&lt;/h4&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、启动项目测试</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589030000687.png" alt="" loading="lazy"></figure>
<p><strong>我们看完语法，很多样式，我们即使现在学习了，也会忘记，所以我们在学习过程中，需要使用什么，根据官方文档来查询，才是最重要的，要熟练使用官方文档！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：AOP]]></title>
        <id>https://totoroay.github.io/post/springaop/</id>
        <link href="https://totoroay.github.io/post/springaop/">
        </link>
        <updated>2020-05-09T05:50:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是aop">什么是AOP</h2>
<p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589003489694.png" alt="" loading="lazy"></figure>
<h2 id="aop在spring中的作用">Aop在Spring中的作用</h2>
<p><mark>提供声明式事务；允许用户自定义切面</mark></p>
<p><mark>以下名词需要了解下：</mark></p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ....</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589003480765.png" alt="" loading="lazy"></figure>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589003466003.png" alt="" loading="lazy"></figure>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<h2 id="使用spring实现aop">使用Spring实现Aop</h2>
<p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
   &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="第一种方式通过-spring-api-实现">第一种方式通过 Spring API 实现</h3>
<p>首先编写我们的业务接口和实现类</p>
<pre><code class="language-java">public interface UserService {

   public void add();

   public void delete();

   public void update();

   public void search();

}
</code></pre>
<pre><code class="language-java">public class UserServiceImpl implements UserService{

   @Override
   public void add() {
       System.out.println(&quot;增加用户&quot;);
  }

   @Override
   public void delete() {
       System.out.println(&quot;删除用户&quot;);
  }

   @Override
   public void update() {
       System.out.println(&quot;更新用户&quot;);
  }

   @Override
   public void search() {
       System.out.println(&quot;查询用户&quot;);
  }
}
</code></pre>
<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<pre><code class="language-java">// 前置增强
public class Log implements MethodBeforeAdvice {

   //method : 要执行的目标对象的方法
   //objects : 被调用的方法的参数
   //Object : 目标对象
   @Override
   public void before(Method method, Object[] objects, Object target) throwsThrowable {
       System.out.println( target.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);
  }
}
</code></pre>
<pre><code class="language-java">// 后置增强
public class AfterLog implements AfterReturningAdvice {
   //returnValue 返回值
   //method被调用的方法
   //args 被调用的方法的对象的参数
   //target 被调用的目标对象
   @Override
   public void afterReturning(Object returnValue, Method method, Object[] args,Object target) throws Throwable {
       System.out.println(&quot;执行了&quot; + target.getClass().getName()
       +&quot;的&quot;+method.getName()+&quot;方法,&quot;
       +&quot;返回值：&quot;+returnValue);
  }
}
</code></pre>
<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

   &lt;!--注册bean--&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.totoroay.service.UserServiceImpl&quot;/&gt;
   &lt;bean id=&quot;log&quot; class=&quot;com.totoroay.log.Log&quot;/&gt;
   &lt;bean id=&quot;afterLog&quot; class=&quot;com.totoroay.log.AfterLog&quot;/&gt;

   &lt;!--aop的配置--&gt;
   &lt;aop:config&gt;
       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;
       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;
       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="language-java">public class MyTest {
   @Test
   public void test(){
       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.search();
  }
}
</code></pre>
<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .</p>
<h3 id="第二种方式自定义类来实现aop">第二种方式自定义类来实现Aop</h3>
<p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<pre><code class="language-java">public class DiyPointcut {

   public void before(){
       System.out.println(&quot;---------方法执行前---------&quot;);
  }
   public void after(){
       System.out.println(&quot;---------方法执行后---------&quot;);
  }
   
}
</code></pre>
<p>去spring中配置</p>
<pre><code class="language-xml">&lt;!--第二种方式自定义实现--&gt;
&lt;!--注册bean--&gt;
&lt;bean id=&quot;diy&quot; class=&quot;com.totoroay.config.DiyPointcut&quot;/&gt;

&lt;!--aop的配置--&gt;
&lt;aop:config&gt;
   &lt;!--第二种方式：使用AOP的标签实现--&gt;
   &lt;aop:aspect ref=&quot;diy&quot;&gt;
       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;
       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class MyTest {
   @Test
   public void test(){
       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.add();
  }
}
</code></pre>
<h3 id="第三种方式使用注解实现">第三种方式使用注解实现</h3>
<p>第一步：编写一个注解实现的增强类</p>
<pre><code class="language-java">package com.totoroay.config;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect //标注这个类是一个切面
public class AnnotationPointcut {
   @Before(&quot;execution(* com.totoroay.service.UserServiceImpl.*(..))&quot;)
   public void before(){
       System.out.println(&quot;---------方法执行前---------&quot;);
  }

   @After(&quot;execution(* com.totoroay.service.UserServiceImpl.*(..))&quot;)
   public void after(){
       System.out.println(&quot;---------方法执行后---------&quot;);
  }

   @Around(&quot;execution(* com.totoroay.service.UserServiceImpl.*(..))&quot;)
   public void around(ProceedingJoinPoint jp) throws Throwable {
       System.out.println(&quot;环绕前&quot;);
       System.out.println(&quot;签名:&quot;+jp.getSignature());
       //执行目标方法proceed
       Object proceed = jp.proceed();
       System.out.println(&quot;环绕后&quot;);
       System.out.println(proceed);
  }
}
</code></pre>
<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<pre><code class="language-xml">&lt;!--第三种方式:注解实现--&gt;
&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.totoroay.config.AnnotationPointcut&quot;/&gt;
&lt;aop:aspectj-autoproxy/
</code></pre>
<p>aop:aspectj-autoproxy：说明</p>
<pre><code class="language-xml">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了

&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ngork内网穿透]]></title>
        <id>https://totoroay.github.io/post/ngork-nei-wang-chuan-tou/</id>
        <link href="https://totoroay.github.io/post/ngork-nei-wang-chuan-tou/">
        </link>
        <updated>2020-05-09T02:33:15.000Z</updated>
        <content type="html"><![CDATA[<p>1、到官网注册</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588997942816.png" alt="" loading="lazy"></figure>
<p>2、注册成功后开通隧道</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588997949246.png" alt="" loading="lazy"></figure>
<p>3、填写相关信息</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588997954532.png" alt="" loading="lazy"></figure>
<p>4、选择对应的版本，下载解压启动工具</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588997960465.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1588997967933.png" alt="" loading="lazy"></figure>
<p>5、填写隧道id并回车</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1588997979308.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1588997988830.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://totoroay.github.io//post-images/1588997996995.png" alt="" loading="lazy"></figure>
<p>6、访问</p>
<ul>
<li>PC端启动项目后</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://totoroay.github.io//post-images/1588998006236.png" alt="" loading="lazy"></figure>
<ul>
<li>手机访问</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://totoroay.github.io//post-images/1588998018034.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://totoroay.github.io//post-images/1588998024505.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：自动装配及使用注解开发]]></title>
        <id>https://totoroay.github.io/post/springzi-dong-zhuang-pei-ji-shi-yong-zhu-jie-kai-fa/</id>
        <link href="https://totoroay.github.io/post/springzi-dong-zhuang-pei-ji-shi-yong-zhu-jie-kai-fa/">
        </link>
        <updated>2020-05-08T09:36:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自动装配">自动装配</h2>
<blockquote>
<p>自动装配说明</p>
</blockquote>
<ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li>
</ul>
<p>Spring中bean有三种装配机制，分别是：</p>
<ol>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ol>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<ol>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li>
</ol>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p>
<blockquote>
<p>测试环境搭建</p>
</blockquote>
<p>1、新建一个项目</p>
<p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p>
<pre><code class="language-java">package com.totoroay.pojo;

public class Cat {
    public void shout(){
        System.out.println(&quot;喵&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.totoroay.pojo;

public class Dog {
    public void shout(){
        System.out.println(&quot;汪&quot;);
    }
}
</code></pre>
<p>3、新建一个用户类 User</p>
<pre><code class="language-java">public class User {
   private Cat cat;
   private Dog dog;
   private String name;
}
</code></pre>
<p>4、编写Spring配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
   &lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;&gt;
       &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
       &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;
       &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
   &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="language-java">public class MyTest {
   @Test
   public void testMethodAutowire() {
       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       User user = (User) context.getBean(&quot;user&quot;);
       user.getCat().shout();
       user.getDog().shout();
  }
}
</code></pre>
<p>结果正常输出，环境OK</p>
<blockquote>
<p>byName</p>
</blockquote>
<p><strong>autowire byName (按名称自动装配)</strong></p>
<p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p>
<p>采用自动装配将避免这些错误，并且使配置简单化。</p>
<p>测试：</p>
<p>1、修改bean配置，增加一个属性  autowire=&quot;byName&quot;</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; autowire=&quot;byName&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>2、再次测试，结果依旧成功输出！</p>
<p>3、我们将 cat 的bean id修改为 catXXX</p>
<p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p>
<p><strong>小结：</strong></p>
<p>当一个bean节点带有 autowire byName的属性时。</p>
<ol>
<li>
<p>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</p>
</li>
<li>
<p>去spring容器中寻找是否有此字符串名称id的对象。</p>
</li>
<li>
<p>如果有，就取出注入；如果没有，就报空指针异常。</p>
</li>
</ol>
<blockquote>
<p>byType</p>
</blockquote>
<p><strong>autowire byType (按类型自动装配)</strong></p>
<p>使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。</p>
<pre><code>NoUniqueBeanDefinitionException
</code></pre>
<p>测试：</p>
<p>1、将user的bean配置修改一下 ： autowire=&quot;byType&quot;</p>
<p>2、测试，正常输出</p>
<p>3、在注册一个cat 的bean对象！</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; autowire=&quot;byType&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>4、测试，报错：NoUniqueBeanDefinitionException</p>
<p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
<h2 id="使用注解">使用注解</h2>
<blockquote>
<p>使用注解</p>
</blockquote>
<p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p>
<p>准备工作：利用注解的方式注入属性。</p>
<p>1、在spring配置文件中引入context文件头</p>
<pre><code class="language-xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;

http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
</code></pre>
<p>2、开启属性注解支持！</p>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;/&gt;
    &lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="autowired">@Autowired</h4>
<ul>
<li>@Autowired是按类型自动转配的，不支持id匹配。</li>
<li>需要导入 spring-aop的包！</li>
</ul>
<p>测试：</p>
<p>1、将User类中的set方法去掉，使用@Autowired注解</p>
<pre><code class="language-java">public class User {
   @Autowired
   private Cat cat;
   @Autowired
   private Dog dog;
   private String name;

   public Cat getCat() {
       return cat;
  }
   public Dog getDog() {
       return dog;
  }
   public String getName() {
       return str;
  }
}
</code></pre>
<p>2、此时配置文件内容</p>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
</code></pre>
<p>3、测试，成功输出结果！</p>
<p>【科普时间】</p>
<p>@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p>
<pre><code>//如果允许对象为null，设置required = false,默认为true
@Autowired(required = false)
private Cat cat;
</code></pre>
<h4 id="qualifier">@Qualifier</h4>
<ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用。</li>
</ul>
<p>测试实验步骤：</p>
<p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog1&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;dog2&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
</code></pre>
<p>2、没有加Qualifier测试，直接报错</p>
<p>3、在属性上添加Qualifier注解</p>
<pre><code class="language-java">@Autowired
@Qualifier(value = &quot;cat2&quot;)
private Cat cat;
@Autowired
@Qualifier(value = &quot;dog2&quot;)
private Dog dog;
</code></pre>
<p>测试，成功输出！</p>
<h4 id="resource">@Resource</h4>
<ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
<p>实体类：</p>
<pre><code class="language-java">public class User {
   //如果允许对象为null，设置required = false,默认为true
   @Resource(name = &quot;cat2&quot;)
   private Cat cat;
   @Resource
   private Dog dog;
   private String str;
}
</code></pre>
<p>beans.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;/&gt;
</code></pre>
<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>实体类上只保留注解</p>
<pre><code class="language-java">@Resource
private Cat cat;
@Resource
private Dog dog;
</code></pre>
<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<h3 id="小结">小结</h3>
<p>@Autowired与@Resource异同：</p>
<p>1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</p>
<p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p>
<h2 id="使用注解开发">使用注解开发</h2>
<p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588930619093.png" alt="" loading="lazy"></figure>
<p>在配置文件当中，还得要引入一个context约束</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    
    &lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;
    &lt;context:component-scan base-package=&quot;com.totoroay.pojo&quot;/&gt;
    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<blockquote>
<p>Bean的实现</p>
</blockquote>
<p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p>
<p>1、配置扫描哪些包下的注解</p>
<pre><code class="language-xml">&lt;!--指定注解扫描包--&gt;
&lt;context:component-scan base-package=&quot;com.totoroay.pojo&quot;/&gt;
</code></pre>
<p>2、在指定包下编写类，增加注解</p>
<pre><code class="language-java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User {
   public String name = &quot;totoroay&quot;;
}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void test(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    User user = context.getBean(&quot;user&quot;, User.class);
    System.out.println(user.getName());
}
</code></pre>
<blockquote>
<p>属性注入</p>
</blockquote>
<p>使用注解注入属性</p>
<p>1、可以不用提供set方法，直接在直接名上添加@value(&quot;值&quot;)</p>
<pre><code class="language-java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User {
   @Value(&quot;totoroay&quot;)
   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
   public String name;
}
</code></pre>
<p>2、如果提供了set方法，也可以在set方法上添加@value(&quot;值&quot;);</p>
<pre><code class="language-java">@Component(&quot;user&quot;)
public class User {

   public String name;

   @Value(&quot;totoroay&quot;)
   public void setName(String name) {
       this.name = name;
  }
}
</code></pre>
<blockquote>
<p>衍生注解</p>
</blockquote>
<p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p>
<p><strong>@Component三个衍生注解</strong></p>
<p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li>@Controller：web层</li>
<li>@Service：service层</li>
<li>@Repository：dao层</li>
</ul>
<p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<blockquote>
<p>自动装配注解</p>
</blockquote>
<p>在Bean的自动装配已经讲过了，可以回顾！</p>
<blockquote>
<p>作用域</p>
</blockquote>
<p>@scope</p>
<ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式（原型模式）。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li>
</ul>
<pre><code class="language-java">@Controller(&quot;user&quot;)
@Scope(&quot;prototype&quot;)
public class User {
   @Value(&quot;totoroay&quot;)
   public String name;
}
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p><strong>XML与注解比较</strong></p>
<ul>
<li>XML可以适用任何场景 ，结构清晰，维护方便</li>
<li>注解不是自己提供的类使用不了，开发简单方便</li>
</ul>
<p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p>
<ul>
<li>xml管理Bean</li>
<li>注解完成属性注入</li>
<li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li>
</ul>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;  
</code></pre>
<p>作用：</p>
<ul>
<li>
<p>进行注解驱动注册，从而使注解生效</p>
</li>
<li>
<p>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</p>
</li>
<li>
<p>如果不扫描包，就需要手动配置bean</p>
</li>
<li>
<p>如果不加注解驱动，则注入的值为null！</p>
</li>
</ul>
<blockquote>
<p>基于Java类进行配置</p>
</blockquote>
<p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p>
<p>测试：</p>
<p>1、编写一个实体类，Dog</p>
<pre><code class="language-java">@Component  //将这个类标注为Spring的一个组件，放到容器中！
public class Dog {
   public String name = &quot;dog&quot;;
}
</code></pre>
<p>2、新建一个config配置包，编写一个MyConfig配置类</p>
<pre><code class="language-java">@Configuration  //代表这是一个配置类
public class MyConfig {

   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！
   public Dog dog(){
       return new Dog();
  }

}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void test2(){
   ApplicationContext applicationContext =
           new AnnotationConfigApplicationContext(MyConfig.class);
   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);
   System.out.println(dog.name);
}
</code></pre>
<p>4、成功输出结果！</p>
<p><strong>导入其他配置如何做呢？</strong></p>
<p>1、我们再编写一个配置类！</p>
<pre><code class="language-java">@Configuration  //代表这是一个配置类
public class MyConfig2 {
}
</code></pre>
<p>2、在之前的配置类中我们来选择导入这个配置类</p>
<pre><code class="language-ja">@Configuration
@Import(MyConfig2.class)  //导入合并其他配置类，类似于配置文件中的 inculde 标签
public class MyConfig {

   @Bean
   public Dog dog(){
       return new Dog();
  }

}
</code></pre>
<p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot06：Web开发静态资源处理]]></title>
        <id>https://totoroay.github.io/post/springboot06web-kai-fa-jing-tai-zi-yuan-chu-li/</id>
        <link href="https://totoroay.github.io/post/springboot06web-kai-fa-jing-tai-zi-yuan-chu-li/">
        </link>
        <updated>2020-05-08T05:39:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自动装配">自动装配</h2>
<p>springboot 到底帮我们配置了什么？我们能不能进行修改？能修改哪些东西？能不能扩展</p>
<ul>
<li>xxxAutoConfiguration	向容器中自动配置组件</li>
<li>xxxProperties	自动配置类 ，装配配置文件中自定义的一些内容</li>
</ul>
<p>要解决的问题：</p>
<ul>
<li>导入静态资源......</li>
<li>首页</li>
<li>jsp，模板引擎  Thymeleaf</li>
<li>装配扩展SpringMVC</li>
<li>增删改查</li>
<li>拦截器</li>
<li>国际化</li>
</ul>
<h2 id="web开发静态资源处理">Web开发静态资源处理</h2>
<h3 id="静态资源映射规则">静态资源映射规则</h3>
<p><strong>首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！</strong></p>
<p>写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？</p>
<p>如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！</p>
<p><strong>我们先来聊聊这个静态资源映射规则：</strong></p>
<p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</p>
<p>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</p>
<p>有一个方法：addResourceHandlers 添加资源处理</p>
<pre><code class="language-java">@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    if (!this.resourceProperties.isAddMappings()) {
        // 已禁用默认资源处理
        logger.debug(&quot;Default resource handling disabled&quot;);
        return;
    }
    // 缓存控制
    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
    // webjars 配置
    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)
                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)
                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
    // 静态资源配置
    String staticPathPattern = this.mvcProperties.getStaticPathPattern();
    if (!registry.hasMappingForPattern(staticPathPattern)) {
        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))
                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
}
</code></pre>
<p>读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源；</p>
<h3 id="什么是webjars-呢">什么是webjars 呢？</h3>
<p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p>
<p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p>
<p>网站：https://www.webjars.org</p>
<p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;3.5.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>导入完毕，查看webjars目录结构，并访问Jquery.js文件！</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588916489459.png" alt="" loading="lazy"></figure>
<p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：http://localhost:8080/webjars/jquery/3.5.1/jquery.js</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588916482138.png" alt="" loading="lazy"></figure>
<h3 id="第二种静态资源映射规则">第二种静态资源映射规则</h3>
<p>那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p>
<p>我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：</p>
<pre><code class="language-java">// 进入方法
public String[] getStaticLocations() {
    return this.staticLocations;
}
// 找到对应的值
private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
// 找到路径
private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { 
    &quot;classpath:/META-INF/resources/&quot;,
  &quot;classpath:/resources/&quot;, 
    &quot;classpath:/static/&quot;, 
    &quot;classpath:/public/&quot; 
};
</code></pre>
<p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p>
<p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p>
<pre><code>&quot;classpath:/METAINF/resources/&quot;
&quot;classpath:/resources/&quot;
&quot;classpath:/static/&quot;
&quot;classpath:/public/&quot;
</code></pre>
<p><mark>resources &gt; static(默认)  &gt; public</mark></p>
<p>我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p>
<p>比如我们访问 http://localhost:8080/1.js , 他就会去这些文件夹中寻找对应的静态资源文件；</p>
<h3 id="自定义静态资源路径">自定义静态资源路径</h3>
<p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p>
<pre><code class="language-properties">spring.resources.static-locations=classpath:/coding/,classpath:/totoroay/
</code></pre>
<p>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！</p>
<h2 id="首页处理">首页处理</h2>
<p>静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！</p>
<pre><code class="language-java">@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
                                                           FormattingConversionService mvcConversionService,
                                                           ResourceUrlProvider mvcResourceUrlProvider) {
    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页
        this.mvcProperties.getStaticPathPattern());
    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
    return welcomePageHandlerMapping;
}
</code></pre>
<p>点进去继续看</p>
<pre><code class="language-java">private Optional&lt;Resource&gt; getWelcomePage() {
    String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());
    // ::是java8 中新引入的运算符
    // Class::function的时候function是属于Class的，应该是静态方法。
    // this::function的funtion是属于这个对象的。
    // 简而言之，就是一种语法糖而已，是一种简写
    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();
}
// 欢迎页就是一个location下的的 index.html 而已
private Resource getIndexHtml(String location) {
    return this.resourceLoader.getResource(location + &quot;index.html&quot;);
}
</code></pre>
<p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。</p>
<p>比如我访问  http://localhost:8080/ ，就会找静态资源文件夹下的 index.html</p>
<p>在static目录下新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试  http://localhost:8080/  看结果！</p>
<p><mark><strong>关于网站图标说明</strong>：</mark></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588916438545.png" alt="" loading="lazy"></figure>
<p>将图标改名为favicon.ico放在public目录下即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot05：自动配置原理]]></title>
        <id>https://totoroay.github.io/post/springboot05zi-dong-pei-zhi-yuan-li/</id>
        <link href="https://totoroay.github.io/post/springboot05zi-dong-pei-zhi-yuan-li/">
        </link>
        <updated>2020-05-07T11:43:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springboot05自动配置原理">SpringBoot05：自动配置原理</h1>
<h2 id="自动配置原理">自动配置原理</h2>
<p>配置文件到底能写什么？怎么写？</p>
<p>SpringBoot官方文档中有大量的配置，我们无法全部记住</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588852012088.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>分析自动配置原理</p>
</blockquote>
<p>我们以**HttpEncodingAutoConfiguration（Http编码自动配置）**为例解释自动配置原理;</p>
<pre><code class="language-java">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；
@Configuration 

//启动指定类的ConfigurationProperties功能；
  //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；
  //并把HttpProperties加入到ioc容器中
@EnableConfigurationProperties({HttpProperties.class}) 

//Spring底层@Conditional注解
  //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；
  //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效
@ConditionalOnWebApplication(
    type = Type.SERVLET
)

//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
@ConditionalOnClass({CharacterEncodingFilter.class})

//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；
  //如果不存在，判断也是成立的
  //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
@ConditionalOnProperty(
    prefix = &quot;spring.http.encoding&quot;,
    value = {&quot;enabled&quot;},
    matchIfMissing = true
)

public class HttpEncodingAutoConfiguration {
    //他已经和SpringBoot的配置文件映射了
    private final Encoding properties;
    //只有一个有参构造器的情况下，参数的值就会从容器中拿
    public HttpEncodingAutoConfiguration(HttpProperties properties) {
        this.properties = properties.getEncoding();
    }
    
    //给容器中添加一个组件，这个组件的某些值需要从properties中获取
    @Bean
    @ConditionalOnMissingBean //判断容器没有这个组件？
    public CharacterEncodingFilter characterEncodingFilter() {
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));
        return filter;
    }
    //。。。。。。。
}
</code></pre>
<p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p>
<ul>
<li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li>
<li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li>
<li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li>
<li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li>
</ul>
<pre><code class="language-java">//从配置文件中获取指定的值和bean的属性进行绑定
@ConfigurationProperties(prefix = &quot;spring.http&quot;) 
public class HttpProperties {
    // .....
}
</code></pre>
<p>我们去配置文件里面试试前缀，看提示！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588852045330.png" alt="" loading="lazy"></figure>
<p><strong>这就是自动装配的原理！</strong></p>
<blockquote>
<p>精髓</p>
</blockquote>
<p>1、SpringBoot启动会加载大量的自动配置类</p>
<p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p>
<p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p>
<p>4、给容器中自动配置类添加组件的时候，会从xxxproperties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p>
<p>**xxxxAutoConfigurartion：自动配置类；**给容器中添加组件</p>
<p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p>
<blockquote>
<p>了解：@Conditional</p>
</blockquote>
<p>了解完自动装配的原理后，我们来关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588851996746.jpg" alt="" loading="lazy"></figure>
<p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p>
<p>我们怎么知道哪些自动配置类生效？</p>
<p><strong>我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p>
<pre><code class="language-yaml">#开启springboot的调试类
debug=true
</code></pre>
<p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p>
<p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p>
<p><strong>Unconditional classes: （没有条件的类）</strong></p>
<p>【演示：查看输出的日志】</p>
<p>掌握吸收理解原理，即可以不变应万变！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot04：JSR303数据校验及多环境切换]]></title>
        <id>https://totoroay.github.io/post/springboot04jsr303-shu-ju-xiao-yan-ji-duo-huan-jing-qie-huan/</id>
        <link href="https://totoroay.github.io/post/springboot04jsr303-shu-ju-xiao-yan-ji-duo-huan-jing-qie-huan/">
        </link>
        <updated>2020-05-07T05:46:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="jsr303数据校验">JSR303数据校验</h2>
<p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；</p>
<pre><code class="language-java">@Component // 注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated  // 数据校验
public class Person {

    @Email(message=&quot;邮箱格式错误&quot;) // name必须是邮箱格式
    private String name;
    // 后面自行补全
}
</code></pre>
<p>运行结果 ：default message [不是一个合法的电子邮件地址];</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588830441091.png" alt="" loading="lazy"></figure>
<p><strong>使用数据校验，可以保证数据的正确性；</strong></p>
<blockquote>
<p>常见参数</p>
</blockquote>
<pre><code class="language-yaml">@NotNull(message=&quot;名字不能为空&quot;)
private String userName;
@Max(value=120,message=&quot;年龄最大不能查过120&quot;)
private int age;
@Email(message=&quot;邮箱格式错误&quot;)
private String email;

空检查
@Null       验证对象是否为null
@NotNull    验证对象是否不为null, 无法查检长度为0的字符串
@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.
@NotEmpty   检查约束元素是否为NULL或者是EMPTY.
    
Booelan检查
@AssertTrue     验证 Boolean 对象是否为 true  
@AssertFalse    验证 Boolean 对象是否为 false  
    
长度检查
@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  
@Length(min=, max=) string is between min and max included.

日期检查
@Past       验证 Date 和 Calendar 对象是否在当前时间之前  
@Future     验证 Date 和 Calendar 对象是否在当前时间之后  
@Pattern    验证 String 对象是否符合正则表达式的规则
    
.......等等
除此以外，我们还可以自定义一些数据校验规则
</code></pre>
<h2 id="多环境切换">多环境切换</h2>
<p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；</p>
<blockquote>
<p>多配置文件</p>
</blockquote>
<p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；</p>
<p><strong>例如：</strong></p>
<p>application-test.properties 代表测试环境配置</p>
<p>application-dev.properties 代表开发环境配置</p>
<p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>；</p>
<p>我们需要通过一个配置来选择需要激活的环境：</p>
<pre><code>#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；
#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；
spring.profiles.active=dev
</code></pre>
<blockquote>
<p>yaml的多文档块</p>
</blockquote>
<p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p>
<pre><code class="language-yaml">server:
  port: 8081
#选择要激活那个环境块
spring:
  profiles:
    active: dev

---
server:
  port: 8083
spring:
  profiles: dev #配置环境的名称


---

server:
  port: 8084
spring:
  profiles: test #配置环境的名称
</code></pre>
<p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p>
<blockquote>
<p>配置文件加载位置</p>
</blockquote>
<p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p>
<p>官方外部配置文件说明参考文档</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588830456817.png" alt="" loading="lazy"></figure>
<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p>
<pre><code>优先级1：项目路径下的config文件夹配置文件
优先级2：项目路径下配置文件
优先级3：资源路径下的config文件夹配置文件
优先级4：资源路径下配置文件
</code></pre>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p>
<p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p>
<pre><code class="language-yaml">#配置项目的访问路径
server.servlet.context-path=/totoroay
</code></pre>
<blockquote>
<p>拓展，运维小技巧</p>
</blockquote>
<p>指定位置加载配置文件</p>
<p>我们还可以通过spring.config.location来改变默认的配置文件位置</p>
<p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p>
<pre><code>java -jar spring-boot-config.jar --spring.config.location=F:/application.properties
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[桥接模式]]></title>
        <id>https://totoroay.github.io/post/qiao-jie-mo-shi/</id>
        <link href="https://totoroay.github.io/post/qiao-jie-mo-shi/">
        </link>
        <updated>2020-05-06T12:15:57.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://totoroay.github.io//post-images/1588767488196.png" alt="" loading="lazy"><br>
<strong><mark>实例分析</mark></strong></p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588767482381.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">package totoroay.bridge;
// 品牌
public interface Brand {
    void info();
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 苹果品牌
public class Apple implements Brand {
    @Override
    public void info() {
        System.out.print(&quot;苹果&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 联想品牌
public class Lenovo implements Brand {
    @Override
    public void info() {
        System.out.print(&quot;联想&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 抽象的电脑类型类
public abstract class Computer {
    // 组合品牌
    protected Brand brand;

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void info(){
        brand.info();
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 笔记本电脑
public class Notebook extends Computer {
    public Notebook(Brand brand) {
        super(brand);
    }

    public void info(){
        brand.info();
        System.out.print(&quot;笔记本&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 台式机
public class Desktop extends Computer {
    public Desktop(Brand brand) {
        super(brand);
    }

    public void info(){
        brand.info();
        System.out.print(&quot;台式机&quot;);
    }
}

</code></pre>
<pre><code class="language-java">package totoroay.bridge;

public class test {
    public static void main(String[] args) {
        // 苹果笔记本
        Notebook notebook = new Notebook(new Apple());
        notebook.info();
        System.out.println(&quot;\n&quot;);
        // 联想台式机
        Desktop desktop = new Desktop(new Lenovo());
        desktop.info();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588767473029.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588767468462.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588767463245.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适配器模式]]></title>
        <id>https://totoroay.github.io/post/gua-pei-qi-mo-shi/</id>
        <link href="https://totoroay.github.io/post/gua-pei-qi-mo-shi/">
        </link>
        <updated>2020-05-06T09:37:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="适配器模式">适配器模式</h1>
<p><strong>结构型模式</strong></p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588757927882.png" alt="" loading="lazy"></figure>
<p><mark><strong>适配器模式</strong></mark></p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588757921508.png" alt="" loading="lazy"></figure>
<p>主要角色：</p>
<ul>
<li>目标接口</li>
<li>适配器类</li>
<li>适配者类</li>
</ul>
<h2 id="继承实现">继承实现</h2>
<pre><code class="language-java">package totoroay.adapter;
// 被适配的类：网线
public class Adapted {
    public void request(){
        System.out.println(&quot;连接网线上网&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 客户端：电脑，想上网
public class Computer {
    public void net(){
        // 上网的具体实现，找一个转接器
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 接口：转换器的抽象实现
public interface NetToUsb {
    // 处理请求，把网线插到转接器上
    void handleRequest();
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 适配器类：转换器的具体实现
// 类适配器：继承实现（不推荐使用）
public class Adapter extends Adapted implements NetToUsb{
    @Override
    public void handleRequest() {
        super.request();// 可以上网了
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 客户端：电脑，想上网
public class Computer {
    // 电脑需要连接转接器
    public void net(NetToUsb adapter){
        // 上网的具体实现，找一个转接器
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        Computer computer = new Computer();
        Adapted adapted = new Adapted();
        Adapter adapter = new Adapter();
        computer.net(adapter);
    }
}
</code></pre>
<h2 id="组合实现推荐使用">组合实现（推荐使用）</h2>
<pre><code class="language-java">package totoroay.adapter;
// 适配器类：转换器的具体实现
// 对象适配器：组合实现（推荐使用）
public class AdapterPlus implements NetToUsb{
    private Adapted adapted;

    public AdapterPlus(Adapted adapted){
        this.adapted = adapted;
    }
    @Override
    public void handleRequest() {
        adapted.request();
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
        Computer computer = new Computer();
        Adapted adapted = new Adapted();
        Adapter adapter = new Adapter();
        computer.net(adapter);
		System.out.println(&quot;=================&quot;);
    
        AdapterPlus adapterPlus = new AdapterPlus(adapted);
        computer.net(adapterPlus);
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588757906285.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代理/静态代理-模式]]></title>
        <id>https://totoroay.github.io/post/dai-li-jing-tai-dai-li-mo-shi/</id>
        <link href="https://totoroay.github.io/post/dai-li-jing-tai-dai-li-mo-shi/">
        </link>
        <updated>2020-05-05T10:12:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="静态代理">静态代理</h2>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588685234201.png" alt="" loading="lazy"></figure>
<p>角色分析</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色后，一般会做一些附属操作</li>
<li>客户：访问代理对象的人</li>
</ul>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 抽象角色
public interface Rent {
    void rent();
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 真实角色
public class Host implements Rent{
    public void rent() {
        System.out.println(&quot;房东要出租房子&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 代理角色
public class Proxy {
    private Host host;

    public Proxy() {}

    public Proxy(Host host) {
        this.host = host;
    }

    public void rent(){
        host.rent();
        seehouse();
    }

    public void seehouse(){
        System.out.println(&quot;看房&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 客户
public class Client {
    public static void main(String[] args) {
        Host host = new Host();
        Proxy proxy = new Proxy(host);
        proxy.rent();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588685225293.png" alt="" loading="lazy"></figure>
<p>代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量翻倍，开发效率会变低</li>
</ul>
<h2 id="加深理解">加深理解</h2>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588685218011.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 抽象角色
public interface UserService {
    void add();
    void delate();
    void update();
    void query();
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 真实角色
public class UserServiceImpl implements UserService{

    public void add() {
        System.out.println(&quot;增加用户&quot;);
    }

    public void delate() {
        System.out.println(&quot;删除用户&quot;);
    }

    public void update() {
        System.out.println(&quot;修改用户&quot;);
    }

    public void query() {
        System.out.println(&quot;查询用户&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 代理角色
public class UserServiceImplProxy {
    private UserServiceImpl userService;

    public UserServiceImpl getUserService() {
        return userService;
    }

    public void setUserService(UserServiceImpl userService) {
        this.userService = userService;
    }

    public void add(){
        userService.add();
        this.log(&quot;增加&quot;);
    }
    public void delate(){
        userService.delate();
    }
    public void update(){
        userService.update();
    }
    public void query(){
        userService.query();
    }

    public void log(String msg){
        System.out.println(&quot;[Debug] &quot;+msg+&quot;错误&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 客户
public class Client {
    public static void main(String[] args) {
        UserServiceImpl userService = new UserServiceImpl();
        UserServiceImplProxy proxy = new UserServiceImplProxy();
        proxy.setUserService(userService);
        proxy.add();
        proxy.delate();
        proxy.update();
        proxy.query();
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588685206797.png" alt="" loading="lazy"></figure>
<h2 id="动态代理">动态代理</h2>
<ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的！</li>
<li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理
<ul>
<li>基于接口---JDK 动态代理	【代码实现】</li>
<li>基于类：cglib</li>
<li>java字节码：javasist</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy：代理，InvocationHandler</p>
<pre><code class="language-java">package totoroay.proxy.demo3;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyInvocationHandler implements InvocationHandler {
    //被代理的接口
    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    // 生成，得到代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }

    // 处理代理实例并返回结果(实现代理类方法)
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object invoke = method.invoke(target,args);
        return invoke;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo3;

import totoroay.proxy.demo2.UserService;
import totoroay.proxy.demo2.UserServiceImpl;

public class Client {
    public static void main(String[] args) {
        //真实对象
        UserServiceImpl userService = new UserServiceImpl();
        // 代理角色
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        // 设置要代理的对象
        pih.setTarget(userService);
        // 动态生成代理类
        UserService proxy = (UserService) pih.getProxy();
        proxy.add();
    }
}
</code></pre>
]]></content>
    </entry>
</feed>