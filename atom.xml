<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://totoroay.github.io/</id>
    <title>totoroay</title>
    <updated>2020-05-07T11:47:30.180Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://totoroay.github.io/"/>
    <link rel="self" href="https://totoroay.github.io/atom.xml"/>
    <subtitle>每天学习5小时！！！</subtitle>
    <logo>https://totoroay.github.io/images/avatar.png</logo>
    <icon>https://totoroay.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, totoroay</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot05：自动配置原理]]></title>
        <id>https://totoroay.github.io/post/springboot05zi-dong-pei-zhi-yuan-li/</id>
        <link href="https://totoroay.github.io/post/springboot05zi-dong-pei-zhi-yuan-li/">
        </link>
        <updated>2020-05-07T11:43:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springboot05自动配置原理">SpringBoot05：自动配置原理</h1>
<h2 id="自动配置原理">自动配置原理</h2>
<p>配置文件到底能写什么？怎么写？</p>
<p>SpringBoot官方文档中有大量的配置，我们无法全部记住</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588852012088.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>分析自动配置原理</p>
</blockquote>
<p>我们以**HttpEncodingAutoConfiguration（Http编码自动配置）**为例解释自动配置原理;</p>
<pre><code class="language-java">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；
@Configuration 

//启动指定类的ConfigurationProperties功能；
  //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；
  //并把HttpProperties加入到ioc容器中
@EnableConfigurationProperties({HttpProperties.class}) 

//Spring底层@Conditional注解
  //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；
  //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效
@ConditionalOnWebApplication(
    type = Type.SERVLET
)

//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
@ConditionalOnClass({CharacterEncodingFilter.class})

//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；
  //如果不存在，判断也是成立的
  //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
@ConditionalOnProperty(
    prefix = &quot;spring.http.encoding&quot;,
    value = {&quot;enabled&quot;},
    matchIfMissing = true
)

public class HttpEncodingAutoConfiguration {
    //他已经和SpringBoot的配置文件映射了
    private final Encoding properties;
    //只有一个有参构造器的情况下，参数的值就会从容器中拿
    public HttpEncodingAutoConfiguration(HttpProperties properties) {
        this.properties = properties.getEncoding();
    }
    
    //给容器中添加一个组件，这个组件的某些值需要从properties中获取
    @Bean
    @ConditionalOnMissingBean //判断容器没有这个组件？
    public CharacterEncodingFilter characterEncodingFilter() {
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));
        return filter;
    }
    //。。。。。。。
}
</code></pre>
<p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p>
<ul>
<li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li>
<li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li>
<li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li>
<li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li>
</ul>
<pre><code class="language-java">//从配置文件中获取指定的值和bean的属性进行绑定
@ConfigurationProperties(prefix = &quot;spring.http&quot;) 
public class HttpProperties {
    // .....
}
</code></pre>
<p>我们去配置文件里面试试前缀，看提示！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588852045330.png" alt="" loading="lazy"></figure>
<p><strong>这就是自动装配的原理！</strong></p>
<blockquote>
<p>精髓</p>
</blockquote>
<p>1、SpringBoot启动会加载大量的自动配置类</p>
<p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p>
<p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p>
<p>4、给容器中自动配置类添加组件的时候，会从xxxproperties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p>
<p>**xxxxAutoConfigurartion：自动配置类；**给容器中添加组件</p>
<p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p>
<blockquote>
<p>了解：@Conditional</p>
</blockquote>
<p>了解完自动装配的原理后，我们来关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588851996746.jpg" alt="" loading="lazy"></figure>
<p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p>
<p>我们怎么知道哪些自动配置类生效？</p>
<p><strong>我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p>
<pre><code class="language-yaml">#开启springboot的调试类
debug=true
</code></pre>
<p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p>
<p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p>
<p><strong>Unconditional classes: （没有条件的类）</strong></p>
<p>【演示：查看输出的日志】</p>
<p>掌握吸收理解原理，即可以不变应万变！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot04：JSR303数据校验及多环境切换]]></title>
        <id>https://totoroay.github.io/post/springboot04jsr303-shu-ju-xiao-yan-ji-duo-huan-jing-qie-huan/</id>
        <link href="https://totoroay.github.io/post/springboot04jsr303-shu-ju-xiao-yan-ji-duo-huan-jing-qie-huan/">
        </link>
        <updated>2020-05-07T05:46:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="jsr303数据校验">JSR303数据校验</h2>
<p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；</p>
<pre><code class="language-java">@Component // 注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated  // 数据校验
public class Person {

    @Email(message=&quot;邮箱格式错误&quot;) // name必须是邮箱格式
    private String name;
    // 后面自行补全
}
</code></pre>
<p>运行结果 ：default message [不是一个合法的电子邮件地址];</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588830441091.png" alt="" loading="lazy"></figure>
<p><strong>使用数据校验，可以保证数据的正确性；</strong></p>
<blockquote>
<p>常见参数</p>
</blockquote>
<pre><code class="language-yaml">@NotNull(message=&quot;名字不能为空&quot;)
private String userName;
@Max(value=120,message=&quot;年龄最大不能查过120&quot;)
private int age;
@Email(message=&quot;邮箱格式错误&quot;)
private String email;

空检查
@Null       验证对象是否为null
@NotNull    验证对象是否不为null, 无法查检长度为0的字符串
@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.
@NotEmpty   检查约束元素是否为NULL或者是EMPTY.
    
Booelan检查
@AssertTrue     验证 Boolean 对象是否为 true  
@AssertFalse    验证 Boolean 对象是否为 false  
    
长度检查
@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  
@Length(min=, max=) string is between min and max included.

日期检查
@Past       验证 Date 和 Calendar 对象是否在当前时间之前  
@Future     验证 Date 和 Calendar 对象是否在当前时间之后  
@Pattern    验证 String 对象是否符合正则表达式的规则
    
.......等等
除此以外，我们还可以自定义一些数据校验规则
</code></pre>
<h2 id="多环境切换">多环境切换</h2>
<p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；</p>
<blockquote>
<p>多配置文件</p>
</blockquote>
<p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；</p>
<p><strong>例如：</strong></p>
<p>application-test.properties 代表测试环境配置</p>
<p>application-dev.properties 代表开发环境配置</p>
<p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>；</p>
<p>我们需要通过一个配置来选择需要激活的环境：</p>
<pre><code>#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；
#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；
spring.profiles.active=dev
</code></pre>
<blockquote>
<p>yaml的多文档块</p>
</blockquote>
<p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p>
<pre><code class="language-yaml">server:
  port: 8081
#选择要激活那个环境块
spring:
  profiles:
    active: dev

---
server:
  port: 8083
spring:
  profiles: dev #配置环境的名称


---

server:
  port: 8084
spring:
  profiles: test #配置环境的名称
</code></pre>
<p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p>
<blockquote>
<p>配置文件加载位置</p>
</blockquote>
<p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p>
<p>官方外部配置文件说明参考文档</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588830456817.png" alt="" loading="lazy"></figure>
<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p>
<pre><code>优先级1：项目路径下的config文件夹配置文件
优先级2：项目路径下配置文件
优先级3：资源路径下的config文件夹配置文件
优先级4：资源路径下配置文件
</code></pre>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p>
<p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p>
<pre><code class="language-yaml">#配置项目的访问路径
server.servlet.context-path=/totoroay
</code></pre>
<blockquote>
<p>拓展，运维小技巧</p>
</blockquote>
<p>指定位置加载配置文件</p>
<p>我们还可以通过spring.config.location来改变默认的配置文件位置</p>
<p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p>
<pre><code>java -jar spring-boot-config.jar --spring.config.location=F:/application.properties
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[桥接模式]]></title>
        <id>https://totoroay.github.io/post/qiao-jie-mo-shi/</id>
        <link href="https://totoroay.github.io/post/qiao-jie-mo-shi/">
        </link>
        <updated>2020-05-06T12:15:57.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://totoroay.github.io//post-images/1588767488196.png" alt="" loading="lazy"><br>
<strong><mark>实例分析</mark></strong></p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588767482381.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">package totoroay.bridge;
// 品牌
public interface Brand {
    void info();
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 苹果品牌
public class Apple implements Brand {
    @Override
    public void info() {
        System.out.print(&quot;苹果&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 联想品牌
public class Lenovo implements Brand {
    @Override
    public void info() {
        System.out.print(&quot;联想&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 抽象的电脑类型类
public abstract class Computer {
    // 组合品牌
    protected Brand brand;

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void info(){
        brand.info();
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 笔记本电脑
public class Notebook extends Computer {
    public Notebook(Brand brand) {
        super(brand);
    }

    public void info(){
        brand.info();
        System.out.print(&quot;笔记本&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 台式机
public class Desktop extends Computer {
    public Desktop(Brand brand) {
        super(brand);
    }

    public void info(){
        brand.info();
        System.out.print(&quot;台式机&quot;);
    }
}

</code></pre>
<pre><code class="language-java">package totoroay.bridge;

public class test {
    public static void main(String[] args) {
        // 苹果笔记本
        Notebook notebook = new Notebook(new Apple());
        notebook.info();
        System.out.println(&quot;\n&quot;);
        // 联想台式机
        Desktop desktop = new Desktop(new Lenovo());
        desktop.info();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588767473029.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588767468462.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588767463245.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适配器模式]]></title>
        <id>https://totoroay.github.io/post/gua-pei-qi-mo-shi/</id>
        <link href="https://totoroay.github.io/post/gua-pei-qi-mo-shi/">
        </link>
        <updated>2020-05-06T09:37:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="适配器模式">适配器模式</h1>
<p><strong>结构型模式</strong></p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588757927882.png" alt="" loading="lazy"></figure>
<p><mark><strong>适配器模式</strong></mark></p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588757921508.png" alt="" loading="lazy"></figure>
<p>主要角色：</p>
<ul>
<li>目标接口</li>
<li>适配器类</li>
<li>适配者类</li>
</ul>
<h2 id="继承实现">继承实现</h2>
<pre><code class="language-java">package totoroay.adapter;
// 被适配的类：网线
public class Adapted {
    public void request(){
        System.out.println(&quot;连接网线上网&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 客户端：电脑，想上网
public class Computer {
    public void net(){
        // 上网的具体实现，找一个转接器
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 接口：转换器的抽象实现
public interface NetToUsb {
    // 处理请求，把网线插到转接器上
    void handleRequest();
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 适配器类：转换器的具体实现
// 类适配器：继承实现（不推荐使用）
public class Adapter extends Adapted implements NetToUsb{
    @Override
    public void handleRequest() {
        super.request();// 可以上网了
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 客户端：电脑，想上网
public class Computer {
    // 电脑需要连接转接器
    public void net(NetToUsb adapter){
        // 上网的具体实现，找一个转接器
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        Computer computer = new Computer();
        Adapted adapted = new Adapted();
        Adapter adapter = new Adapter();
        computer.net(adapter);
    }
}
</code></pre>
<h2 id="组合实现推荐使用">组合实现（推荐使用）</h2>
<pre><code class="language-java">package totoroay.adapter;
// 适配器类：转换器的具体实现
// 对象适配器：组合实现（推荐使用）
public class AdapterPlus implements NetToUsb{
    private Adapted adapted;

    public AdapterPlus(Adapted adapted){
        this.adapted = adapted;
    }
    @Override
    public void handleRequest() {
        adapted.request();
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
        Computer computer = new Computer();
        Adapted adapted = new Adapted();
        Adapter adapter = new Adapter();
        computer.net(adapter);
		System.out.println(&quot;=================&quot;);
    
        AdapterPlus adapterPlus = new AdapterPlus(adapted);
        computer.net(adapterPlus);
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588757906285.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代理/静态代理-模式]]></title>
        <id>https://totoroay.github.io/post/dai-li-jing-tai-dai-li-mo-shi/</id>
        <link href="https://totoroay.github.io/post/dai-li-jing-tai-dai-li-mo-shi/">
        </link>
        <updated>2020-05-05T10:12:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="静态代理">静态代理</h2>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588685234201.png" alt="" loading="lazy"></figure>
<p>角色分析</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色后，一般会做一些附属操作</li>
<li>客户：访问代理对象的人</li>
</ul>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 抽象角色
public interface Rent {
    void rent();
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 真实角色
public class Host implements Rent{
    public void rent() {
        System.out.println(&quot;房东要出租房子&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 代理角色
public class Proxy {
    private Host host;

    public Proxy() {}

    public Proxy(Host host) {
        this.host = host;
    }

    public void rent(){
        host.rent();
        seehouse();
    }

    public void seehouse(){
        System.out.println(&quot;看房&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 客户
public class Client {
    public static void main(String[] args) {
        Host host = new Host();
        Proxy proxy = new Proxy(host);
        proxy.rent();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588685225293.png" alt="" loading="lazy"></figure>
<p>代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量翻倍，开发效率会变低</li>
</ul>
<h2 id="加深理解">加深理解</h2>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588685218011.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 抽象角色
public interface UserService {
    void add();
    void delate();
    void update();
    void query();
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 真实角色
public class UserServiceImpl implements UserService{

    public void add() {
        System.out.println(&quot;增加用户&quot;);
    }

    public void delate() {
        System.out.println(&quot;删除用户&quot;);
    }

    public void update() {
        System.out.println(&quot;修改用户&quot;);
    }

    public void query() {
        System.out.println(&quot;查询用户&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 代理角色
public class UserServiceImplProxy {
    private UserServiceImpl userService;

    public UserServiceImpl getUserService() {
        return userService;
    }

    public void setUserService(UserServiceImpl userService) {
        this.userService = userService;
    }

    public void add(){
        userService.add();
        this.log(&quot;增加&quot;);
    }
    public void delate(){
        userService.delate();
    }
    public void update(){
        userService.update();
    }
    public void query(){
        userService.query();
    }

    public void log(String msg){
        System.out.println(&quot;[Debug] &quot;+msg+&quot;错误&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 客户
public class Client {
    public static void main(String[] args) {
        UserServiceImpl userService = new UserServiceImpl();
        UserServiceImplProxy proxy = new UserServiceImplProxy();
        proxy.setUserService(userService);
        proxy.add();
        proxy.delate();
        proxy.update();
        proxy.query();
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588685206797.png" alt="" loading="lazy"></figure>
<h2 id="动态代理">动态代理</h2>
<ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的！</li>
<li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理
<ul>
<li>基于接口---JDK 动态代理	【代码实现】</li>
<li>基于类：cglib</li>
<li>java字节码：javasist</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy：代理，InvocationHandler</p>
<pre><code class="language-java">package totoroay.proxy.demo3;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyInvocationHandler implements InvocationHandler {
    //被代理的接口
    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    // 生成，得到代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }

    // 处理代理实例并返回结果(实现代理类方法)
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object invoke = method.invoke(target,args);
        return invoke;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo3;

import totoroay.proxy.demo2.UserService;
import totoroay.proxy.demo2.UserServiceImpl;

public class Client {
    public static void main(String[] args) {
        //真实对象
        UserServiceImpl userService = new UserServiceImpl();
        // 代理角色
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        // 设置要代理的对象
        pih.setTarget(userService);
        // 动态生成代理类
        UserService proxy = (UserService) pih.getProxy();
        proxy.add();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[建造者模式]]></title>
        <id>https://totoroay.github.io/post/jian-zao-zhe-mo-shi/</id>
        <link href="https://totoroay.github.io/post/jian-zao-zhe-mo-shi/">
        </link>
        <updated>2020-05-05T09:50:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="建造者模式">建造者模式</h1>
<p><img src="https://totoroay.github.io//post-images/1588672365938.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1588672372510.png" alt="" loading="lazy"></p>
<h6 id="demo1"><mark>demo1</mark></h6>
<pre><code class="language-java">package totoroay.builder.demo1;
// 抽象的建造者：方法
public abstract class Builder {
    abstract void buildA();// 地基
    abstract void buildB();// 钢筋工程
    abstract void buildC();// 铺电线
    abstract void buildD();// 粉刷

    // 完工：得到产品
    abstract Product getProduct();
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;
// 产品：房子
public class Product {
    private String buildA;// 地基
    private String buildB;// 钢筋工程
    private String buildC;// 铺电线
    private String buildD;// 粉刷
    
    //get,set,toString方法自己补全
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;
// 具体的建造者：工人
public class Worker extends Builder {
    private Product product;

    // 工人生产产品
    public Worker() {
        product = new Product();
    }

    @Override
    void buildA() {
        product.setBuildA(&quot;地基&quot;);
        System.out.println(&quot;地基&quot;);
    }

    @Override
    void buildB() {
        product.setBuildB(&quot;钢筋工程&quot;);
        System.out.println(&quot;钢筋工程&quot;);
    }

    @Override
    void buildC() {
        product.setBuildC(&quot;铺电线&quot;);
        System.out.println(&quot;铺电线&quot;);
    }

    @Override
    void buildD() {
        product.setBuildD(&quot;粉刷&quot;);
        System.out.println(&quot;粉刷&quot;);
    }

    @Override
    Product getProduct() {
        return product;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;
// 指挥：核心。负责指挥构建一个工程，有它决定
public class Director {
    // 指挥具体的工人建房子
    public Product builder(Builder builder){
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();
        return builder.getProduct();
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;

public class Test {
    public static void main(String[] args) {
        // 指挥
        Director director = new Director();
        // 指挥具体的工人完成产品
        Product builder = director.builder(new Worker());
        System.out.println(builder.toString());
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588672354974.png" alt="" loading="lazy"></figure>
<h6 id="demo2"><mark>demo2</mark></h6>
<pre><code class="language-java">package totoroay.builder.demo2;
// 抽象的建造者：方法
public abstract class Builder {
    // 静态内部类方式
    abstract Builder buildA(String msg);// 汉堡
    abstract Builder buildB(String msg);// 可乐
    abstract Builder buildC(String msg);// 薯条
    abstract Builder buildD(String msg);// 甜品

    // 完工：得到产品
    abstract Product getProduct();
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo2;
// 产品：套餐
public class Product {
    private String buildA = &quot;汉堡&quot;;// 汉堡
    private String buildB = &quot;可乐&quot;;// 可乐
    private String buildC = &quot;薯条&quot;;// 薯条
    private String buildD = &quot;甜品&quot;;// 甜品
    
    //get,set,toString方法自己补全
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo2;
// 具体的建造者
public class Worker extends Builder {
    private Product product;

    public Worker(){
        product = new Product();
    }

    @Override
    Builder buildA(String msg) {
        product.setBuildA(msg);
        return this;
    }

    @Override
    Builder buildB(String msg) {
        product.setBuildB(msg);
        return this;
    }

    @Override
    Builder buildC(String msg) {
        product.setBuildC(msg);
        return this;
    }

    @Override
    Builder buildD(String msg) {
        product.setBuildD(msg);
        return this;
    }

    @Override
    Product getProduct() {
        return product;
    }
}

</code></pre>
<pre><code class="language-java">package totoroay.builder.demo2;

public class Test {
    public static void main(String[] args) {
        // 服务员，默认套餐
        Worker worker = new Worker();
        Product product = worker.getProduct();
        System.out.println(product.toString());

        // 另一个服务员
        Worker worker1 = new Worker();
        // 链式编程
        Product product1 = worker1.buildA(&quot;牛肉汉堡&quot;).buildB(&quot;大杯可乐&quot;)
                .getProduct();
        System.out.println(product1.toString());
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588672343175.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588672337519.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：依赖注入（DI）]]></title>
        <id>https://totoroay.github.io/post/springyi-lai-zhu-ru-di/</id>
        <link href="https://totoroay.github.io/post/springyi-lai-zhu-ru-di/">
        </link>
        <updated>2020-05-05T04:10:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dependency-injection">Dependency Injection</h2>
<blockquote>
<p>概念</p>
</blockquote>
<ul>
<li>依赖注入（Dependency Injection,DI）。</li>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配</li>
</ul>
<blockquote>
<p>构造器注入</p>
</blockquote>
<p>我们在之前的案例已经讲过了</p>
<blockquote>
<p>Set 注入 （重点）</p>
</blockquote>
<p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p>
<p>测试pojo类 :</p>
<p>Address.java</p>
<pre><code class="language-java">package com.totoroay.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Address {
    private String address;
}

</code></pre>
<p>Student.java</p>
<pre><code class="language-java">package com.totoroay.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.*;
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbies;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;
}
</code></pre>
<p>beans.xml：<mark><strong>各种注入方式</strong></mark></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--pojo，bean注入，注意点：这里的值是一个引用，ref--&gt;
    &lt;bean id=&quot;address&quot; class=&quot;com.totoroay.pojo.Address&quot;&gt;
        &lt;property name=&quot;address&quot; value=&quot;武汉&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;student&quot; class=&quot;com.totoroay.pojo.Student&quot;&gt;
        &lt;!--string，常量注入--&gt;
        &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
        &lt;!--pojo，bean注入，注意点：这里的值是一个引用，ref--&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
        &lt;!--array，数组注入--&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;java&lt;/value&gt;
                &lt;value&gt;paython&lt;/value&gt;
                &lt;value&gt;php&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--list，List注入--&gt;
        &lt;property name=&quot;hobbies&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;打游戏&lt;/value&gt;
                &lt;value&gt;打篮球&lt;/value&gt;
                &lt;value&gt;编程&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--map，Map注入--&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;14381983491084&quot;/&gt;
                &lt;entry key=&quot;银行卡&quot; value=&quot;1231238798798798&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--set--&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;lol&lt;/value&gt;
                &lt;value&gt;coc&lt;/value&gt;
                &lt;value&gt;coc&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;!--null，Null注入--&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;
        &lt;!--Properties注入--&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;学号&quot;&gt;20178213718&lt;/prop&gt;
                &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试结果：</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588651878727.png" alt="" loading="lazy"></figure>
<blockquote>
<p>Bean的作用域</p>
</blockquote>
<p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588651855715.png" alt="" loading="lazy"></figure>
<p>几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<h4 id="singleton">Singleton</h4>
<p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，<mark>默认</mark>，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; scope=&quot;singleton&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;33&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@Test
public void test03(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);
    User user = context.getBean(&quot;user&quot;, User.class);
    User user2 = context.getBean(&quot;user&quot;, User.class);
    System.out.println(user==user2);
}
</code></pre>
<h4 id="prototype">Prototype</h4>
<p>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
<h4 id="request">Request</h4>
<p>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<h4 id="session">Session</h4>
<p>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot03：yaml配置注入]]></title>
        <id>https://totoroay.github.io/post/springboot03yaml-pei-zhi-zhu-ru/</id>
        <link href="https://totoroay.github.io/post/springboot03yaml-pei-zhi-zhu-ru/">
        </link>
        <updated>2020-05-04T12:12:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="配置文件">配置文件</h3>
<p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p>
<ul>
<li>
<p>application.properties</p>
</li>
<li>
<ul>
<li>语法结构 ：key=value</li>
</ul>
</li>
<li>
<p>application.yml</p>
</li>
<li>
<ul>
<li>语法结构 ：key：空格 value</li>
</ul>
</li>
</ul>
<p>**配置文件的作用 ：**修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p>
<p>比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！</p>
<pre><code class="language-properties">server.port=8081
</code></pre>
<h3 id="yaml概述">yaml概述</h3>
<p>YAML是 &quot;YAML Ain't a Markup Language&quot; （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）</p>
<p><strong>这种语言以数据<strong><strong>作</strong></strong>为中心，而不是以标记语言为重点！</strong></p>
<p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p>
<p>传统xml配置：</p>
<pre><code class="language-xml">&lt;server&gt;    
    &lt;port&gt;8081&lt;port&gt;
&lt;/server&gt;
</code></pre>
<p>yaml配置：</p>
<pre><code class="language-yaml">server：  prot: 8080
</code></pre>
<h3 id="yaml基础语法">yaml基础语法</h3>
<p>说明：语法要求严格！</p>
<p>1、空格不能省略</p>
<p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p>
<p>3、属性和值的大小写都是十分敏感的。</p>
<p><strong>字面量：普通的值  [ 数字，布尔值，字符串  ]</strong></p>
<p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p>
<pre><code class="language-yaml">k: v
</code></pre>
<p>注意：</p>
<ul>
<li>
<p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p>
<p>比如 ：name: &quot;totoroay\n ayoung&quot;  输出 ：totoroay 换行  ayoung</p>
</li>
<li>
<p>'' 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p>
<p>比如 ：name: ‘totoroay\n ayoung’  输出 ：totoroay  \n  ayoung</p>
</li>
</ul>
<p><strong>对象、Map（键值对）</strong></p>
<pre><code class="language-yaml">#对象、Map格式k:     v1:    v2:
</code></pre>
<p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p>
<pre><code class="language-yaml">student:
	name: totoroay    age: 99
</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">student: {name: totoroay,age: 99}
</code></pre>
<p><strong>数组（ List、set ）</strong></p>
<p>用 - 值表示数组中的一个元素,比如：</p>
<pre><code class="language-yaml">pets:
 - cat
 - dog
 - pig
</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">pets: [cat,dog,pig]
</code></pre>
<p><strong>修改SpringBoot的默认端口号</strong></p>
<p>配置文件中添加，端口号的参数，就可以切换端口；</p>
<pre><code class="language-yaml">server:  
  port: 8081
</code></pre>
<h3 id="yaml注入配置文件">yaml注入配置文件</h3>
<p>yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！</p>
<blockquote>
<p>yaml注入配置文件</p>
</blockquote>
<p>1、在springboot项目中的resources目录下新建一个文件 application.yml</p>
<p>2、编写一个实体类 Dog；</p>
<pre><code class="language-java">package com.totoroay.pojo;

@Component  //注册bean到容器中
public class Dog {
    private String name;
    private Integer age;
    
    //有参无参构造、get、set方法、toString()方法  
}
</code></pre>
<p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p>
<pre><code class="language-java">@Component //注册bean
public class Dog {
    @Value(&quot;阿黄&quot;)
    private String name;
    @Value(&quot;9&quot;)
    private Integer age;
}
</code></pre>
<p>4、在SpringBoot的测试类下注入狗狗输出一下；</p>
<pre><code class="language-java">@SpringBootTest
class Springboot02ConofigApplicationTests {

    @Autowired //将狗狗自动注入进来
    Dog dog;

    @Test
    void contextLoads() {
        System.out.println(dog); //打印看下狗狗对象
    }

}
</code></pre>
<p>结果成功输出，@Value注入成功，这是我们原来的办法对吧。</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588594490094.png" alt="" loading="lazy"></figure>
<p>5、我们在编写一个复杂一点的实体类：Person 类</p>
<pre><code class="language-java">@Component //注册bean到容器中
public class Person {
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
    
    //有参无参构造、get、set方法、toString()方法  
}
</code></pre>
<p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p>
<pre><code class="language-yaml">person:
  name: totoroay
  age: 19
  happy: false
  birth: 1999/09/09
  maps: {k1: v1,k2: v2}
  lists:
    - code
    - girl
    - music
    - game
  dog:
    name: 阿花
    age: 9
</code></pre>
<p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p>
<pre><code class="language-java">/*
@ConfigurationProperties作用：
将配置文件中配置的每一个属性的值，映射到这个组件中；
告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定
参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应
*/
@Component //注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
}
</code></pre>
<p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588594502287.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588594507982.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>9、确认以上配置都OK之后，我们去测试类中测试一下：</p>
<pre><code class="language-java">@SpringBootTest
class DemoApplicationTests {

    @Autowired
    Person person; //将person自动注入进来

    @Test
    public void contextLoads() {
        System.out.println(person); //打印person信息
    }

}
</code></pre>
<p>结果：所有值全部注入成功！</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588594519838.png" alt="" loading="lazy"></figure>
<p><strong>yaml配置注入到实体类完全OK！</strong></p>
<p>课堂测试：</p>
<p>1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败</p>
<p>2、在配置一个person2，然后将 @ConfigurationProperties(prefix = &quot;person2&quot;) 指向我们的person2；</p>
<h3 id="加载指定的配置文件">加载指定的配置文件</h3>
<p>**@PropertySource ：**加载指定的配置文件；</p>
<p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p>
<p>1、我们去在resources目录下新建一个<strong>person.properties</strong>文件</p>
<pre><code class="language-properties">name=zy
</code></pre>
<p>2、然后在我们的代码中指定加载person.properties文件</p>
<pre><code class="language-java">@PropertySource(value = &quot;classpath:person.properties&quot;)
@Component //注册bean
public class Person {

    @Value(&quot;${name}&quot;)
    private String name;

    ......  
}
</code></pre>
<p>3、再次输出测试一下：指定配置文件绑定成功！</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1588594529477.png" alt="" loading="lazy"></figure>
<h3 id="配置文件占位符">配置文件占位符</h3>
<p>配置文件还可以编写占位符生成随机数</p>
<pre><code class="language-yaml">person:
    name: totoroay${random.uuid} # 随机uuid
    age: ${random.int}  # 随机int
    happy: false
    birth: 1999/09/09
    maps: {k1: v1,k2: v2}
    lists:
      - code
      - girl
      - music
      - game
    dog:
      name: ${person.hello:other}_旺财
      age: 1
</code></pre>
<h3 id="回顾properties配置">回顾properties配置</h3>
<p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！</p>
<p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p>
<p>settings--&gt;FileEncodings 中配置；</p>
<p><img src="https://totoroay.github.io//post-images/1588594536690.png" alt="" loading="lazy"><br>
<strong>测试步骤：</strong></p>
<p>1、新建一个实体类User</p>
<pre><code class="language-java">@Component //注册bean
public class User {
    private String name;
    private int age;
    private String sex;
}
</code></pre>
<p>2、编辑配置文件 user.properties</p>
<pre><code class="language-properties">user1.name=kuangshenuser1.age=18user1.sex=男
</code></pre>
<p>3、我们在User类上使用@Value来进行注入！</p>
<pre><code class="language-java">@Component //注册bean
@PropertySource(value = &quot;classpath:user.properties&quot;)
public class User {
    //直接使用@value
    @Value(&quot;${user.name}&quot;) //从配置文件中取值
    private String name;
    @Value(&quot;#{9*2}&quot;)  // #{SPEL} Spring表达式
    private int age;
    @Value(&quot;男&quot;)  // 字面量
    private String sex;
}
</code></pre>
<p>4、Springboot测试</p>
<pre><code class="language-java">@SpringBootTest
class DemoApplicationTests {

    @Autowired
    User user;

    @Test
    public void contextLoads() {
        System.out.println(user);
    }

}
</code></pre>
<p>结果正常输出：</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1588594546320.png" alt="" loading="lazy"></figure>
<h3 id="对比小结">对比小结</h3>
<p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1588594553170.png" alt="" loading="lazy"></figure>
<p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p>
<p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p>
<p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p>
<p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p>
<p><strong>结论：</strong></p>
<p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p>
<p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p>
<p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot02：运行原理初探]]></title>
        <id>https://totoroay.github.io/post/springboot02yun-xing-yuan-li-chu-tan/</id>
        <link href="https://totoroay.github.io/post/springboot02yun-xing-yuan-li-chu-tan/">
        </link>
        <updated>2020-05-04T08:59:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springboot02运行原理初探">SpringBoot02：运行原理初探</h1>
<p><mark>自动配置</mark></p>
<h2 id="pomxml">pom.xml</h2>
<p>我们之前写的HelloSpringBoot，到底是怎么运行的呢，Maven项目，我们一般从pom.xml文件探究起；</p>
<h3 id="父依赖">父依赖</h3>
<p>其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
</code></pre>
<p>点进去，发现还有一个父依赖</p>
<p>我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为这些版本仓库</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre>
<p>这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p>
<p><strong>以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p>
<h3 id="启动器-spring-boot-starter">启动器 spring-boot-starter</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p>
<p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p>
<p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p>
<h2 id="主启动类">主启动类</h2>
<p>分析完了 pom.xml 来看看这个启动类</p>
<h3 id="默认的主启动类">默认的主启动类</h3>
<pre><code class="language-java">//@SpringBootApplication 来标注一个主程序类
//说明这是一个Spring Boot应用
@SpringBootApplication
public class SpringbootApplication {

   public static void main(String[] args) {
     //以为是启动了一个方法，没想到启动了一个服务
      SpringApplication.run(SpringbootApplication.class, args);
   }

}
</code></pre>
<p>但是**一个简单的启动类并不简单！**我们来分析一下这些注解都干了什么</p>
<h3 id="springbootapplication">@SpringBootApplication</h3>
<p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>进入这个注解：可以看到上面还有很多其他注解！</p>
<pre><code class="language-java">@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
    // ......
}
</code></pre>
<h3 id="componentscan">@ComponentScan</h3>
<p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p>
<p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p>
<h3 id="springbootconfiguration">@SpringBootConfiguration</h3>
<p>作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p>
<p>我们继续进去这个注解查看</p>
<pre><code class="language-java">// 点进去得到下面的 @Component
@Configuration
public @interface SpringBootConfiguration {}

@Component
public @interface Configuration {}
</code></pre>
<p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p>
<p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p>
<p>我们回到 SpringBootApplication 注解中继续看。</p>
<h3 id="enableautoconfiguration">@EnableAutoConfiguration</h3>
<p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p>
<p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p>
<p>点进注解接续查看：</p>
<p><strong>@AutoConfigurationPackage ：自动配置包</strong></p>
<pre><code class="language-java">@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage {

}
</code></pre>
<p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p>
<p>Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</p>
<p>这个分析完了，退到上一步，继续看</p>
<p><strong>@Import(AutoConfigurationImportSelector.class) ：给容器导入组件 ；</strong></p>
<p>AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p>
<p>1、这个类中有一个这样的方法</p>
<pre><code class="language-java">// 获得候选的配置
protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
    //这里的getSpringFactoriesLoaderFactoryClass（）方法
    //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration
    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);
    return configurations;
}
</code></pre>
<p>2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法</p>
<pre><code class="language-java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {
    String factoryClassName = factoryClass.getName();
    //这里它又调用了 loadSpringFactories 方法
    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
}
</code></pre>
<p>3、我们继续点击查看 loadSpringFactories 方法</p>
<pre><code class="language-java">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {
    //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身
    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);
    if (result != null) {
        return result;
    } else {
        try {
            //去获取一个资源 &quot;META-INF/spring.factories&quot;
            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);
            LinkedMultiValueMap result = new LinkedMultiValueMap();

            //将读取到的资源遍历，封装成为一个Properties
            while(urls.hasMoreElements()) {
                URL url = (URL)urls.nextElement();
                UrlResource resource = new UrlResource(url);
                Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                Iterator var6 = properties.entrySet().iterator();

                while(var6.hasNext()) {
                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();
                    String factoryClassName = ((String)entry.getKey()).trim();
                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());
                    int var10 = var9.length;

                    for(int var11 = 0; var11 &lt; var10; ++var11) {
                        String factoryName = var9[var11];
                        result.add(factoryClassName, factoryName.trim());
                    }
                }
            }

            cache.put(classLoader, result);
            return result;
        } catch (IOException var13) {
            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);
        }
    }
}
</code></pre>
<p>4、发现一个多次出现的文件：spring.factories，全局搜索它</p>
<h3 id="springfactories">spring.factories</h3>
<p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588583000379.png" alt="" loading="lazy"></figure>
<p><strong>WebMvcAutoConfiguration</strong></p>
<p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588582994094.png" alt="" loading="lazy"></figure>
<p>可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p>
<p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>
<p><strong>结论：</strong></p>
<ol>
<li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li>
<li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li>
<li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li>
<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li>
<li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li>
</ol>
<p><strong>现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！</strong></p>
<h2 id="springapplication">SpringApplication</h2>
<blockquote>
<p>不简单的方法</p>
</blockquote>
<p>我最初以为就是运行了一个main方法，没想到却开启了一个服务；</p>
<pre><code class="language-java">@SpringBootApplication
public class SpringbootApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringbootApplication.class, args);
    }
}
</code></pre>
<p><strong>SpringApplication.run分析</strong></p>
<p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p>
<blockquote>
<p>SpringApplication</p>
</blockquote>
<p><strong>这个类主要做了以下四件事情：</strong></p>
<p>1、推断应用的类型是普通的项目还是Web项目</p>
<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>
<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>
<p>4、推断并设置main方法的定义类，找到运行的主类</p>
<p>查看构造器：</p>
<pre><code class="language-java">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {
    // ......
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    this.setInitializers(this.getSpringFactoriesInstances();
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = this.deduceMainApplicationClass();
}
</code></pre>
<blockquote>
<p>run方法流程分析</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588582960125.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：IOC]]></title>
        <id>https://totoroay.github.io/post/springioc/</id>
        <link href="https://totoroay.github.io/post/springioc/">
        </link>
        <updated>2020-05-04T06:31:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="11-简介">1.1、简介</h2>
<ul>
<li>
<p>Spring：软件行业的春天</p>
</li>
<li>
<p>2002，首次推出了Spring框架的雏形：interface21框架</p>
</li>
<li>
<p>2004年3月24号，正式发布Spring 1.0 版本</p>
</li>
<li>
<p><strong>Rod Johnson</strong>，Spring Framework创始人</p>
</li>
<li>
<p>Spring理念：使现有的技术更加容易使用，本身是一个大杂烩</p>
</li>
</ul>
<p>官网：https://spring.io/projects/spring-framework#overview</p>
<p>官方下载地址：https://repo.spring.io/release/org/springframework/spring/</p>
<p>GitHub：https://github.com/spring-projects/spring-framework</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="12-优点">1.2、优点</h2>
<ul>
<li>Spring是一个开源免费的框架</li>
<li>Spring是一个轻量级、非入侵式的框架</li>
<li>控制反转（IOC），面向切面编程（AOP）</li>
<li>支持事务处理，对框架的整合支持</li>
</ul>
<h2 id="13-组成">1.3、组成</h2>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588573987212.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<h2 id="14-拓展">1.4、拓展</h2>
<ul>
<li>
<p>Spring Boot——Spring Cloud——Spring Cloud Data Flow</p>
</li>
<li>
<p>构建一切————协调一切————连接一切</p>
</li>
<li>
<p>Spring Boot</p>
<ul>
<li>一个快速开发的脚手架</li>
<li>基于Spring Boot可以快速开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>
<p>Spring Cloud</p>
<ul>
<li>基于Spring Boot实现</li>
</ul>
</li>
</ul>
<h2 id="2-ioc理论推导复习">2、IOC理论推导（复习）</h2>
<p>我们先用我们原来的方式写一段代码 .</p>
<p>1、先写一个UserDao接口</p>
<pre><code class="language-java">public interface UserDao {
   public void getUser();
}
</code></pre>
<p>2、再去写Dao的实现类</p>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;获取用户数据&quot;);
  }
}
</code></pre>
<p>3、然后去写UserService的接口</p>
<pre><code>public interface UserService {
   public void getUser();
}
</code></pre>
<p>4、最后写Service的实现类</p>
<pre><code>public class UserServiceImpl implements UserService {
   private UserDao userDao = new UserDaoImpl();

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>5、测试一下</p>
<pre><code>@Test
public void test(){
   UserService service = new UserServiceImpl();
   service.getUser();
}
</code></pre>
<p>这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 .</p>
<p>把Userdao的实现类增加一个 .</p>
<pre><code>public class UserDaoMySqlImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;MySql获取用户数据&quot;);
  }
}
</code></pre>
<p>紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p>
<pre><code>public class UserServiceImpl implements UserService {
   private UserDao userDao = new UserDaoMySqlImpl();

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>在假设, 我们再增加一个Userdao的实现类 .</p>
<pre><code>public class UserDaoOracleImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;Oracle获取用户数据&quot;);
  }
}
</code></pre>
<p>那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 .</p>
<p><strong>那我们如何去解决呢 ?</strong></p>
<p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .</p>
<pre><code>public class UserServiceImpl implements UserService {
   private UserDao userDao;
// 利用set实现
   public void setUserDao(UserDao userDao) {
       this.userDao = userDao;
  }

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>现在去我们的测试类里 , 进行测试 ;</p>
<pre><code>@Test
public void test(){
   UserServiceImpl service = new UserServiceImpl();
   service.setUserDao( new UserDaoMySqlImpl() );
   service.getUser();
   //那我们现在又想用Oracle去实现呢
   service.setUserDao( new UserDaoOracleImpl() );
   service.getUser();
}
</code></pre>
<p>大家发现了区别没有 ? 可能很多人说没啥区别 . 但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 .</p>
<p>这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</p>
<h3 id="ioc本质">IOC本质</h3>
<p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588574089832.png" alt="" loading="lazy"></figure>
<p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588574100860.png" alt="" loading="lazy"></figure>
<h2 id="3-快速上手spring">3、快速上手Spring</h2>
<blockquote>
<p>导入Jar包</p>
</blockquote>
<p>注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>编写代码</p>
</blockquote>
<p>1、编写一个Hello实体类</p>
<pre><code class="language-java">public class Hello {
   private String name;

   public String getName() {
       return name;
  }
   public void setName(String name) {
       this.name = name;
  }

   public void show(){
       System.out.println(&quot;Hello,&quot;+ name );
  }
}
</code></pre>
<p>2、编写我们的spring文件 , 这里我们命名为beans.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;
   &lt;bean id=&quot;hello&quot; class=&quot;com.totoroay.pojo.Hello&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>3、我们可以去进行测试了</p>
<pre><code class="language-java">@Test
public void test(){
   //解析beans.xml文件 , 生成管理相应的Bean对象
   ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   //getBean : 参数即为spring配置文件中bean的id .
   Hello hello = context.getBean(&quot;hello&quot;, Hello.class);
   hello.show();
}
</code></pre>
<blockquote>
<p>思考</p>
</blockquote>
<ul>
<li>Hello 对象是谁创建的 ?  【hello 对象是由Spring创建的</li>
<li>Hello 对象的属性是怎么设置的 ?  【hello 对象的属性是由Spring容器设置的</li>
</ul>
<p>这个过程就叫控制反转 :</p>
<ul>
<li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li>
<li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li>
</ul>
<p>依赖注入 : 就是利用set方法来进行注入的.</p>
<p>IOC是一种编程思想，由主动的编程变成被动的接收</p>
<p>可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .</p>
<blockquote>
<p>修改案例一</p>
</blockquote>
<p>我们在案例一中， 新增一个Spring配置文件beans.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;/&gt;
   &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;/&gt;

   &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.kuang.service.impl.UserServiceImpl&quot;&gt;
       &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;
       &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;
       &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试！</p>
<pre><code>@Test
public void test2(){
   ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserServiceImpl serviceImpl = (UserServiceImpl)context.getBean(&quot;ServiceImpl&quot;);
   serviceImpl.getUser();
}
</code></pre>
<p>OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !</p>
<h2 id="4-ioc创建对象方式">4、IOC创建对象方式</h2>
<h3 id="通过无参构造方法来创建">通过无参构造方法来创建</h3>
<p>1、User.java</p>
<pre><code class="language-java">public class User {

   private String name;

   public User() {
       System.out.println(&quot;user无参构造方法&quot;);
  }

   public void setName(String name) {
       this.name = name;
  }

   public void show(){
       System.out.println(&quot;name=&quot;+ name );
  }

}
</code></pre>
<p>2、beans.xml</p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void test(){
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   //在执行getBean的时候, user已经创建好了 , 通过无参构造
   User user = (User) context.getBean(&quot;user&quot;);
   //调用对象的方法 .
   user.show();
}
</code></pre>
<p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p>
<h3 id="通过有参构造方法来创建">通过有参构造方法来创建</h3>
<p>1、UserT . java</p>
<pre><code class="language-java">public class UserT {

   private String name;

   public UserT(String name) {
       this.name = name;
  }

   public void setName(String name) {
       this.name = name;
  }

   public void show(){
       System.out.println(&quot;name=&quot;+ name );
  }

}
</code></pre>
<p>2、beans.xml 有三种方式编写</p>
<pre><code class="language-xml">&lt;!-- 第一种根据index参数下标设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.totoroay.pojo.UserT&quot;&gt;
   &lt;!-- index指构造方法 , 下标从0开始 --&gt;
   &lt;constructor-arg index=&quot;0&quot; value=&quot;totoroay2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第二种根据参数名字设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.totoroay.pojo.UserT&quot;&gt;
   &lt;!-- name指参数名 --&gt;
   &lt;constructor-arg name=&quot;name&quot; value=&quot;totoroay2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第三种根据参数类型设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.totoroay.pojo.UserT&quot;&gt;
   &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;totoroay2&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void testT(){
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserT user = (UserT) context.getBean(&quot;userT&quot;);
   user.show();
}
</code></pre>
<p>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</p>
<h2 id="spring配置">Spring配置</h2>
<blockquote>
<p>别名</p>
</blockquote>
<p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p>
<pre><code class="language-xml">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;
&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<blockquote>
<p>Bean的配置</p>
</blockquote>
<pre><code class="language-xml">&lt;!--bean就是java对象,由Spring创建和管理--&gt;

&lt;!--
   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符
   如果配置id,又配置了name,那么name是别名
   name可以设置多个别名,可以用逗号,分号,空格隔开
   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;

class是bean的全限定名=包名+类名
--&gt;
&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>import</p>
</blockquote>
<pre><code class="language-xml">&lt;import resource=&quot;{path}/beans.xml&quot;/&gt;
</code></pre>
]]></content>
    </entry>
</feed>