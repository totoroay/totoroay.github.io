<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://totoroay.github.io/</id>
    <title>totoroay</title>
    <updated>2020-05-05T13:28:05.218Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://totoroay.github.io/"/>
    <link rel="self" href="https://totoroay.github.io/atom.xml"/>
    <subtitle>每天学习5小时！！！</subtitle>
    <logo>https://totoroay.github.io/images/avatar.png</logo>
    <icon>https://totoroay.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, totoroay</rights>
    <entry>
        <title type="html"><![CDATA[代理/静态代理-模式]]></title>
        <id>https://totoroay.github.io/post/dai-li-jing-tai-dai-li-mo-shi/</id>
        <link href="https://totoroay.github.io/post/dai-li-jing-tai-dai-li-mo-shi/">
        </link>
        <updated>2020-05-05T10:12:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="静态代理">静态代理</h2>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588685234201.png" alt="" loading="lazy"></figure>
<p>角色分析</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色后，一般会做一些附属操作</li>
<li>客户：访问代理对象的人</li>
</ul>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 抽象角色
public interface Rent {
    void rent();
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 真实角色
public class Host implements Rent{
    public void rent() {
        System.out.println(&quot;房东要出租房子&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 代理角色
public class Proxy {
    private Host host;

    public Proxy() {}

    public Proxy(Host host) {
        this.host = host;
    }

    public void rent(){
        host.rent();
        seehouse();
    }

    public void seehouse(){
        System.out.println(&quot;看房&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 客户
public class Client {
    public static void main(String[] args) {
        Host host = new Host();
        Proxy proxy = new Proxy(host);
        proxy.rent();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588685225293.png" alt="" loading="lazy"></figure>
<p>代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量翻倍，开发效率会变低</li>
</ul>
<h2 id="加深理解">加深理解</h2>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588685218011.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 抽象角色
public interface UserService {
    void add();
    void delate();
    void update();
    void query();
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 真实角色
public class UserServiceImpl implements UserService{

    public void add() {
        System.out.println(&quot;增加用户&quot;);
    }

    public void delate() {
        System.out.println(&quot;删除用户&quot;);
    }

    public void update() {
        System.out.println(&quot;修改用户&quot;);
    }

    public void query() {
        System.out.println(&quot;查询用户&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 代理角色
public class UserServiceImplProxy {
    private UserServiceImpl userService;

    public UserServiceImpl getUserService() {
        return userService;
    }

    public void setUserService(UserServiceImpl userService) {
        this.userService = userService;
    }

    public void add(){
        userService.add();
        this.log(&quot;增加&quot;);
    }
    public void delate(){
        userService.delate();
    }
    public void update(){
        userService.update();
    }
    public void query(){
        userService.query();
    }

    public void log(String msg){
        System.out.println(&quot;[Debug] &quot;+msg+&quot;错误&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 客户
public class Client {
    public static void main(String[] args) {
        UserServiceImpl userService = new UserServiceImpl();
        UserServiceImplProxy proxy = new UserServiceImplProxy();
        proxy.setUserService(userService);
        proxy.add();
        proxy.delate();
        proxy.update();
        proxy.query();
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588685206797.png" alt="" loading="lazy"></figure>
<h2 id="动态代理">动态代理</h2>
<ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的！</li>
<li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理
<ul>
<li>基于接口---JDK 动态代理	【代码实现】</li>
<li>基于类：cglib</li>
<li>java字节码：javasist</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy：代理，InvocationHandler</p>
<pre><code class="language-java">package totoroay.proxy.demo3;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyInvocationHandler implements InvocationHandler {
    //被代理的接口
    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    // 生成，得到代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }

    // 处理代理实例并返回结果(实现代理类方法)
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object invoke = method.invoke(target,args);
        return invoke;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo3;

import totoroay.proxy.demo2.UserService;
import totoroay.proxy.demo2.UserServiceImpl;

public class Client {
    public static void main(String[] args) {
        //真实对象
        UserServiceImpl userService = new UserServiceImpl();
        // 代理角色
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        // 设置要代理的对象
        pih.setTarget(userService);
        // 动态生成代理类
        UserService proxy = (UserService) pih.getProxy();
        proxy.add();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[建造者模式]]></title>
        <id>https://totoroay.github.io/post/jian-zao-zhe-mo-shi/</id>
        <link href="https://totoroay.github.io/post/jian-zao-zhe-mo-shi/">
        </link>
        <updated>2020-05-05T09:50:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="建造者模式">建造者模式</h1>
<p><img src="https://totoroay.github.io//post-images/1588672365938.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1588672372510.png" alt="" loading="lazy"></p>
<h6 id="demo1"><mark>demo1</mark></h6>
<pre><code class="language-java">package totoroay.builder.demo1;
// 抽象的建造者：方法
public abstract class Builder {
    abstract void buildA();// 地基
    abstract void buildB();// 钢筋工程
    abstract void buildC();// 铺电线
    abstract void buildD();// 粉刷

    // 完工：得到产品
    abstract Product getProduct();
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;
// 产品：房子
public class Product {
    private String buildA;// 地基
    private String buildB;// 钢筋工程
    private String buildC;// 铺电线
    private String buildD;// 粉刷
    
    //get,set,toString方法自己补全
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;
// 具体的建造者：工人
public class Worker extends Builder {
    private Product product;

    // 工人生产产品
    public Worker() {
        product = new Product();
    }

    @Override
    void buildA() {
        product.setBuildA(&quot;地基&quot;);
        System.out.println(&quot;地基&quot;);
    }

    @Override
    void buildB() {
        product.setBuildB(&quot;钢筋工程&quot;);
        System.out.println(&quot;钢筋工程&quot;);
    }

    @Override
    void buildC() {
        product.setBuildC(&quot;铺电线&quot;);
        System.out.println(&quot;铺电线&quot;);
    }

    @Override
    void buildD() {
        product.setBuildD(&quot;粉刷&quot;);
        System.out.println(&quot;粉刷&quot;);
    }

    @Override
    Product getProduct() {
        return product;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;
// 指挥：核心。负责指挥构建一个工程，有它决定
public class Director {
    // 指挥具体的工人建房子
    public Product builder(Builder builder){
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();
        return builder.getProduct();
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;

public class Test {
    public static void main(String[] args) {
        // 指挥
        Director director = new Director();
        // 指挥具体的工人完成产品
        Product builder = director.builder(new Worker());
        System.out.println(builder.toString());
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588672354974.png" alt="" loading="lazy"></figure>
<h6 id="demo2"><mark>demo2</mark></h6>
<pre><code class="language-java">package totoroay.builder.demo2;
// 抽象的建造者：方法
public abstract class Builder {
    // 静态内部类方式
    abstract Builder buildA(String msg);// 汉堡
    abstract Builder buildB(String msg);// 可乐
    abstract Builder buildC(String msg);// 薯条
    abstract Builder buildD(String msg);// 甜品

    // 完工：得到产品
    abstract Product getProduct();
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo2;
// 产品：套餐
public class Product {
    private String buildA = &quot;汉堡&quot;;// 汉堡
    private String buildB = &quot;可乐&quot;;// 可乐
    private String buildC = &quot;薯条&quot;;// 薯条
    private String buildD = &quot;甜品&quot;;// 甜品
    
    //get,set,toString方法自己补全
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo2;
// 具体的建造者
public class Worker extends Builder {
    private Product product;

    public Worker(){
        product = new Product();
    }

    @Override
    Builder buildA(String msg) {
        product.setBuildA(msg);
        return this;
    }

    @Override
    Builder buildB(String msg) {
        product.setBuildB(msg);
        return this;
    }

    @Override
    Builder buildC(String msg) {
        product.setBuildC(msg);
        return this;
    }

    @Override
    Builder buildD(String msg) {
        product.setBuildD(msg);
        return this;
    }

    @Override
    Product getProduct() {
        return product;
    }
}

</code></pre>
<pre><code class="language-java">package totoroay.builder.demo2;

public class Test {
    public static void main(String[] args) {
        // 服务员，默认套餐
        Worker worker = new Worker();
        Product product = worker.getProduct();
        System.out.println(product.toString());

        // 另一个服务员
        Worker worker1 = new Worker();
        // 链式编程
        Product product1 = worker1.buildA(&quot;牛肉汉堡&quot;).buildB(&quot;大杯可乐&quot;)
                .getProduct();
        System.out.println(product1.toString());
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588672343175.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588672337519.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：依赖注入（DI）]]></title>
        <id>https://totoroay.github.io/post/springyi-lai-zhu-ru-di/</id>
        <link href="https://totoroay.github.io/post/springyi-lai-zhu-ru-di/">
        </link>
        <updated>2020-05-05T04:10:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dependency-injection">Dependency Injection</h2>
<blockquote>
<p>概念</p>
</blockquote>
<ul>
<li>依赖注入（Dependency Injection,DI）。</li>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配</li>
</ul>
<blockquote>
<p>构造器注入</p>
</blockquote>
<p>我们在之前的案例已经讲过了</p>
<blockquote>
<p>Set 注入 （重点）</p>
</blockquote>
<p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p>
<p>测试pojo类 :</p>
<p>Address.java</p>
<pre><code class="language-java">package com.totoroay.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Address {
    private String address;
}

</code></pre>
<p>Student.java</p>
<pre><code class="language-java">package com.totoroay.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.*;
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbies;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;
}
</code></pre>
<p>beans.xml：<mark><strong>各种注入方式</strong></mark></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--pojo，bean注入，注意点：这里的值是一个引用，ref--&gt;
    &lt;bean id=&quot;address&quot; class=&quot;com.totoroay.pojo.Address&quot;&gt;
        &lt;property name=&quot;address&quot; value=&quot;武汉&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;student&quot; class=&quot;com.totoroay.pojo.Student&quot;&gt;
        &lt;!--string，常量注入--&gt;
        &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
        &lt;!--pojo，bean注入，注意点：这里的值是一个引用，ref--&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
        &lt;!--array，数组注入--&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;java&lt;/value&gt;
                &lt;value&gt;paython&lt;/value&gt;
                &lt;value&gt;php&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--list，List注入--&gt;
        &lt;property name=&quot;hobbies&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;打游戏&lt;/value&gt;
                &lt;value&gt;打篮球&lt;/value&gt;
                &lt;value&gt;编程&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--map，Map注入--&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;14381983491084&quot;/&gt;
                &lt;entry key=&quot;银行卡&quot; value=&quot;1231238798798798&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--set--&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;lol&lt;/value&gt;
                &lt;value&gt;coc&lt;/value&gt;
                &lt;value&gt;coc&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;!--null，Null注入--&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;
        &lt;!--Properties注入--&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;学号&quot;&gt;20178213718&lt;/prop&gt;
                &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试结果：</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588651878727.png" alt="" loading="lazy"></figure>
<blockquote>
<p>Bean的作用域</p>
</blockquote>
<p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588651855715.png" alt="" loading="lazy"></figure>
<p>几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<h4 id="singleton">Singleton</h4>
<p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，<mark>默认</mark>，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; scope=&quot;singleton&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;33&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@Test
public void test03(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);
    User user = context.getBean(&quot;user&quot;, User.class);
    User user2 = context.getBean(&quot;user&quot;, User.class);
    System.out.println(user==user2);
}
</code></pre>
<h4 id="prototype">Prototype</h4>
<p>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
<h4 id="request">Request</h4>
<p>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<h4 id="session">Session</h4>
<p>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot03：yaml配置注入]]></title>
        <id>https://totoroay.github.io/post/springboot03yaml-pei-zhi-zhu-ru/</id>
        <link href="https://totoroay.github.io/post/springboot03yaml-pei-zhi-zhu-ru/">
        </link>
        <updated>2020-05-04T12:12:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="配置文件">配置文件</h3>
<p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p>
<ul>
<li>
<p>application.properties</p>
</li>
<li>
<ul>
<li>语法结构 ：key=value</li>
</ul>
</li>
<li>
<p>application.yml</p>
</li>
<li>
<ul>
<li>语法结构 ：key：空格 value</li>
</ul>
</li>
</ul>
<p>**配置文件的作用 ：**修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p>
<p>比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！</p>
<pre><code class="language-properties">server.port=8081
</code></pre>
<h3 id="yaml概述">yaml概述</h3>
<p>YAML是 &quot;YAML Ain't a Markup Language&quot; （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）</p>
<p><strong>这种语言以数据<strong><strong>作</strong></strong>为中心，而不是以标记语言为重点！</strong></p>
<p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p>
<p>传统xml配置：</p>
<pre><code class="language-xml">&lt;server&gt;    
    &lt;port&gt;8081&lt;port&gt;
&lt;/server&gt;
</code></pre>
<p>yaml配置：</p>
<pre><code class="language-yaml">server：  prot: 8080
</code></pre>
<h3 id="yaml基础语法">yaml基础语法</h3>
<p>说明：语法要求严格！</p>
<p>1、空格不能省略</p>
<p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p>
<p>3、属性和值的大小写都是十分敏感的。</p>
<p><strong>字面量：普通的值  [ 数字，布尔值，字符串  ]</strong></p>
<p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p>
<pre><code class="language-yaml">k: v
</code></pre>
<p>注意：</p>
<ul>
<li>
<p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p>
<p>比如 ：name: &quot;totoroay\n ayoung&quot;  输出 ：totoroay 换行  ayoung</p>
</li>
<li>
<p>'' 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p>
<p>比如 ：name: ‘totoroay\n ayoung’  输出 ：totoroay  \n  ayoung</p>
</li>
</ul>
<p><strong>对象、Map（键值对）</strong></p>
<pre><code class="language-yaml">#对象、Map格式k:     v1:    v2:
</code></pre>
<p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p>
<pre><code class="language-yaml">student:
	name: totoroay    age: 99
</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">student: {name: totoroay,age: 99}
</code></pre>
<p><strong>数组（ List、set ）</strong></p>
<p>用 - 值表示数组中的一个元素,比如：</p>
<pre><code class="language-yaml">pets:
 - cat
 - dog
 - pig
</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">pets: [cat,dog,pig]
</code></pre>
<p><strong>修改SpringBoot的默认端口号</strong></p>
<p>配置文件中添加，端口号的参数，就可以切换端口；</p>
<pre><code class="language-yaml">server:  
  port: 8081
</code></pre>
<h3 id="yaml注入配置文件">yaml注入配置文件</h3>
<p>yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！</p>
<blockquote>
<p>yaml注入配置文件</p>
</blockquote>
<p>1、在springboot项目中的resources目录下新建一个文件 application.yml</p>
<p>2、编写一个实体类 Dog；</p>
<pre><code class="language-java">package com.totoroay.pojo;

@Component  //注册bean到容器中
public class Dog {
    private String name;
    private Integer age;
    
    //有参无参构造、get、set方法、toString()方法  
}
</code></pre>
<p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p>
<pre><code class="language-java">@Component //注册bean
public class Dog {
    @Value(&quot;阿黄&quot;)
    private String name;
    @Value(&quot;9&quot;)
    private Integer age;
}
</code></pre>
<p>4、在SpringBoot的测试类下注入狗狗输出一下；</p>
<pre><code class="language-java">@SpringBootTest
class Springboot02ConofigApplicationTests {

    @Autowired //将狗狗自动注入进来
    Dog dog;

    @Test
    void contextLoads() {
        System.out.println(dog); //打印看下狗狗对象
    }

}
</code></pre>
<p>结果成功输出，@Value注入成功，这是我们原来的办法对吧。</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588594490094.png" alt="" loading="lazy"></figure>
<p>5、我们在编写一个复杂一点的实体类：Person 类</p>
<pre><code class="language-java">@Component //注册bean到容器中
public class Person {
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
    
    //有参无参构造、get、set方法、toString()方法  
}
</code></pre>
<p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p>
<pre><code class="language-yaml">person:
  name: totoroay
  age: 19
  happy: false
  birth: 1999/09/09
  maps: {k1: v1,k2: v2}
  lists:
    - code
    - girl
    - music
    - game
  dog:
    name: 阿花
    age: 9
</code></pre>
<p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p>
<pre><code class="language-java">/*
@ConfigurationProperties作用：
将配置文件中配置的每一个属性的值，映射到这个组件中；
告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定
参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应
*/
@Component //注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
}
</code></pre>
<p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588594502287.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588594507982.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>9、确认以上配置都OK之后，我们去测试类中测试一下：</p>
<pre><code class="language-java">@SpringBootTest
class DemoApplicationTests {

    @Autowired
    Person person; //将person自动注入进来

    @Test
    public void contextLoads() {
        System.out.println(person); //打印person信息
    }

}
</code></pre>
<p>结果：所有值全部注入成功！</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588594519838.png" alt="" loading="lazy"></figure>
<p><strong>yaml配置注入到实体类完全OK！</strong></p>
<p>课堂测试：</p>
<p>1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败</p>
<p>2、在配置一个person2，然后将 @ConfigurationProperties(prefix = &quot;person2&quot;) 指向我们的person2；</p>
<h3 id="加载指定的配置文件">加载指定的配置文件</h3>
<p>**@PropertySource ：**加载指定的配置文件；</p>
<p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p>
<p>1、我们去在resources目录下新建一个<strong>person.properties</strong>文件</p>
<pre><code class="language-properties">name=zy
</code></pre>
<p>2、然后在我们的代码中指定加载person.properties文件</p>
<pre><code class="language-java">@PropertySource(value = &quot;classpath:person.properties&quot;)
@Component //注册bean
public class Person {

    @Value(&quot;${name}&quot;)
    private String name;

    ......  
}
</code></pre>
<p>3、再次输出测试一下：指定配置文件绑定成功！</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1588594529477.png" alt="" loading="lazy"></figure>
<h3 id="配置文件占位符">配置文件占位符</h3>
<p>配置文件还可以编写占位符生成随机数</p>
<pre><code class="language-yaml">person:
    name: totoroay${random.uuid} # 随机uuid
    age: ${random.int}  # 随机int
    happy: false
    birth: 1999/09/09
    maps: {k1: v1,k2: v2}
    lists:
      - code
      - girl
      - music
      - game
    dog:
      name: ${person.hello:other}_旺财
      age: 1
</code></pre>
<h3 id="回顾properties配置">回顾properties配置</h3>
<p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！</p>
<p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p>
<p>settings--&gt;FileEncodings 中配置；</p>
<p><img src="https://totoroay.github.io//post-images/1588594536690.png" alt="" loading="lazy"><br>
<strong>测试步骤：</strong></p>
<p>1、新建一个实体类User</p>
<pre><code class="language-java">@Component //注册bean
public class User {
    private String name;
    private int age;
    private String sex;
}
</code></pre>
<p>2、编辑配置文件 user.properties</p>
<pre><code class="language-properties">user1.name=kuangshenuser1.age=18user1.sex=男
</code></pre>
<p>3、我们在User类上使用@Value来进行注入！</p>
<pre><code class="language-java">@Component //注册bean
@PropertySource(value = &quot;classpath:user.properties&quot;)
public class User {
    //直接使用@value
    @Value(&quot;${user.name}&quot;) //从配置文件中取值
    private String name;
    @Value(&quot;#{9*2}&quot;)  // #{SPEL} Spring表达式
    private int age;
    @Value(&quot;男&quot;)  // 字面量
    private String sex;
}
</code></pre>
<p>4、Springboot测试</p>
<pre><code class="language-java">@SpringBootTest
class DemoApplicationTests {

    @Autowired
    User user;

    @Test
    public void contextLoads() {
        System.out.println(user);
    }

}
</code></pre>
<p>结果正常输出：</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1588594546320.png" alt="" loading="lazy"></figure>
<h3 id="对比小结">对比小结</h3>
<p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1588594553170.png" alt="" loading="lazy"></figure>
<p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p>
<p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p>
<p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p>
<p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p>
<p><strong>结论：</strong></p>
<p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p>
<p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p>
<p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot02：运行原理初探]]></title>
        <id>https://totoroay.github.io/post/springboot02yun-xing-yuan-li-chu-tan/</id>
        <link href="https://totoroay.github.io/post/springboot02yun-xing-yuan-li-chu-tan/">
        </link>
        <updated>2020-05-04T08:59:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springboot02运行原理初探">SpringBoot02：运行原理初探</h1>
<p><mark>自动配置</mark></p>
<h2 id="pomxml">pom.xml</h2>
<p>我们之前写的HelloSpringBoot，到底是怎么运行的呢，Maven项目，我们一般从pom.xml文件探究起；</p>
<h3 id="父依赖">父依赖</h3>
<p>其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
</code></pre>
<p>点进去，发现还有一个父依赖</p>
<p>我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为这些版本仓库</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre>
<p>这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p>
<p><strong>以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p>
<h3 id="启动器-spring-boot-starter">启动器 spring-boot-starter</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p>
<p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p>
<p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p>
<h2 id="主启动类">主启动类</h2>
<p>分析完了 pom.xml 来看看这个启动类</p>
<h3 id="默认的主启动类">默认的主启动类</h3>
<pre><code class="language-java">//@SpringBootApplication 来标注一个主程序类
//说明这是一个Spring Boot应用
@SpringBootApplication
public class SpringbootApplication {

   public static void main(String[] args) {
     //以为是启动了一个方法，没想到启动了一个服务
      SpringApplication.run(SpringbootApplication.class, args);
   }

}
</code></pre>
<p>但是**一个简单的启动类并不简单！**我们来分析一下这些注解都干了什么</p>
<h3 id="springbootapplication">@SpringBootApplication</h3>
<p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>进入这个注解：可以看到上面还有很多其他注解！</p>
<pre><code class="language-java">@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
    // ......
}
</code></pre>
<h3 id="componentscan">@ComponentScan</h3>
<p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p>
<p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p>
<h3 id="springbootconfiguration">@SpringBootConfiguration</h3>
<p>作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p>
<p>我们继续进去这个注解查看</p>
<pre><code class="language-java">// 点进去得到下面的 @Component
@Configuration
public @interface SpringBootConfiguration {}

@Component
public @interface Configuration {}
</code></pre>
<p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p>
<p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p>
<p>我们回到 SpringBootApplication 注解中继续看。</p>
<h3 id="enableautoconfiguration">@EnableAutoConfiguration</h3>
<p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p>
<p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p>
<p>点进注解接续查看：</p>
<p><strong>@AutoConfigurationPackage ：自动配置包</strong></p>
<pre><code class="language-java">@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage {

}
</code></pre>
<p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p>
<p>Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</p>
<p>这个分析完了，退到上一步，继续看</p>
<p><strong>@Import(AutoConfigurationImportSelector.class) ：给容器导入组件 ；</strong></p>
<p>AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p>
<p>1、这个类中有一个这样的方法</p>
<pre><code class="language-java">// 获得候选的配置
protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
    //这里的getSpringFactoriesLoaderFactoryClass（）方法
    //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration
    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);
    return configurations;
}
</code></pre>
<p>2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法</p>
<pre><code class="language-java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {
    String factoryClassName = factoryClass.getName();
    //这里它又调用了 loadSpringFactories 方法
    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
}
</code></pre>
<p>3、我们继续点击查看 loadSpringFactories 方法</p>
<pre><code class="language-java">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {
    //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身
    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);
    if (result != null) {
        return result;
    } else {
        try {
            //去获取一个资源 &quot;META-INF/spring.factories&quot;
            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);
            LinkedMultiValueMap result = new LinkedMultiValueMap();

            //将读取到的资源遍历，封装成为一个Properties
            while(urls.hasMoreElements()) {
                URL url = (URL)urls.nextElement();
                UrlResource resource = new UrlResource(url);
                Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                Iterator var6 = properties.entrySet().iterator();

                while(var6.hasNext()) {
                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();
                    String factoryClassName = ((String)entry.getKey()).trim();
                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());
                    int var10 = var9.length;

                    for(int var11 = 0; var11 &lt; var10; ++var11) {
                        String factoryName = var9[var11];
                        result.add(factoryClassName, factoryName.trim());
                    }
                }
            }

            cache.put(classLoader, result);
            return result;
        } catch (IOException var13) {
            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);
        }
    }
}
</code></pre>
<p>4、发现一个多次出现的文件：spring.factories，全局搜索它</p>
<h3 id="springfactories">spring.factories</h3>
<p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588583000379.png" alt="" loading="lazy"></figure>
<p><strong>WebMvcAutoConfiguration</strong></p>
<p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588582994094.png" alt="" loading="lazy"></figure>
<p>可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p>
<p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>
<p><strong>结论：</strong></p>
<ol>
<li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li>
<li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li>
<li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li>
<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li>
<li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li>
</ol>
<p><strong>现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！</strong></p>
<h2 id="springapplication">SpringApplication</h2>
<blockquote>
<p>不简单的方法</p>
</blockquote>
<p>我最初以为就是运行了一个main方法，没想到却开启了一个服务；</p>
<pre><code class="language-java">@SpringBootApplication
public class SpringbootApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringbootApplication.class, args);
    }
}
</code></pre>
<p><strong>SpringApplication.run分析</strong></p>
<p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p>
<blockquote>
<p>SpringApplication</p>
</blockquote>
<p><strong>这个类主要做了以下四件事情：</strong></p>
<p>1、推断应用的类型是普通的项目还是Web项目</p>
<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>
<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>
<p>4、推断并设置main方法的定义类，找到运行的主类</p>
<p>查看构造器：</p>
<pre><code class="language-java">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {
    // ......
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    this.setInitializers(this.getSpringFactoriesInstances();
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = this.deduceMainApplicationClass();
}
</code></pre>
<blockquote>
<p>run方法流程分析</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588582960125.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：IOC]]></title>
        <id>https://totoroay.github.io/post/springioc/</id>
        <link href="https://totoroay.github.io/post/springioc/">
        </link>
        <updated>2020-05-04T06:31:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="11-简介">1.1、简介</h2>
<ul>
<li>
<p>Spring：软件行业的春天</p>
</li>
<li>
<p>2002，首次推出了Spring框架的雏形：interface21框架</p>
</li>
<li>
<p>2004年3月24号，正式发布Spring 1.0 版本</p>
</li>
<li>
<p><strong>Rod Johnson</strong>，Spring Framework创始人</p>
</li>
<li>
<p>Spring理念：使现有的技术更加容易使用，本身是一个大杂烩</p>
</li>
</ul>
<p>官网：https://spring.io/projects/spring-framework#overview</p>
<p>官方下载地址：https://repo.spring.io/release/org/springframework/spring/</p>
<p>GitHub：https://github.com/spring-projects/spring-framework</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="12-优点">1.2、优点</h2>
<ul>
<li>Spring是一个开源免费的框架</li>
<li>Spring是一个轻量级、非入侵式的框架</li>
<li>控制反转（IOC），面向切面编程（AOP）</li>
<li>支持事务处理，对框架的整合支持</li>
</ul>
<h2 id="13-组成">1.3、组成</h2>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588573987212.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<h2 id="14-拓展">1.4、拓展</h2>
<ul>
<li>
<p>Spring Boot——Spring Cloud——Spring Cloud Data Flow</p>
</li>
<li>
<p>构建一切————协调一切————连接一切</p>
</li>
<li>
<p>Spring Boot</p>
<ul>
<li>一个快速开发的脚手架</li>
<li>基于Spring Boot可以快速开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>
<p>Spring Cloud</p>
<ul>
<li>基于Spring Boot实现</li>
</ul>
</li>
</ul>
<h2 id="2-ioc理论推导复习">2、IOC理论推导（复习）</h2>
<p>我们先用我们原来的方式写一段代码 .</p>
<p>1、先写一个UserDao接口</p>
<pre><code class="language-java">public interface UserDao {
   public void getUser();
}
</code></pre>
<p>2、再去写Dao的实现类</p>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;获取用户数据&quot;);
  }
}
</code></pre>
<p>3、然后去写UserService的接口</p>
<pre><code>public interface UserService {
   public void getUser();
}
</code></pre>
<p>4、最后写Service的实现类</p>
<pre><code>public class UserServiceImpl implements UserService {
   private UserDao userDao = new UserDaoImpl();

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>5、测试一下</p>
<pre><code>@Test
public void test(){
   UserService service = new UserServiceImpl();
   service.getUser();
}
</code></pre>
<p>这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 .</p>
<p>把Userdao的实现类增加一个 .</p>
<pre><code>public class UserDaoMySqlImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;MySql获取用户数据&quot;);
  }
}
</code></pre>
<p>紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p>
<pre><code>public class UserServiceImpl implements UserService {
   private UserDao userDao = new UserDaoMySqlImpl();

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>在假设, 我们再增加一个Userdao的实现类 .</p>
<pre><code>public class UserDaoOracleImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;Oracle获取用户数据&quot;);
  }
}
</code></pre>
<p>那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 .</p>
<p><strong>那我们如何去解决呢 ?</strong></p>
<p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .</p>
<pre><code>public class UserServiceImpl implements UserService {
   private UserDao userDao;
// 利用set实现
   public void setUserDao(UserDao userDao) {
       this.userDao = userDao;
  }

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>现在去我们的测试类里 , 进行测试 ;</p>
<pre><code>@Test
public void test(){
   UserServiceImpl service = new UserServiceImpl();
   service.setUserDao( new UserDaoMySqlImpl() );
   service.getUser();
   //那我们现在又想用Oracle去实现呢
   service.setUserDao( new UserDaoOracleImpl() );
   service.getUser();
}
</code></pre>
<p>大家发现了区别没有 ? 可能很多人说没啥区别 . 但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 .</p>
<p>这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</p>
<h3 id="ioc本质">IOC本质</h3>
<p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588574089832.png" alt="" loading="lazy"></figure>
<p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588574100860.png" alt="" loading="lazy"></figure>
<h2 id="3-快速上手spring">3、快速上手Spring</h2>
<blockquote>
<p>导入Jar包</p>
</blockquote>
<p>注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>编写代码</p>
</blockquote>
<p>1、编写一个Hello实体类</p>
<pre><code class="language-java">public class Hello {
   private String name;

   public String getName() {
       return name;
  }
   public void setName(String name) {
       this.name = name;
  }

   public void show(){
       System.out.println(&quot;Hello,&quot;+ name );
  }
}
</code></pre>
<p>2、编写我们的spring文件 , 这里我们命名为beans.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;
   &lt;bean id=&quot;hello&quot; class=&quot;com.totoroay.pojo.Hello&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>3、我们可以去进行测试了</p>
<pre><code class="language-java">@Test
public void test(){
   //解析beans.xml文件 , 生成管理相应的Bean对象
   ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   //getBean : 参数即为spring配置文件中bean的id .
   Hello hello = context.getBean(&quot;hello&quot;, Hello.class);
   hello.show();
}
</code></pre>
<blockquote>
<p>思考</p>
</blockquote>
<ul>
<li>Hello 对象是谁创建的 ?  【hello 对象是由Spring创建的</li>
<li>Hello 对象的属性是怎么设置的 ?  【hello 对象的属性是由Spring容器设置的</li>
</ul>
<p>这个过程就叫控制反转 :</p>
<ul>
<li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li>
<li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li>
</ul>
<p>依赖注入 : 就是利用set方法来进行注入的.</p>
<p>IOC是一种编程思想，由主动的编程变成被动的接收</p>
<p>可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .</p>
<blockquote>
<p>修改案例一</p>
</blockquote>
<p>我们在案例一中， 新增一个Spring配置文件beans.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;/&gt;
   &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;/&gt;

   &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.kuang.service.impl.UserServiceImpl&quot;&gt;
       &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;
       &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;
       &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试！</p>
<pre><code>@Test
public void test2(){
   ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserServiceImpl serviceImpl = (UserServiceImpl)context.getBean(&quot;ServiceImpl&quot;);
   serviceImpl.getUser();
}
</code></pre>
<p>OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !</p>
<h2 id="4-ioc创建对象方式">4、IOC创建对象方式</h2>
<h3 id="通过无参构造方法来创建">通过无参构造方法来创建</h3>
<p>1、User.java</p>
<pre><code class="language-java">public class User {

   private String name;

   public User() {
       System.out.println(&quot;user无参构造方法&quot;);
  }

   public void setName(String name) {
       this.name = name;
  }

   public void show(){
       System.out.println(&quot;name=&quot;+ name );
  }

}
</code></pre>
<p>2、beans.xml</p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void test(){
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   //在执行getBean的时候, user已经创建好了 , 通过无参构造
   User user = (User) context.getBean(&quot;user&quot;);
   //调用对象的方法 .
   user.show();
}
</code></pre>
<p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p>
<h3 id="通过有参构造方法来创建">通过有参构造方法来创建</h3>
<p>1、UserT . java</p>
<pre><code class="language-java">public class UserT {

   private String name;

   public UserT(String name) {
       this.name = name;
  }

   public void setName(String name) {
       this.name = name;
  }

   public void show(){
       System.out.println(&quot;name=&quot;+ name );
  }

}
</code></pre>
<p>2、beans.xml 有三种方式编写</p>
<pre><code class="language-xml">&lt;!-- 第一种根据index参数下标设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.totoroay.pojo.UserT&quot;&gt;
   &lt;!-- index指构造方法 , 下标从0开始 --&gt;
   &lt;constructor-arg index=&quot;0&quot; value=&quot;totoroay2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第二种根据参数名字设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.totoroay.pojo.UserT&quot;&gt;
   &lt;!-- name指参数名 --&gt;
   &lt;constructor-arg name=&quot;name&quot; value=&quot;totoroay2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第三种根据参数类型设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.totoroay.pojo.UserT&quot;&gt;
   &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;totoroay2&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void testT(){
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserT user = (UserT) context.getBean(&quot;userT&quot;);
   user.show();
}
</code></pre>
<p>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</p>
<h2 id="spring配置">Spring配置</h2>
<blockquote>
<p>别名</p>
</blockquote>
<p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p>
<pre><code class="language-xml">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;
&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<blockquote>
<p>Bean的配置</p>
</blockquote>
<pre><code class="language-xml">&lt;!--bean就是java对象,由Spring创建和管理--&gt;

&lt;!--
   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符
   如果配置id,又配置了name,那么name是别名
   name可以设置多个别名,可以用逗号,分号,空格隔开
   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;

class是bean的全限定名=包名+类名
--&gt;
&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>import</p>
</blockquote>
<pre><code class="language-xml">&lt;import resource=&quot;{path}/beans.xml&quot;/&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot01：Hello World]]></title>
        <id>https://totoroay.github.io/post/hello-world/</id>
        <link href="https://totoroay.github.io/post/hello-world/">
        </link>
        <updated>2020-05-02T13:45:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot简介">SpringBoot简介</h2>
<h3 id="回顾什么是spring">回顾什么是Spring</h3>
<p>Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson  。</p>
<p><strong>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</strong></p>
<h3 id="spring是如何简化java开发的">Spring是如何简化Java开发的</h3>
<p>为了降低Java开发的复杂性，Spring采用了以下4种关键策略：</p>
<p>1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean；</p>
<p>2、通过IOC，依赖注入（DI）和面向接口实现松耦合；</p>
<p>3、基于切面（AOP）和惯例进行声明式编程；</p>
<p>4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate；</p>
<h3 id="什么是springboot">什么是SpringBoot</h3>
<p>学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍；</p>
<p>言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置，  you can &quot;just run&quot;，能迅速的开发web应用，几行代码开发一个http接口。</p>
<p>所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。</p>
<p>是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。</p>
<p>随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；</p>
<p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>约定大于配置的核心思想</strong>，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p>
<p>简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p>
<p>Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。</p>
<p><strong>Spring Boot的主要优点：</strong></p>
<ul>
<li>为所有Spring开发者更快的入门</li>
<li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li>
<li>内嵌式容器简化Web项目</li>
<li>没有冗余代码生成和XML配置的要求</li>
</ul>
<p>真的很爽，我们快速去体验开发个接口的感觉吧！</p>
<h2 id="第一个springboot程序">第一个SpringBoot程序</h2>
<h3 id="学习环境">学习环境</h3>
<ul>
<li>java version &quot;1.8.0_171&quot;</li>
<li>Maven-3.6.0</li>
<li>SpringBoot 2.x 最新版</li>
</ul>
<h3 id="项目创建方式一">项目创建方式一：</h3>
<p>使用Spring Initializr 的 Web页面创建项目</p>
<p>1、打开  https://start.spring.io/</p>
<p>2、填写项目信息</p>
<p>3、点击”Generate Project“按钮生成项目；下载此项目</p>
<p>4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。</p>
<p>5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。</p>
<h3 id="项目创建方式二">项目创建方式二：</h3>
<p>使用 IDEA 直接创建项目</p>
<p>1、创建一个新项目</p>
<p>2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现</p>
<p>3、填写项目信息</p>
<p>4、选择初始化的组件（初学勾选 Web 即可）</p>
<p>5、填写项目路径</p>
<p>6、等待项目构建成功</p>
<h3 id="项目结构分析">项目结构分析：</h3>
<p>通过上面步骤完成了基础项目的创建。就会自动生成以下文件。</p>
<p>1、程序的主启动类（本身就是Spring的一个组件，不能动！！！！）</p>
<p>2、一个 application.properties 配置文件（空文件）</p>
<p>3、一个 测试类</p>
<p>4、一个 pom.xml</p>
<blockquote>
<p>pom.xml 分析</p>
</blockquote>
<pre><code class="language-java">&lt;!-- 父依赖 --&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;!-- web场景启动器 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- springboot单元测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;!-- 剔除依赖 --&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;!-- 打包插件 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<blockquote>
<p>编写一个http接口</p>
</blockquote>
<p>1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到</p>
<p>2、在包中新建一个HelloController类</p>
<pre><code class="language-java">@RestController
public class HelloController {
    @RequestMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;Hello World&quot;;
    }
}
</code></pre>
<p>3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588427307378.png" alt="" loading="lazy"></figure>
<p>简单几步，就完成了一个web接口的开发，SpringBoot就是这么简单。所以我们常用它来建立我们的微服务项目！</p>
<blockquote>
<p>将项目打成jar包，点击 maven的 package</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588427317097.png" alt="" loading="lazy"></figure>
<p>如果遇到以上错误，可以配置打包时 跳过项目运行测试用例</p>
<pre><code class="language-xml">&lt;!--
    在工作中,很多情况下我们打包是不想执行测试用例的
    可能是测试用例不完事,或是测试用例会影响数据库数据
    跳过测试用例执
    --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;!--跳过项目运行测试用例--&gt;
        &lt;skipTests&gt;true&lt;/skipTests&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>如果打包成功，则会在target目录下生成一个 jar 包</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588427325312.png" alt="" loading="lazy"></figure>
<p>打成了jar包后，就可以在任何地方运行了！OK</p>
<ul>
<li>cmd：java -jar.\springboot-01-helloword-0.0.1-SNAPSHOT</li>
</ul>
<h3 id="彩蛋">彩蛋</h3>
<p>更改端口号：application.properties</p>
<pre><code class="language-properties"># 更改项目的端口号
server.port=8081
</code></pre>
<p>如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案；</p>
<p>只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。</p>
<p>图案可以到：https://www.bootschool.net/ascii 这个网站生成，然后拷贝到文件中即可！</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588427331808.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[抽象工厂模式]]></title>
        <id>https://totoroay.github.io/post/chou-xiang-gong-han-mo-shi/</id>
        <link href="https://totoroay.github.io/post/chou-xiang-gong-han-mo-shi/">
        </link>
        <updated>2020-04-28T05:59:31.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588053644854.png" alt="" loading="lazy"></figure>
<p>====</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588053652595.png" alt="" loading="lazy"></figure>
<p>====</p>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  手机产品接口
public interface IphoneProduct {
    void start();
    void shutdown();
    void callup();
    void sendSMS();
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  路由器产品接口
public interface IRouterProduct {
    void start();
    void shutdown();
    void openWiFi();
    void setting();
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  小米手机
public class XiaomiPhone implements IphoneProduct {
    @Override
    public void start() { System.out.println(&quot;小米手机开机&quot;); }

    @Override
    public void shutdown() { System.out.println(&quot;小米手机关机&quot;); }

    @Override
    public void callup() { System.out.println(&quot;小米手机打电话&quot;); }

    @Override
    public void sendSMS() { System.out.println(&quot;小米手机发短信&quot;); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  小米路由器
public class XiaomiRouter implements IRouterProduct {
    @Override
    public void start() { System.out.println(&quot;小米路由器开启&quot;); }

    @Override
    public void shutdown() { System.out.println(&quot;小米路由器关闭&quot;); }

    @Override
    public void openWiFi() { System.out.println(&quot;小米路由器开启WiFi&quot;); }

    @Override
    public void setting() { System.out.println(&quot;小米路由器开启设置&quot;); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  华为手机
public class HuaweiPhone implements IphoneProduct {
    @Override
    public void start() { System.out.println(&quot;华为手机开机&quot;); }

    @Override
    public void shutdown() { System.out.println(&quot;华为手机关机&quot;); }

    @Override
    public void callup() { System.out.println(&quot;华为手机打电话&quot;); }

    @Override
    public void sendSMS() { System.out.println(&quot;华为手机发短信&quot;); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  华为路由器
public class HuaweiRouter implements IRouterProduct {
    @Override
    public void start() {
        System.out.println(&quot;华为路由器开启&quot;);
    }

    @Override
    public void shutdown() {
        System.out.println(&quot;华为路由器关闭&quot;);
    }

    @Override
    public void openWiFi() {
        System.out.println(&quot;华为路由器开启WiFi&quot;);
    }

    @Override
    public void setting() { System.out.println(&quot;华为路由器开启设置&quot;); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  抽象产品工厂
public interface IProductFactory {
    //  生产手机
    IphoneProduct iphoneproduct();
    //  生产路由器
    IRouterProduct irouterproduct();
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  小米工厂
public class XiaomiFactory implements IProductFactory {
    @Override
    public IphoneProduct iphoneproduct() { return new XiaomiPhone(); }

    @Override
    public IRouterProduct irouterproduct() { return new XiaomiRouter(); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  华为工厂
public class HuaweiFactory implements IProductFactory {
    @Override
    public IphoneProduct iphoneproduct() { return new HuaweiPhone(); }

    @Override
    public IRouterProduct irouterproduct() { return new HuaweiRouter(); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  客户
public class Client {
    public static void main(String[] args) {
        System.out.println(&quot;====小米系列产品====&quot;);
        IphoneProduct iphoneproduct = new XiaomiFactory().iphoneproduct();
        iphoneproduct.start();
        iphoneproduct.callup();
        IRouterProduct irouterproduct = new XiaomiFactory().irouterproduct();
        irouterproduct.start();
        irouterproduct.openWiFi();

        System.out.println(&quot;====华为系列产品====&quot;);
        IphoneProduct iphoneproduct1 = new HuaweiFactory().iphoneproduct();
        iphoneproduct1.start();
        iphoneproduct1.sendSMS();
        IRouterProduct irouterproduct1 = new HuaweiFactory().irouterproduct();
        irouterproduct1.start();
        irouterproduct1.setting();
    }
}
</code></pre>
<p>====</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588053661006.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工厂模式]]></title>
        <id>https://totoroay.github.io/post/gong-han-mo-shi/</id>
        <link href="https://totoroay.github.io/post/gong-han-mo-shi/">
        </link>
        <updated>2020-04-27T14:21:16.000Z</updated>
        <content type="html"><![CDATA[<p><mark>作用</mark>：</p>
<ul>
<li><strong>实现创建者和调用者的分离</strong></li>
<li>详细分类：
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
</li>
</ul>
<p><mark>核心本质</mark>：</p>
<ul>
<li>实例化对象不再使用new，用工厂方法代替</li>
<li>将选择实现类，创建对象统一管理和控制，从而将调用者跟实现类解耦++</li>
</ul>
<p><mark>三种模式</mark>：</p>
<ul>
<li>
<p>简单工厂模式</p>
<ul>
<li>用来生产同一等级结构中的任意产品（对增加新的产品，需要球盖已有代码）</li>
</ul>
</li>
<li>
<p>工厂方法模式</p>
<ul>
<li>用来生产同一等级结构中的固定产品（支持增加任意产品）</li>
</ul>
</li>
<li>
<p>抽象工厂模式</p>
<ul>
<li>围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂</li>
</ul>
</li>
</ul>
<h2 id="简单工厂模式">简单工厂模式</h2>
<pre><code class="language-java">//	车接口
package totoroay.factory.simple;

public interface Car {
    void name();
}
</code></pre>
<pre><code class="language-java">//	车工厂
package totoroay.factory.simple;

//  静态工厂模式即简单工厂模式
//  增加新产品必须修改代码
//  不满足开闭原则
public class CarFactory {
    public static Car getCar(String car) {
        if (car.equals(&quot;五菱宏光&quot;)){
            return new WuLing();
        } else if (car.equals(&quot;特斯拉&quot;)) {
            return new Tesla();
        } else if (car.equals(&quot;大众&quot;)) {
            return new Dazhong();
        } else {
            return null;
        }
    }
}
</code></pre>
<pre><code class="language-java">//	具体的车
package totoroay.factory.simple;

public class WuLing implements Car {
    @Override
    public void name() {
        System.out.println(&quot;五菱宏光&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//	消费者
package totoroay.factory.simple;

public class Consumer {
    public static void main(String[] args) {
        // 原始方法
        Car car = new WuLing();
        Car car1 = new Tesla();
        car.name();
        car1.name();
        
        // 使用工厂创建
        Car car2 = CarFactory.getCar(&quot;五菱宏光&quot;);
        Car car3 = CarFactory.getCar(&quot;特斯拉&quot;);
        car2.name();
        car3.name();

    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1587997372616.png" alt="" loading="lazy"></figure>
<h2 id="工厂方法模式">工厂方法模式</h2>
<pre><code class="language-java">//	车接口
package totoroay.factory.method;

public interface Car {
    void name();
}
</code></pre>
<pre><code class="language-java">//	车工厂接口
package totoroay.factory.method;

//  工厂方法模式
public interface CarFactory {
    Car getCar();
}

</code></pre>
<pre><code class="language-java">//	车工厂
package totoroay.factory.method;

public class MobikeFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new Mobike();
    }
}
</code></pre>
<pre><code class="language-java">//	具体的车
package totoroay.factory.method;

public class Mobike implements Car {
    @Override
    public void name() {
        System.out.println(&quot;摩拜单车&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//	消费者
package totoroay.factory.method;

public class Consumer {
    public static void main(String[] args) {
        Car car = new WuLingFactory().getCar();
        Car car1 = new TeslaFactory().getCar();
        Car car2 = new MobikeFactory().getCar();
        car.name();
        car1.name();
        car2.name();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1587997407988.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原型模式]]></title>
        <id>https://totoroay.github.io/post/yuan-xing-mo-shi/</id>
        <link href="https://totoroay.github.io/post/yuan-xing-mo-shi/">
        </link>
        <updated>2020-04-26T03:44:12.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://totoroay.github.io//post-images/1587872675351.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1587872743440.png" alt="" loading="lazy"></p>
<pre><code class="language-java">// 潜克隆
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.Date;

public class Prototype {
    public static void main(String[] args) throws CloneNotSupportedException {
        Date date = new Date();
        video v = new video(&quot;原型模式&quot;,date);
        video v1 =(video) v.clone();
        System.out.println(v);
        System.out.println(v1);
        System.out.println(&quot;===================================&quot;);
        date.setTime(1232131312);
        System.out.println(v);
        System.out.println(v1);
    }
}

@Data
@NoArgsConstructor
@AllArgsConstructor
class video implements Cloneable{
    private String name;
    private Date date;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1587872749669.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">// 深克隆：改造clone()方法
@Override
    protected Object clone() throws CloneNotSupportedException {
        Object obj = super.clone();
        video v = (video) obj;
        // 将对象的属性进行克隆
        v.date = (Date) this.date.clone();
        return obj;
    }
</code></pre>
<p><img src="https://totoroay.github.io//post-images/1587872756815.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1587872763023.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>