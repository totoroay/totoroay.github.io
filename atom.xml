<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://totoroay.github.io/</id>
    <title>totoroay</title>
    <updated>2020-05-05T04:39:20.457Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://totoroay.github.io/"/>
    <link rel="self" href="https://totoroay.github.io/atom.xml"/>
    <subtitle>每天学习5小时！！！</subtitle>
    <logo>https://totoroay.github.io/images/avatar.png</logo>
    <icon>https://totoroay.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, totoroay</rights>
    <entry>
        <title type="html"><![CDATA[Spring：依赖注入（DI）]]></title>
        <id>https://totoroay.github.io/post/springyi-lai-zhu-ru-di/</id>
        <link href="https://totoroay.github.io/post/springyi-lai-zhu-ru-di/">
        </link>
        <updated>2020-05-05T04:10:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dependency-injection">Dependency Injection</h2>
<blockquote>
<p>概念</p>
</blockquote>
<ul>
<li>依赖注入（Dependency Injection,DI）。</li>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配</li>
</ul>
<blockquote>
<p>构造器注入</p>
</blockquote>
<p>我们在之前的案例已经讲过了</p>
<blockquote>
<p>Set 注入 （重点）</p>
</blockquote>
<p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p>
<p>测试pojo类 :</p>
<p>Address.java</p>
<pre><code class="language-java">package com.totoroay.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Address {
    private String address;
}

</code></pre>
<p>Student.java</p>
<pre><code class="language-java">package com.totoroay.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.*;
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbies;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;
}
</code></pre>
<p>beans.xml：<mark><strong>各种注入方式</strong></mark></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--pojo，bean注入，注意点：这里的值是一个引用，ref--&gt;
    &lt;bean id=&quot;address&quot; class=&quot;com.totoroay.pojo.Address&quot;&gt;
        &lt;property name=&quot;address&quot; value=&quot;武汉&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;student&quot; class=&quot;com.totoroay.pojo.Student&quot;&gt;
        &lt;!--string，常量注入--&gt;
        &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
        &lt;!--pojo，bean注入，注意点：这里的值是一个引用，ref--&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
        &lt;!--array，数组注入--&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;java&lt;/value&gt;
                &lt;value&gt;paython&lt;/value&gt;
                &lt;value&gt;php&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--list，List注入--&gt;
        &lt;property name=&quot;hobbies&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;打游戏&lt;/value&gt;
                &lt;value&gt;打篮球&lt;/value&gt;
                &lt;value&gt;编程&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--map，Map注入--&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;14381983491084&quot;/&gt;
                &lt;entry key=&quot;银行卡&quot; value=&quot;1231238798798798&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--set--&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;lol&lt;/value&gt;
                &lt;value&gt;coc&lt;/value&gt;
                &lt;value&gt;coc&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;!--null，Null注入--&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;
        &lt;!--Properties注入--&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;学号&quot;&gt;20178213718&lt;/prop&gt;
                &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试结果：</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588651878727.png" alt="" loading="lazy"></figure>
<blockquote>
<p>Bean的作用域</p>
</blockquote>
<p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588651855715.png" alt="" loading="lazy"></figure>
<p>几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<h4 id="singleton">Singleton</h4>
<p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，<mark>默认</mark>，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; scope=&quot;singleton&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;33&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@Test
public void test03(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);
    User user = context.getBean(&quot;user&quot;, User.class);
    User user2 = context.getBean(&quot;user&quot;, User.class);
    System.out.println(user==user2);
}
</code></pre>
<h4 id="prototype">Prototype</h4>
<p>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
<h4 id="request">Request</h4>
<p>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<h4 id="session">Session</h4>
<p>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot03：yaml配置注入]]></title>
        <id>https://totoroay.github.io/post/springboot03yaml-pei-zhi-zhu-ru/</id>
        <link href="https://totoroay.github.io/post/springboot03yaml-pei-zhi-zhu-ru/">
        </link>
        <updated>2020-05-04T12:12:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="配置文件">配置文件</h3>
<p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p>
<ul>
<li>
<p>application.properties</p>
</li>
<li>
<ul>
<li>语法结构 ：key=value</li>
</ul>
</li>
<li>
<p>application.yml</p>
</li>
<li>
<ul>
<li>语法结构 ：key：空格 value</li>
</ul>
</li>
</ul>
<p>**配置文件的作用 ：**修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p>
<p>比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！</p>
<pre><code class="language-properties">server.port=8081
</code></pre>
<h3 id="yaml概述">yaml概述</h3>
<p>YAML是 &quot;YAML Ain't a Markup Language&quot; （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）</p>
<p><strong>这种语言以数据<strong><strong>作</strong></strong>为中心，而不是以标记语言为重点！</strong></p>
<p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p>
<p>传统xml配置：</p>
<pre><code class="language-xml">&lt;server&gt;    
    &lt;port&gt;8081&lt;port&gt;
&lt;/server&gt;
</code></pre>
<p>yaml配置：</p>
<pre><code class="language-yaml">server：  prot: 8080
</code></pre>
<h3 id="yaml基础语法">yaml基础语法</h3>
<p>说明：语法要求严格！</p>
<p>1、空格不能省略</p>
<p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p>
<p>3、属性和值的大小写都是十分敏感的。</p>
<p><strong>字面量：普通的值  [ 数字，布尔值，字符串  ]</strong></p>
<p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p>
<pre><code class="language-yaml">k: v
</code></pre>
<p>注意：</p>
<ul>
<li>
<p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p>
<p>比如 ：name: &quot;totoroay\n ayoung&quot;  输出 ：totoroay 换行  ayoung</p>
</li>
<li>
<p>'' 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p>
<p>比如 ：name: ‘totoroay\n ayoung’  输出 ：totoroay  \n  ayoung</p>
</li>
</ul>
<p><strong>对象、Map（键值对）</strong></p>
<pre><code class="language-yaml">#对象、Map格式k:     v1:    v2:
</code></pre>
<p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p>
<pre><code class="language-yaml">student:
	name: totoroay    age: 99
</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">student: {name: totoroay,age: 99}
</code></pre>
<p><strong>数组（ List、set ）</strong></p>
<p>用 - 值表示数组中的一个元素,比如：</p>
<pre><code class="language-yaml">pets:
 - cat
 - dog
 - pig
</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">pets: [cat,dog,pig]
</code></pre>
<p><strong>修改SpringBoot的默认端口号</strong></p>
<p>配置文件中添加，端口号的参数，就可以切换端口；</p>
<pre><code class="language-yaml">server:  
  port: 8081
</code></pre>
<h3 id="yaml注入配置文件">yaml注入配置文件</h3>
<p>yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！</p>
<blockquote>
<p>yaml注入配置文件</p>
</blockquote>
<p>1、在springboot项目中的resources目录下新建一个文件 application.yml</p>
<p>2、编写一个实体类 Dog；</p>
<pre><code class="language-java">package com.totoroay.pojo;

@Component  //注册bean到容器中
public class Dog {
    private String name;
    private Integer age;
    
    //有参无参构造、get、set方法、toString()方法  
}
</code></pre>
<p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p>
<pre><code class="language-java">@Component //注册bean
public class Dog {
    @Value(&quot;阿黄&quot;)
    private String name;
    @Value(&quot;9&quot;)
    private Integer age;
}
</code></pre>
<p>4、在SpringBoot的测试类下注入狗狗输出一下；</p>
<pre><code class="language-java">@SpringBootTest
class Springboot02ConofigApplicationTests {

    @Autowired //将狗狗自动注入进来
    Dog dog;

    @Test
    void contextLoads() {
        System.out.println(dog); //打印看下狗狗对象
    }

}
</code></pre>
<p>结果成功输出，@Value注入成功，这是我们原来的办法对吧。</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588594490094.png" alt="" loading="lazy"></figure>
<p>5、我们在编写一个复杂一点的实体类：Person 类</p>
<pre><code class="language-java">@Component //注册bean到容器中
public class Person {
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
    
    //有参无参构造、get、set方法、toString()方法  
}
</code></pre>
<p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p>
<pre><code class="language-yaml">person:
  name: totoroay
  age: 19
  happy: false
  birth: 1999/09/09
  maps: {k1: v1,k2: v2}
  lists:
    - code
    - girl
    - music
    - game
  dog:
    name: 阿花
    age: 9
</code></pre>
<p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p>
<pre><code class="language-java">/*
@ConfigurationProperties作用：
将配置文件中配置的每一个属性的值，映射到这个组件中；
告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定
参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应
*/
@Component //注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
}
</code></pre>
<p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588594502287.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588594507982.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>9、确认以上配置都OK之后，我们去测试类中测试一下：</p>
<pre><code class="language-java">@SpringBootTest
class DemoApplicationTests {

    @Autowired
    Person person; //将person自动注入进来

    @Test
    public void contextLoads() {
        System.out.println(person); //打印person信息
    }

}
</code></pre>
<p>结果：所有值全部注入成功！</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588594519838.png" alt="" loading="lazy"></figure>
<p><strong>yaml配置注入到实体类完全OK！</strong></p>
<p>课堂测试：</p>
<p>1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败</p>
<p>2、在配置一个person2，然后将 @ConfigurationProperties(prefix = &quot;person2&quot;) 指向我们的person2；</p>
<h3 id="加载指定的配置文件">加载指定的配置文件</h3>
<p>**@PropertySource ：**加载指定的配置文件；</p>
<p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p>
<p>1、我们去在resources目录下新建一个<strong>person.properties</strong>文件</p>
<pre><code class="language-properties">name=zy
</code></pre>
<p>2、然后在我们的代码中指定加载person.properties文件</p>
<pre><code class="language-java">@PropertySource(value = &quot;classpath:person.properties&quot;)
@Component //注册bean
public class Person {

    @Value(&quot;${name}&quot;)
    private String name;

    ......  
}
</code></pre>
<p>3、再次输出测试一下：指定配置文件绑定成功！</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1588594529477.png" alt="" loading="lazy"></figure>
<h3 id="配置文件占位符">配置文件占位符</h3>
<p>配置文件还可以编写占位符生成随机数</p>
<pre><code class="language-yaml">person:
    name: totoroay${random.uuid} # 随机uuid
    age: ${random.int}  # 随机int
    happy: false
    birth: 1999/09/09
    maps: {k1: v1,k2: v2}
    lists:
      - code
      - girl
      - music
      - game
    dog:
      name: ${person.hello:other}_旺财
      age: 1
</code></pre>
<h3 id="回顾properties配置">回顾properties配置</h3>
<p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！</p>
<p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p>
<p>settings--&gt;FileEncodings 中配置；</p>
<p><img src="https://totoroay.github.io//post-images/1588594536690.png" alt="" loading="lazy"><br>
<strong>测试步骤：</strong></p>
<p>1、新建一个实体类User</p>
<pre><code class="language-java">@Component //注册bean
public class User {
    private String name;
    private int age;
    private String sex;
}
</code></pre>
<p>2、编辑配置文件 user.properties</p>
<pre><code class="language-properties">user1.name=kuangshenuser1.age=18user1.sex=男
</code></pre>
<p>3、我们在User类上使用@Value来进行注入！</p>
<pre><code class="language-java">@Component //注册bean
@PropertySource(value = &quot;classpath:user.properties&quot;)
public class User {
    //直接使用@value
    @Value(&quot;${user.name}&quot;) //从配置文件中取值
    private String name;
    @Value(&quot;#{9*2}&quot;)  // #{SPEL} Spring表达式
    private int age;
    @Value(&quot;男&quot;)  // 字面量
    private String sex;
}
</code></pre>
<p>4、Springboot测试</p>
<pre><code class="language-java">@SpringBootTest
class DemoApplicationTests {

    @Autowired
    User user;

    @Test
    public void contextLoads() {
        System.out.println(user);
    }

}
</code></pre>
<p>结果正常输出：</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1588594546320.png" alt="" loading="lazy"></figure>
<h3 id="对比小结">对比小结</h3>
<p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1588594553170.png" alt="" loading="lazy"></figure>
<p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p>
<p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p>
<p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p>
<p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p>
<p><strong>结论：</strong></p>
<p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p>
<p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p>
<p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot02：运行原理初探]]></title>
        <id>https://totoroay.github.io/post/springboot02yun-xing-yuan-li-chu-tan/</id>
        <link href="https://totoroay.github.io/post/springboot02yun-xing-yuan-li-chu-tan/">
        </link>
        <updated>2020-05-04T08:59:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springboot02运行原理初探">SpringBoot02：运行原理初探</h1>
<p><mark>自动配置</mark></p>
<h2 id="pomxml">pom.xml</h2>
<p>我们之前写的HelloSpringBoot，到底是怎么运行的呢，Maven项目，我们一般从pom.xml文件探究起；</p>
<h3 id="父依赖">父依赖</h3>
<p>其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;
</code></pre>
<p>点进去，发现还有一个父依赖</p>
<p>我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为这些版本仓库</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
</code></pre>
<p>这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p>
<p><strong>以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p>
<h3 id="启动器-spring-boot-starter">启动器 spring-boot-starter</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p>
<p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p>
<p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p>
<h2 id="主启动类">主启动类</h2>
<p>分析完了 pom.xml 来看看这个启动类</p>
<h3 id="默认的主启动类">默认的主启动类</h3>
<pre><code class="language-java">//@SpringBootApplication 来标注一个主程序类
//说明这是一个Spring Boot应用
@SpringBootApplication
public class SpringbootApplication {

   public static void main(String[] args) {
     //以为是启动了一个方法，没想到启动了一个服务
      SpringApplication.run(SpringbootApplication.class, args);
   }

}
</code></pre>
<p>但是**一个简单的启动类并不简单！**我们来分析一下这些注解都干了什么</p>
<h3 id="springbootapplication">@SpringBootApplication</h3>
<p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<p>进入这个注解：可以看到上面还有很多其他注解！</p>
<pre><code class="language-java">@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
    // ......
}
</code></pre>
<h3 id="componentscan">@ComponentScan</h3>
<p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p>
<p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p>
<h3 id="springbootconfiguration">@SpringBootConfiguration</h3>
<p>作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p>
<p>我们继续进去这个注解查看</p>
<pre><code class="language-java">// 点进去得到下面的 @Component
@Configuration
public @interface SpringBootConfiguration {}

@Component
public @interface Configuration {}
</code></pre>
<p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p>
<p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p>
<p>我们回到 SpringBootApplication 注解中继续看。</p>
<h3 id="enableautoconfiguration">@EnableAutoConfiguration</h3>
<p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p>
<p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p>
<p>点进注解接续查看：</p>
<p><strong>@AutoConfigurationPackage ：自动配置包</strong></p>
<pre><code class="language-java">@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage {

}
</code></pre>
<p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p>
<p>Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</p>
<p>这个分析完了，退到上一步，继续看</p>
<p><strong>@Import(AutoConfigurationImportSelector.class) ：给容器导入组件 ；</strong></p>
<p>AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p>
<p>1、这个类中有一个这样的方法</p>
<pre><code class="language-java">// 获得候选的配置
protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
    //这里的getSpringFactoriesLoaderFactoryClass（）方法
    //返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration
    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);
    return configurations;
}
</code></pre>
<p>2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法</p>
<pre><code class="language-java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {
    String factoryClassName = factoryClass.getName();
    //这里它又调用了 loadSpringFactories 方法
    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
}
</code></pre>
<p>3、我们继续点击查看 loadSpringFactories 方法</p>
<pre><code class="language-java">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {
    //获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身
    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);
    if (result != null) {
        return result;
    } else {
        try {
            //去获取一个资源 &quot;META-INF/spring.factories&quot;
            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);
            LinkedMultiValueMap result = new LinkedMultiValueMap();

            //将读取到的资源遍历，封装成为一个Properties
            while(urls.hasMoreElements()) {
                URL url = (URL)urls.nextElement();
                UrlResource resource = new UrlResource(url);
                Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                Iterator var6 = properties.entrySet().iterator();

                while(var6.hasNext()) {
                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();
                    String factoryClassName = ((String)entry.getKey()).trim();
                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());
                    int var10 = var9.length;

                    for(int var11 = 0; var11 &lt; var10; ++var11) {
                        String factoryName = var9[var11];
                        result.add(factoryClassName, factoryName.trim());
                    }
                }
            }

            cache.put(classLoader, result);
            return result;
        } catch (IOException var13) {
            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);
        }
    }
}
</code></pre>
<p>4、发现一个多次出现的文件：spring.factories，全局搜索它</p>
<h3 id="springfactories">spring.factories</h3>
<p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588583000379.png" alt="" loading="lazy"></figure>
<p><strong>WebMvcAutoConfiguration</strong></p>
<p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588582994094.png" alt="" loading="lazy"></figure>
<p>可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p>
<p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>
<p><strong>结论：</strong></p>
<ol>
<li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li>
<li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li>
<li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li>
<li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li>
<li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li>
</ol>
<p><strong>现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！</strong></p>
<h2 id="springapplication">SpringApplication</h2>
<blockquote>
<p>不简单的方法</p>
</blockquote>
<p>我最初以为就是运行了一个main方法，没想到却开启了一个服务；</p>
<pre><code class="language-java">@SpringBootApplication
public class SpringbootApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringbootApplication.class, args);
    }
}
</code></pre>
<p><strong>SpringApplication.run分析</strong></p>
<p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p>
<blockquote>
<p>SpringApplication</p>
</blockquote>
<p><strong>这个类主要做了以下四件事情：</strong></p>
<p>1、推断应用的类型是普通的项目还是Web项目</p>
<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>
<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>
<p>4、推断并设置main方法的定义类，找到运行的主类</p>
<p>查看构造器：</p>
<pre><code class="language-java">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {
    // ......
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    this.setInitializers(this.getSpringFactoriesInstances();
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = this.deduceMainApplicationClass();
}
</code></pre>
<blockquote>
<p>run方法流程分析</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588582960125.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：IOC]]></title>
        <id>https://totoroay.github.io/post/springioc/</id>
        <link href="https://totoroay.github.io/post/springioc/">
        </link>
        <updated>2020-05-04T06:31:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="11-简介">1.1、简介</h2>
<ul>
<li>
<p>Spring：软件行业的春天</p>
</li>
<li>
<p>2002，首次推出了Spring框架的雏形：interface21框架</p>
</li>
<li>
<p>2004年3月24号，正式发布Spring 1.0 版本</p>
</li>
<li>
<p><strong>Rod Johnson</strong>，Spring Framework创始人</p>
</li>
<li>
<p>Spring理念：使现有的技术更加容易使用，本身是一个大杂烩</p>
</li>
</ul>
<p>官网：https://spring.io/projects/spring-framework#overview</p>
<p>官方下载地址：https://repo.spring.io/release/org/springframework/spring/</p>
<p>GitHub：https://github.com/spring-projects/spring-framework</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="12-优点">1.2、优点</h2>
<ul>
<li>Spring是一个开源免费的框架</li>
<li>Spring是一个轻量级、非入侵式的框架</li>
<li>控制反转（IOC），面向切面编程（AOP）</li>
<li>支持事务处理，对框架的整合支持</li>
</ul>
<h2 id="13-组成">1.3、组成</h2>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588573987212.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em>（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li>
<li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
<li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li>
<li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li>
<li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li>
<li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
<li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li>
</ul>
<h2 id="14-拓展">1.4、拓展</h2>
<ul>
<li>
<p>Spring Boot——Spring Cloud——Spring Cloud Data Flow</p>
</li>
<li>
<p>构建一切————协调一切————连接一切</p>
</li>
<li>
<p>Spring Boot</p>
<ul>
<li>一个快速开发的脚手架</li>
<li>基于Spring Boot可以快速开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>
<p>Spring Cloud</p>
<ul>
<li>基于Spring Boot实现</li>
</ul>
</li>
</ul>
<h2 id="2-ioc理论推导复习">2、IOC理论推导（复习）</h2>
<p>我们先用我们原来的方式写一段代码 .</p>
<p>1、先写一个UserDao接口</p>
<pre><code class="language-java">public interface UserDao {
   public void getUser();
}
</code></pre>
<p>2、再去写Dao的实现类</p>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;获取用户数据&quot;);
  }
}
</code></pre>
<p>3、然后去写UserService的接口</p>
<pre><code>public interface UserService {
   public void getUser();
}
</code></pre>
<p>4、最后写Service的实现类</p>
<pre><code>public class UserServiceImpl implements UserService {
   private UserDao userDao = new UserDaoImpl();

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>5、测试一下</p>
<pre><code>@Test
public void test(){
   UserService service = new UserServiceImpl();
   service.getUser();
}
</code></pre>
<p>这是我们原来的方式 , 开始大家也都是这么去写的对吧 . 那我们现在修改一下 .</p>
<p>把Userdao的实现类增加一个 .</p>
<pre><code>public class UserDaoMySqlImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;MySql获取用户数据&quot;);
  }
}
</code></pre>
<p>紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p>
<pre><code>public class UserServiceImpl implements UserService {
   private UserDao userDao = new UserDaoMySqlImpl();

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>在假设, 我们再增加一个Userdao的实现类 .</p>
<pre><code>public class UserDaoOracleImpl implements UserDao {
   @Override
   public void getUser() {
       System.out.println(&quot;Oracle获取用户数据&quot;);
  }
}
</code></pre>
<p>那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 .</p>
<p><strong>那我们如何去解决呢 ?</strong></p>
<p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 .</p>
<pre><code>public class UserServiceImpl implements UserService {
   private UserDao userDao;
// 利用set实现
   public void setUserDao(UserDao userDao) {
       this.userDao = userDao;
  }

   @Override
   public void getUser() {
       userDao.getUser();
  }
}
</code></pre>
<p>现在去我们的测试类里 , 进行测试 ;</p>
<pre><code>@Test
public void test(){
   UserServiceImpl service = new UserServiceImpl();
   service.setUserDao( new UserDaoMySqlImpl() );
   service.getUser();
   //那我们现在又想用Oracle去实现呢
   service.setUserDao( new UserDaoOracleImpl() );
   service.getUser();
}
</code></pre>
<p>大家发现了区别没有 ? 可能很多人说没啥区别 . 但是同学们 , 他们已经发生了根本性的变化 , 很多地方都不一样了 . 仔细去思考一下 , 以前所有东西都是由程序去进行控制创建 , 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 . 程序不用去管怎么创建,怎么实现了 . 它只负责提供一个接口 .</p>
<p>这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 . 耦合性大大降低 . 这也就是IOC的原型 !</p>
<h3 id="ioc本质">IOC本质</h3>
<p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588574089832.png" alt="" loading="lazy"></figure>
<p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588574100860.png" alt="" loading="lazy"></figure>
<h2 id="3-快速上手spring">3、快速上手Spring</h2>
<blockquote>
<p>导入Jar包</p>
</blockquote>
<p>注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .</p>
<pre><code>&lt;dependency&gt;
   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
   &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>编写代码</p>
</blockquote>
<p>1、编写一个Hello实体类</p>
<pre><code class="language-java">public class Hello {
   private String name;

   public String getName() {
       return name;
  }
   public void setName(String name) {
       this.name = name;
  }

   public void show(){
       System.out.println(&quot;Hello,&quot;+ name );
  }
}
</code></pre>
<p>2、编写我们的spring文件 , 这里我们命名为beans.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;!--bean就是java对象 , 由Spring创建和管理--&gt;
   &lt;bean id=&quot;hello&quot; class=&quot;com.totoroay.pojo.Hello&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>3、我们可以去进行测试了</p>
<pre><code class="language-java">@Test
public void test(){
   //解析beans.xml文件 , 生成管理相应的Bean对象
   ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   //getBean : 参数即为spring配置文件中bean的id .
   Hello hello = context.getBean(&quot;hello&quot;, Hello.class);
   hello.show();
}
</code></pre>
<blockquote>
<p>思考</p>
</blockquote>
<ul>
<li>Hello 对象是谁创建的 ?  【hello 对象是由Spring创建的</li>
<li>Hello 对象的属性是怎么设置的 ?  【hello 对象的属性是由Spring容器设置的</li>
</ul>
<p>这个过程就叫控制反转 :</p>
<ul>
<li>控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的</li>
<li>反转 : 程序本身不创建对象 , 而变成被动的接收对象 .</li>
</ul>
<p>依赖注入 : 就是利用set方法来进行注入的.</p>
<p>IOC是一种编程思想，由主动的编程变成被动的接收</p>
<p>可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .</p>
<blockquote>
<p>修改案例一</p>
</blockquote>
<p>我们在案例一中， 新增一个Spring配置文件beans.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;/&gt;
   &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;/&gt;

   &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.kuang.service.impl.UserServiceImpl&quot;&gt;
       &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;
       &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;
       &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试！</p>
<pre><code>@Test
public void test2(){
   ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserServiceImpl serviceImpl = (UserServiceImpl)context.getBean(&quot;ServiceImpl&quot;);
   serviceImpl.getUser();
}
</code></pre>
<p>OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !</p>
<h2 id="4-ioc创建对象方式">4、IOC创建对象方式</h2>
<h3 id="通过无参构造方法来创建">通过无参构造方法来创建</h3>
<p>1、User.java</p>
<pre><code class="language-java">public class User {

   private String name;

   public User() {
       System.out.println(&quot;user无参构造方法&quot;);
  }

   public void setName(String name) {
       this.name = name;
  }

   public void show(){
       System.out.println(&quot;name=&quot;+ name );
  }

}
</code></pre>
<p>2、beans.xml</p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;&gt;
       &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void test(){
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   //在执行getBean的时候, user已经创建好了 , 通过无参构造
   User user = (User) context.getBean(&quot;user&quot;);
   //调用对象的方法 .
   user.show();
}
</code></pre>
<p>结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！</p>
<h3 id="通过有参构造方法来创建">通过有参构造方法来创建</h3>
<p>1、UserT . java</p>
<pre><code class="language-java">public class UserT {

   private String name;

   public UserT(String name) {
       this.name = name;
  }

   public void setName(String name) {
       this.name = name;
  }

   public void show(){
       System.out.println(&quot;name=&quot;+ name );
  }

}
</code></pre>
<p>2、beans.xml 有三种方式编写</p>
<pre><code class="language-xml">&lt;!-- 第一种根据index参数下标设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.totoroay.pojo.UserT&quot;&gt;
   &lt;!-- index指构造方法 , 下标从0开始 --&gt;
   &lt;constructor-arg index=&quot;0&quot; value=&quot;totoroay2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第二种根据参数名字设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.totoroay.pojo.UserT&quot;&gt;
   &lt;!-- name指参数名 --&gt;
   &lt;constructor-arg name=&quot;name&quot; value=&quot;totoroay2&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 第三种根据参数类型设置 --&gt;
&lt;bean id=&quot;userT&quot; class=&quot;com.totoroay.pojo.UserT&quot;&gt;
   &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;totoroay2&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void testT(){
   ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserT user = (UserT) context.getBean(&quot;userT&quot;);
   user.show();
}
</code></pre>
<p>结论：在配置文件加载的时候。其中管理的对象都已经初始化了！</p>
<h2 id="spring配置">Spring配置</h2>
<blockquote>
<p>别名</p>
</blockquote>
<p>alias 设置别名 , 为bean设置别名 , 可以设置多个别名</p>
<pre><code class="language-xml">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;
&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<blockquote>
<p>Bean的配置</p>
</blockquote>
<pre><code class="language-xml">&lt;!--bean就是java对象,由Spring创建和管理--&gt;

&lt;!--
   id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符
   如果配置id,又配置了name,那么name是别名
   name可以设置多个别名,可以用逗号,分号,空格隔开
   如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;

class是bean的全限定名=包名+类名
--&gt;
&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<blockquote>
<p>import</p>
</blockquote>
<pre><code class="language-xml">&lt;import resource=&quot;{path}/beans.xml&quot;/&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot01：Hello World]]></title>
        <id>https://totoroay.github.io/post/hello-world/</id>
        <link href="https://totoroay.github.io/post/hello-world/">
        </link>
        <updated>2020-05-02T13:45:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springboot简介">SpringBoot简介</h2>
<h3 id="回顾什么是spring">回顾什么是Spring</h3>
<p>Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson  。</p>
<p><strong>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</strong></p>
<h3 id="spring是如何简化java开发的">Spring是如何简化Java开发的</h3>
<p>为了降低Java开发的复杂性，Spring采用了以下4种关键策略：</p>
<p>1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean；</p>
<p>2、通过IOC，依赖注入（DI）和面向接口实现松耦合；</p>
<p>3、基于切面（AOP）和惯例进行声明式编程；</p>
<p>4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate；</p>
<h3 id="什么是springboot">什么是SpringBoot</h3>
<p>学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍；</p>
<p>言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置，  you can &quot;just run&quot;，能迅速的开发web应用，几行代码开发一个http接口。</p>
<p>所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。</p>
<p>是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。</p>
<p>随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；</p>
<p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>约定大于配置的核心思想</strong>，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p>
<p>简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p>
<p>Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。</p>
<p><strong>Spring Boot的主要优点：</strong></p>
<ul>
<li>为所有Spring开发者更快的入门</li>
<li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li>
<li>内嵌式容器简化Web项目</li>
<li>没有冗余代码生成和XML配置的要求</li>
</ul>
<p>真的很爽，我们快速去体验开发个接口的感觉吧！</p>
<h2 id="第一个springboot程序">第一个SpringBoot程序</h2>
<h3 id="学习环境">学习环境</h3>
<ul>
<li>java version &quot;1.8.0_171&quot;</li>
<li>Maven-3.6.0</li>
<li>SpringBoot 2.x 最新版</li>
</ul>
<h3 id="项目创建方式一">项目创建方式一：</h3>
<p>使用Spring Initializr 的 Web页面创建项目</p>
<p>1、打开  https://start.spring.io/</p>
<p>2、填写项目信息</p>
<p>3、点击”Generate Project“按钮生成项目；下载此项目</p>
<p>4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。</p>
<p>5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。</p>
<h3 id="项目创建方式二">项目创建方式二：</h3>
<p>使用 IDEA 直接创建项目</p>
<p>1、创建一个新项目</p>
<p>2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现</p>
<p>3、填写项目信息</p>
<p>4、选择初始化的组件（初学勾选 Web 即可）</p>
<p>5、填写项目路径</p>
<p>6、等待项目构建成功</p>
<h3 id="项目结构分析">项目结构分析：</h3>
<p>通过上面步骤完成了基础项目的创建。就会自动生成以下文件。</p>
<p>1、程序的主启动类（本身就是Spring的一个组件，不能动！！！！）</p>
<p>2、一个 application.properties 配置文件（空文件）</p>
<p>3、一个 测试类</p>
<p>4、一个 pom.xml</p>
<blockquote>
<p>pom.xml 分析</p>
</blockquote>
<pre><code class="language-java">&lt;!-- 父依赖 --&gt;
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
    &lt;relativePath/&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;!-- web场景启动器 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!-- springboot单元测试 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
        &lt;scope&gt;test&lt;/scope&gt;
        &lt;!-- 剔除依赖 --&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;!-- 打包插件 --&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<blockquote>
<p>编写一个http接口</p>
</blockquote>
<p>1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到</p>
<p>2、在包中新建一个HelloController类</p>
<pre><code class="language-java">@RestController
public class HelloController {
    @RequestMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;Hello World&quot;;
    }
}
</code></pre>
<p>3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588427307378.png" alt="" loading="lazy"></figure>
<p>简单几步，就完成了一个web接口的开发，SpringBoot就是这么简单。所以我们常用它来建立我们的微服务项目！</p>
<blockquote>
<p>将项目打成jar包，点击 maven的 package</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588427317097.png" alt="" loading="lazy"></figure>
<p>如果遇到以上错误，可以配置打包时 跳过项目运行测试用例</p>
<pre><code class="language-xml">&lt;!--
    在工作中,很多情况下我们打包是不想执行测试用例的
    可能是测试用例不完事,或是测试用例会影响数据库数据
    跳过测试用例执
    --&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;!--跳过项目运行测试用例--&gt;
        &lt;skipTests&gt;true&lt;/skipTests&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>如果打包成功，则会在target目录下生成一个 jar 包</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588427325312.png" alt="" loading="lazy"></figure>
<p>打成了jar包后，就可以在任何地方运行了！OK</p>
<ul>
<li>cmd：java -jar.\springboot-01-helloword-0.0.1-SNAPSHOT</li>
</ul>
<h3 id="彩蛋">彩蛋</h3>
<p>更改端口号：application.properties</p>
<pre><code class="language-properties"># 更改项目的端口号
server.port=8081
</code></pre>
<p>如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案；</p>
<p>只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。</p>
<p>图案可以到：https://www.bootschool.net/ascii 这个网站生成，然后拷贝到文件中即可！</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588427331808.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[抽象工厂模式]]></title>
        <id>https://totoroay.github.io/post/chou-xiang-gong-han-mo-shi/</id>
        <link href="https://totoroay.github.io/post/chou-xiang-gong-han-mo-shi/">
        </link>
        <updated>2020-04-28T05:59:31.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588053644854.png" alt="" loading="lazy"></figure>
<p>====</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588053652595.png" alt="" loading="lazy"></figure>
<p>====</p>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  手机产品接口
public interface IphoneProduct {
    void start();
    void shutdown();
    void callup();
    void sendSMS();
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  路由器产品接口
public interface IRouterProduct {
    void start();
    void shutdown();
    void openWiFi();
    void setting();
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  小米手机
public class XiaomiPhone implements IphoneProduct {
    @Override
    public void start() { System.out.println(&quot;小米手机开机&quot;); }

    @Override
    public void shutdown() { System.out.println(&quot;小米手机关机&quot;); }

    @Override
    public void callup() { System.out.println(&quot;小米手机打电话&quot;); }

    @Override
    public void sendSMS() { System.out.println(&quot;小米手机发短信&quot;); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  小米路由器
public class XiaomiRouter implements IRouterProduct {
    @Override
    public void start() { System.out.println(&quot;小米路由器开启&quot;); }

    @Override
    public void shutdown() { System.out.println(&quot;小米路由器关闭&quot;); }

    @Override
    public void openWiFi() { System.out.println(&quot;小米路由器开启WiFi&quot;); }

    @Override
    public void setting() { System.out.println(&quot;小米路由器开启设置&quot;); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  华为手机
public class HuaweiPhone implements IphoneProduct {
    @Override
    public void start() { System.out.println(&quot;华为手机开机&quot;); }

    @Override
    public void shutdown() { System.out.println(&quot;华为手机关机&quot;); }

    @Override
    public void callup() { System.out.println(&quot;华为手机打电话&quot;); }

    @Override
    public void sendSMS() { System.out.println(&quot;华为手机发短信&quot;); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  华为路由器
public class HuaweiRouter implements IRouterProduct {
    @Override
    public void start() {
        System.out.println(&quot;华为路由器开启&quot;);
    }

    @Override
    public void shutdown() {
        System.out.println(&quot;华为路由器关闭&quot;);
    }

    @Override
    public void openWiFi() {
        System.out.println(&quot;华为路由器开启WiFi&quot;);
    }

    @Override
    public void setting() { System.out.println(&quot;华为路由器开启设置&quot;); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  抽象产品工厂
public interface IProductFactory {
    //  生产手机
    IphoneProduct iphoneproduct();
    //  生产路由器
    IRouterProduct irouterproduct();
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  小米工厂
public class XiaomiFactory implements IProductFactory {
    @Override
    public IphoneProduct iphoneproduct() { return new XiaomiPhone(); }

    @Override
    public IRouterProduct irouterproduct() { return new XiaomiRouter(); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  华为工厂
public class HuaweiFactory implements IProductFactory {
    @Override
    public IphoneProduct iphoneproduct() { return new HuaweiPhone(); }

    @Override
    public IRouterProduct irouterproduct() { return new HuaweiRouter(); }
}
</code></pre>
<pre><code class="language-java">package totoroay.factory.abstract1;
//  客户
public class Client {
    public static void main(String[] args) {
        System.out.println(&quot;====小米系列产品====&quot;);
        IphoneProduct iphoneproduct = new XiaomiFactory().iphoneproduct();
        iphoneproduct.start();
        iphoneproduct.callup();
        IRouterProduct irouterproduct = new XiaomiFactory().irouterproduct();
        irouterproduct.start();
        irouterproduct.openWiFi();

        System.out.println(&quot;====华为系列产品====&quot;);
        IphoneProduct iphoneproduct1 = new HuaweiFactory().iphoneproduct();
        iphoneproduct1.start();
        iphoneproduct1.sendSMS();
        IRouterProduct irouterproduct1 = new HuaweiFactory().irouterproduct();
        irouterproduct1.start();
        irouterproduct1.setting();
    }
}
</code></pre>
<p>====</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588053661006.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工厂模式]]></title>
        <id>https://totoroay.github.io/post/gong-han-mo-shi/</id>
        <link href="https://totoroay.github.io/post/gong-han-mo-shi/">
        </link>
        <updated>2020-04-27T14:21:16.000Z</updated>
        <content type="html"><![CDATA[<p><mark>作用</mark>：</p>
<ul>
<li><strong>实现创建者和调用者的分离</strong></li>
<li>详细分类：
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
</li>
</ul>
<p><mark>核心本质</mark>：</p>
<ul>
<li>实例化对象不再使用new，用工厂方法代替</li>
<li>将选择实现类，创建对象统一管理和控制，从而将调用者跟实现类解耦++</li>
</ul>
<p><mark>三种模式</mark>：</p>
<ul>
<li>
<p>简单工厂模式</p>
<ul>
<li>用来生产同一等级结构中的任意产品（对增加新的产品，需要球盖已有代码）</li>
</ul>
</li>
<li>
<p>工厂方法模式</p>
<ul>
<li>用来生产同一等级结构中的固定产品（支持增加任意产品）</li>
</ul>
</li>
<li>
<p>抽象工厂模式</p>
<ul>
<li>围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂</li>
</ul>
</li>
</ul>
<h2 id="简单工厂模式">简单工厂模式</h2>
<pre><code class="language-java">//	车接口
package totoroay.factory.simple;

public interface Car {
    void name();
}
</code></pre>
<pre><code class="language-java">//	车工厂
package totoroay.factory.simple;

//  静态工厂模式即简单工厂模式
//  增加新产品必须修改代码
//  不满足开闭原则
public class CarFactory {
    public static Car getCar(String car) {
        if (car.equals(&quot;五菱宏光&quot;)){
            return new WuLing();
        } else if (car.equals(&quot;特斯拉&quot;)) {
            return new Tesla();
        } else if (car.equals(&quot;大众&quot;)) {
            return new Dazhong();
        } else {
            return null;
        }
    }
}
</code></pre>
<pre><code class="language-java">//	具体的车
package totoroay.factory.simple;

public class WuLing implements Car {
    @Override
    public void name() {
        System.out.println(&quot;五菱宏光&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//	消费者
package totoroay.factory.simple;

public class Consumer {
    public static void main(String[] args) {
        // 原始方法
        Car car = new WuLing();
        Car car1 = new Tesla();
        car.name();
        car1.name();
        
        // 使用工厂创建
        Car car2 = CarFactory.getCar(&quot;五菱宏光&quot;);
        Car car3 = CarFactory.getCar(&quot;特斯拉&quot;);
        car2.name();
        car3.name();

    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1587997372616.png" alt="" loading="lazy"></figure>
<h2 id="工厂方法模式">工厂方法模式</h2>
<pre><code class="language-java">//	车接口
package totoroay.factory.method;

public interface Car {
    void name();
}
</code></pre>
<pre><code class="language-java">//	车工厂接口
package totoroay.factory.method;

//  工厂方法模式
public interface CarFactory {
    Car getCar();
}

</code></pre>
<pre><code class="language-java">//	车工厂
package totoroay.factory.method;

public class MobikeFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new Mobike();
    }
}
</code></pre>
<pre><code class="language-java">//	具体的车
package totoroay.factory.method;

public class Mobike implements Car {
    @Override
    public void name() {
        System.out.println(&quot;摩拜单车&quot;);
    }
}
</code></pre>
<pre><code class="language-java">//	消费者
package totoroay.factory.method;

public class Consumer {
    public static void main(String[] args) {
        Car car = new WuLingFactory().getCar();
        Car car1 = new TeslaFactory().getCar();
        Car car2 = new MobikeFactory().getCar();
        car.name();
        car1.name();
        car2.name();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1587997407988.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[原型模式]]></title>
        <id>https://totoroay.github.io/post/yuan-xing-mo-shi/</id>
        <link href="https://totoroay.github.io/post/yuan-xing-mo-shi/">
        </link>
        <updated>2020-04-26T03:44:12.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://totoroay.github.io//post-images/1587872675351.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1587872743440.png" alt="" loading="lazy"></p>
<pre><code class="language-java">// 潜克隆
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.Date;

public class Prototype {
    public static void main(String[] args) throws CloneNotSupportedException {
        Date date = new Date();
        video v = new video(&quot;原型模式&quot;,date);
        video v1 =(video) v.clone();
        System.out.println(v);
        System.out.println(v1);
        System.out.println(&quot;===================================&quot;);
        date.setTime(1232131312);
        System.out.println(v);
        System.out.println(v1);
    }
}

@Data
@NoArgsConstructor
@AllArgsConstructor
class video implements Cloneable{
    private String name;
    private Date date;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1587872749669.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">// 深克隆：改造clone()方法
@Override
    protected Object clone() throws CloneNotSupportedException {
        Object obj = super.clone();
        video v = (video) obj;
        // 将对象的属性进行克隆
        v.date = (Date) this.date.clone();
        return obj;
    }
</code></pre>
<p><img src="https://totoroay.github.io//post-images/1587872756815.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1587872763023.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例模式]]></title>
        <id>https://totoroay.github.io/post/dan-li-mo-shi/</id>
        <link href="https://totoroay.github.io/post/dan-li-mo-shi/">
        </link>
        <updated>2020-04-26T03:38:29.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://totoroay.github.io//post-images/1587872393341.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1587872419615.png" alt="" loading="lazy"></p>
<ul>
<li></li>
</ul>
<pre><code class="language-java">// 饿汉式 缺点：空间上造成浪费
public class Hungry {
    public static void main(String[] args) {
        User user = User.getUser();
        for (int i = 0; i &lt; 1000000; i++) {
            User u =User.getUser();
            if (user != u){
                System.out.println(&quot;产生了新的对象！&quot;);
            }
        }
        System.out.println(&quot;end&quot;);
    }
}

class User {
    // 1.私有化构造方法
    private User(){
        System.out.println();
    }
    // 2.定义一个静态类对象
    private static User user = new User();// 空间浪费
    // 3.提供一个方法，返回给调用方一个类对象
    public static User getUser(){
        return user;
    }

}
</code></pre>
<ul>
<li>懒汉式 特点：类加载时没有生成单例，只有当第一次调用getStudent()方法时才创建单例</li>
</ul>
<pre><code class="language-java">// 懒汉式 缺点：造成性能上的损耗，多线程下可能不止一个对象
//                              加锁解决（synchronized）
public class Slacker {
    public static void main(String[] args) {
        Student student = Student.getStudent();
        Student student1 = Student.getStudent();
        System.out.println(student);
        System.out.println(student1);
    }
}
class Student{
    private Student(){}
    private static Student student;
    public static synchronized Student getStudent(){
        if (student==null){
            student = new Student();// 性能损耗
        }
        return student;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSM整合]]></title>
        <id>https://totoroay.github.io/post/ssm-zheng-he/</id>
        <link href="https://totoroay.github.io/post/ssm-zheng-he/">
        </link>
        <updated>2020-04-25T09:23:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="整体架构">整体架构</h2>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1587807061832.png" alt="" loading="lazy"></figure>
<h2 id="数据库及建表">数据库及建表</h2>
<pre><code class="language-sql">CREATE DATABASE `ssmbuild`;

USE `ssmbuild`;

DROP TABLE IF EXISTS `books`;

CREATE TABLE `books` (
`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT '书id',
`bookName` VARCHAR(100) NOT NULL COMMENT '书名',
`bookCounts` INT(11) NOT NULL COMMENT '数量',
`detail` VARCHAR(200) NOT NULL COMMENT '描述',
KEY `bookID` (`bookID`)
) ENGINE=INNODB DEFAULT CHARSET=utf8;

INSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES 
(1,'Java',1,'从入门到放弃'),
(2,'MySQL',10,'从删库到跑路'),
(3,'Linux',5,'从进门到进牢');
</code></pre>
<h2 id="基本环境搭建">基本环境搭建</h2>
<h5 id="1-新建一个空的maven项目">1、新建一个空的Maven项目</h5>
<h5 id="2-添加web支持">2、添加web支持</h5>
<p><img src="https://totoroay.github.io//post-images/1587807215470.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1587807239144.png" alt="" loading="lazy"></p>
<h5 id="3-导入相关依赖">3、导入相关依赖</h5>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.example&lt;/groupId&gt;
    &lt;artifactId&gt;ssmbuild&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;!--Junit--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.12&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--数据库驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 数据库连接池 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.mchange&lt;/groupId&gt;
            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;
            &lt;version&gt;0.9.5.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Servlet - JSP --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;4.0.1&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Mybatis--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
            &lt;version&gt;3.5.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
            &lt;version&gt;2.0.2&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--Spring--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
            &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--AOP--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
            &lt;version&gt;1.9.4&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!--lombok--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.12&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/java&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;false&lt;/filtering&gt;
            &lt;/resource&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.properties&lt;/include&gt;
                    &lt;include&gt;**/*.xml&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;false&lt;/filtering&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h5 id="4-打war包">4、打war包</h5>
<p><img src="https://totoroay.github.io//post-images/1587807356487.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1587807371220.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1587807395323.png" alt="" loading="lazy"></p>
<p>全选点击ok</p>
<h5 id="5-建立基本结构">5、建立基本结构</h5>
<pre><code class="language-java">com.totoroay.pojo
com.totoroay.mapper
com.totoroay.service
com.totoroay.service.serviceimpl
com.totoroay.controller
</code></pre>
<h2 id="resources目录下各个配置文件">resources目录下各个配置文件</h2>
<h6 id="1-mybatis-configxml">1、mybatis-config.xml</h6>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;settings&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;/settings&gt;

    &lt;typeAliases&gt;
        &lt;package name=&quot;com.totoroay.pojo&quot;/&gt;
    &lt;/typeAliases&gt;
    &lt;!-- 注册mapper --&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mapper/BookMapper.xml&quot;/&gt;
    &lt;/mappers&gt;

&lt;/configuration&gt;
</code></pre>
<h6 id="2-databaseproperties">2、database.properties</h6>
<pre><code class="language-properties">jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8
jdbc.username=root
jdbc.password=root
</code></pre>
<h6 id="3-spring-daoxml">3、spring-dao.xml</h6>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 配置整合mybatis --&gt;
    &lt;!-- 1.关联数据库文件 --&gt;
    &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt;

    &lt;!-- 2.数据库连接池 --&gt;
    &lt;!--数据库连接池
        dbcp 半自动化操作 不能自动连接
        c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）
    --&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;!-- 配置连接池属性 --&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;
        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;

        &lt;!-- c3p0连接池的私有属性 --&gt;
        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;
        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;
        &lt;!-- 关闭连接后不自动commit --&gt;
        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;
        &lt;!-- 获取连接超时时间 --&gt;
        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt;
        &lt;!-- 当获取连接失败重试次数 --&gt;
        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 3.配置SqlSessionFactory对象 --&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
        &lt;!-- 注入数据库连接池 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;
    &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;
    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
        &lt;!-- 注入sqlSessionFactory --&gt;
        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;
        &lt;!-- 给出需要扫描Dao接口包 --&gt;
        &lt;property name=&quot;basePackage&quot; value=&quot;com.totoroay.mapper&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<h6 id="4-spring-servicexml">4、spring-service.xml</h6>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context.xsd
   http://www.springframework.org/schema/aop
   https://www.springframework.org/schema/aop/spring-aop.xsd 
   http://www.springframework.org/schema/tx 
   http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;

    &lt;!-- 1.扫描service相关的bean --&gt;
    &lt;context:component-scan base-package=&quot;com.totoroay.service&quot; /&gt;

    &lt;!-- 2.BookServiceImpl注入到IOC容器中--&gt;
    &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.totoroay.service.serviceimpl.BookServiceImpl&quot;&gt;
        &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- 3.配置事务管理器 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!-- 注入数据库连接池 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;/bean&gt;

    &lt;!--4.事务支持--&gt;
    &lt;!--结合aop实现事务的织入--&gt;
    &lt;!--配置事务通知--&gt;
    &lt;!--&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
            &lt;tx:method name=&quot;query&quot; read-only=&quot;true&quot;/&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;--&gt;

    &lt;!--配置事务切入--&gt;
    &lt;!--&lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.totoroay.mapper.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;
    &lt;/aop:config&gt;--&gt;
&lt;/beans&gt;
</code></pre>
<h6 id="5-spring-mvcxml">5、spring-mvc.xml</h6>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/mvc
        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 配置SpringMVC --&gt;
    &lt;!-- 1.开启SpringMVC注解驱动 --&gt;
    &lt;mvc:annotation-driven /&gt;
    &lt;!-- 2.静态资源默认servlet配置--&gt;
    &lt;mvc:default-servlet-handler/&gt;

    &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- 4.扫描web相关的bean --&gt;
    &lt;context:component-scan base-package=&quot;com.totoroay.controller&quot; /&gt;

&lt;/beans&gt;
</code></pre>
<h6 id="6-applicationcontextxml">6、applicationContext.xml</h6>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;import resource=&quot;spring-dao.xml&quot;/&gt;
    &lt;import resource=&quot;spring-service.xml&quot;/&gt;
    &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h6 id="7-webxml">7、web.xml</h6>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--DispatcherServlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;!--一定要注意:我们这里加载的是总的配置文件！--&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;!--encodingFilter--&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;
            org.springframework.web.filter.CharacterEncodingFilter
        &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;utf-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!--Session过期时间--&gt;
    &lt;session-config&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;
&lt;/web-app&gt;
</code></pre>
<h2 id="后端代码">后端代码</h2>
<h6 id="1-实体类books">1、实体类：Books</h6>
<pre><code class="language-java">package com.totoroay.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Books {
    private int bookID;
    private String bookName;
    private int bookCounts;
    private String detail;
}
</code></pre>
<h6 id="2-mapper接口bookmapper">2、mapper接口：BookMapper</h6>
<pre><code class="language-java">package com.totoroay.mapper;

import com.totoroay.pojo.Books;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface BookMapper {
    //增加一个Book
    int addBook(Books book);

    //根据id删除一个Book
    int deleteBookById(@Param(&quot;bookID&quot;) int id);

    //更新Book
    int updateBook(Books books);

    //根据id查询,返回一个Book
    Books queryBookById(@Param(&quot;bookID&quot;) int id);

    //查询全部Book,返回list集合
    List&lt;Books&gt; queryAllBook();

    //根据书名查询书籍
    Books queryBookByName(@Param(&quot;bookName&quot;) String bookName);
}

</code></pre>
<h6 id="3-注册bookmapper">3、注册BookMapper</h6>
<ul>
<li>在mybatis-config.xml中注册</li>
</ul>
<h6 id="4-bookservice接口">4、BookService接口</h6>
<pre><code class="language-java">package com.totoroay.service;

import com.totoroay.pojo.Books;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface BookService {
    // 增加一个Book
    int addBook(Books book);
    // 根据id删除一个Book
    int deleteBookById(int id);
    // 更新Book
    int updateBook(Books books);
    // 根据id查询,返回一个Book
    Books queryBookById(int id);
    // 查询全部Book,返回list集合
    List&lt;Books&gt; queryAllBook();
    // 根据书名查询一本书
    Books queryBookByName(String bookName);
}
</code></pre>
<h6 id="5-bookservice实现类">5、BookService实现类</h6>
<pre><code class="language-java">package com.totoroay.service.serviceimpl;

import com.totoroay.mapper.BookMapper;
import com.totoroay.pojo.Books;
import com.totoroay.service.BookService;
import org.springframework.stereotype.Service;

import java.util.List;
@Service
public class BookServiceImpl implements BookService {

    //调用dao层的操作，设置一个set接口，方便Spring管理
    private BookMapper bookMapper;

    public void setBookMapper(BookMapper bookMapper) {
        this.bookMapper = bookMapper;
    }

    public int addBook(Books book) {
        return bookMapper.addBook(book);
    }

    public int deleteBookById(int id) {
        return bookMapper.deleteBookById(id);
    }

    public int updateBook(Books books) {
        return bookMapper.updateBook(books);
    }

    public Books queryBookById(int id) {
        return bookMapper.queryBookById(id);
    }

    public List&lt;Books&gt; queryAllBook() {
        return bookMapper.queryAllBook();
    }

    public Books queryBookByName(String bookName) {
        return bookMapper.queryBookByName(bookName);
    }
}

</code></pre>
<h6 id="6-bookcontroller">6、BookController</h6>
<pre><code class="language-java">package com.totoroay.controller;

import com.totoroay.pojo.Books;
import com.totoroay.service.BookService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

import java.util.ArrayList;
import java.util.List;

@Controller
@RequestMapping(&quot;/book&quot;)
public class BookController {
    // controller调service
    @Autowired
    @Qualifier(&quot;BookServiceImpl&quot;)
    private BookService bookService;

    // 查询全部书籍
    @RequestMapping(&quot;/allBook&quot;)
    public String list(Model model) {
        List&lt;Books&gt; list = bookService.queryAllBook();
        model.addAttribute(&quot;list&quot;, list);
        return &quot;allBook&quot;;
    }

    // 跳转到增加书籍页面
    @RequestMapping(&quot;/toAddBook&quot;)
    public String toAddBook(){
        return &quot;addBook&quot;;
    }

    // 添加书籍的请求
    @RequestMapping(&quot;/addBook&quot;)
    public String addBook(Books books){
        bookService.addBook(books);
        return &quot;redirect:/book/allBook&quot;;
    }

    // 跳转到修改书籍页面
    @RequestMapping(&quot;/toUpdateBook&quot;)
    public String toUpdateBook(int id, Model model){
        Books books = bookService.queryBookById(id);
        model.addAttribute(&quot;book&quot;, books);
        return &quot;updateBook&quot;;
    }

    // 修改书籍的请求
    @RequestMapping(&quot;/updateBook&quot;)
    public String updateBook(Books books, Model model){
        int i = bookService.updateBook(books);
        if (i &gt; 0) {
            System.out.println(&quot;修改成功&quot;+books);
        }
        return &quot;redirect:/book/allBook&quot;;
    }

    // 删除书籍
    @RequestMapping(&quot;/deleteBook/{bookID}&quot;)
    public String deleteBook(@PathVariable(&quot;bookID&quot;) int id){
        bookService.deleteBookById(id);
        return &quot;redirect:/book/allBook&quot;;
    }

    // 查询书籍
    @RequestMapping(&quot;/queryBookName&quot;)
    public String queryBookName(String queryBookName, Model model){
        Books books = bookService.queryBookByName(queryBookName);
        List&lt;Books&gt; list = new ArrayList&lt;Books&gt;();
        list.add(books);
        if (books==null){
            list = bookService.queryAllBook();
            model.addAttribute(&quot;msg&quot;, &quot;未查到&quot;);
        }
        model.addAttribute(&quot;list&quot;, list);
        return &quot;allBook&quot;;
    }
}
</code></pre>
<h2 id="前端代码">前端代码</h2>
<h6 id="1-indexjsp">1、index.jsp</h6>
<pre><code>&lt;%--
  Created by IntelliJ IDEA.
  User: totoroay
  Date: 2020/4/25
  Time: 11:13
  To change this template use File | Settings | File Templates.
--%&gt;
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;首页&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    a {
      text-decoration: none;
      color: black;
      font-size: 18px;
    }
    h3 {
      width: 180px;
      height: 38px;
      margin: 100px auto;
      text-align: center;
      line-height: 38px;
      background: deepskyblue;
      border-radius: 4px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h3&gt;
  &lt;a href=&quot;${pageContext.request.contextPath}/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;
&lt;/h3&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h6 id="2-allbookjsp">2、allBook.jsp</h6>
<pre><code class="language-java">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;书籍列表&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;!-- 引入 Bootstrap --&gt;
    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class=&quot;container&quot;&gt;

    &lt;div class=&quot;row clearfix&quot;&gt;
        &lt;div class=&quot;col-md-12 column&quot;&gt;
            &lt;div class=&quot;page-header&quot;&gt;
                &lt;h1&gt;
                    &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;
                &lt;/h1&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-4 column&quot;&gt;
            &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/toAddBook&quot;&gt;新增&lt;/a&gt;
            &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/allBook&quot;&gt;显示所有书籍&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-md-4 column&quot;&gt;
            &lt;span style=&quot;color: red&quot;&gt;${msg}&lt;/span&gt;
            &lt;%--查询书籍--%&gt;
            &lt;form class=&quot;form-inline&quot; action=&quot;${pageContext.request.contextPath}/book/queryBookName&quot; method=&quot;post&quot; style=&quot;float: right&quot;&gt;
                &lt;input type=&quot;text&quot; name=&quot;queryBookName&quot; class=&quot;form-control&quot; placeholder=&quot;请输入要查询的书籍名称&quot;&gt;
                &lt;input type=&quot;submit&quot; value=&quot;查询&quot; class=&quot;btn btn-primary&quot;&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;row clearfix&quot;&gt;
        &lt;div class=&quot;col-md-12 column&quot;&gt;
            &lt;table class=&quot;table table-hover table-striped&quot;&gt;
                &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;书籍编号&lt;/th&gt;
                    &lt;th&gt;书籍名字&lt;/th&gt;
                    &lt;th&gt;书籍数量&lt;/th&gt;
                    &lt;th&gt;书籍详情&lt;/th&gt;
                    &lt;th&gt;操作&lt;/th&gt;
                &lt;/tr&gt;
                &lt;/thead&gt;

                &lt;tbody&gt;
                &lt;c:forEach var=&quot;book&quot; items=&quot;${requestScope.get('list')}&quot;&gt;
                    &lt;tr&gt;
                        &lt;td&gt;${book.getBookID()}&lt;/td&gt;
                        &lt;td&gt;${book.getBookName()}&lt;/td&gt;
                        &lt;td&gt;${book.getBookCounts()}&lt;/td&gt;
                        &lt;td&gt;${book.getDetail()}&lt;/td&gt;
                        &lt;td&gt;
                            &lt;a href=&quot;${pageContext.request.contextPath}/book/toUpdateBook?id=${book.bookID}&quot;&gt;修改&lt;/a&gt; |
                            &lt;a href=&quot;${pageContext.request.contextPath}/book/deleteBook/${book.bookID}&quot;&gt;删除&lt;/a&gt;
                        &lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/c:forEach&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h6 id="3-addbookjsp">3、addBook.jsp</h6>
<pre><code class="language-java">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;书籍列表&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;!-- 引入 Bootstrap --&gt;
    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class=&quot;container&quot;&gt;

    &lt;div class=&quot;row clearfix&quot;&gt;
        &lt;div class=&quot;col-md-12 column&quot;&gt;
            &lt;div class=&quot;page-header&quot;&gt;
                &lt;h1&gt;
                    &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;
                &lt;/h1&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-4 column&quot;&gt;
            &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/toAddBook&quot;&gt;新增&lt;/a&gt;
            &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/allBook&quot;&gt;显示所有书籍&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-md-4 column&quot;&gt;
            &lt;span style=&quot;color: red&quot;&gt;${msg}&lt;/span&gt;
            &lt;%--查询书籍--%&gt;
            &lt;form class=&quot;form-inline&quot; action=&quot;${pageContext.request.contextPath}/book/queryBookName&quot; method=&quot;post&quot; style=&quot;float: right&quot;&gt;
                &lt;input type=&quot;text&quot; name=&quot;queryBookName&quot; class=&quot;form-control&quot; placeholder=&quot;请输入要查询的书籍名称&quot;&gt;
                &lt;input type=&quot;submit&quot; value=&quot;查询&quot; class=&quot;btn btn-primary&quot;&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;row clearfix&quot;&gt;
        &lt;div class=&quot;col-md-12 column&quot;&gt;
            &lt;table class=&quot;table table-hover table-striped&quot;&gt;
                &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;书籍编号&lt;/th&gt;
                    &lt;th&gt;书籍名字&lt;/th&gt;
                    &lt;th&gt;书籍数量&lt;/th&gt;
                    &lt;th&gt;书籍详情&lt;/th&gt;
                    &lt;th&gt;操作&lt;/th&gt;
                &lt;/tr&gt;
                &lt;/thead&gt;

                &lt;tbody&gt;
                &lt;c:forEach var=&quot;book&quot; items=&quot;${requestScope.get('list')}&quot;&gt;
                    &lt;tr&gt;
                        &lt;td&gt;${book.getBookID()}&lt;/td&gt;
                        &lt;td&gt;${book.getBookName()}&lt;/td&gt;
                        &lt;td&gt;${book.getBookCounts()}&lt;/td&gt;
                        &lt;td&gt;${book.getDetail()}&lt;/td&gt;
                        &lt;td&gt;
                            &lt;a href=&quot;${pageContext.request.contextPath}/book/toUpdateBook?id=${book.bookID}&quot;&gt;修改&lt;/a&gt; |
                            &lt;a href=&quot;${pageContext.request.contextPath}/book/deleteBook/${book.bookID}&quot;&gt;删除&lt;/a&gt;
                        &lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/c:forEach&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h6 id="4-updatebookjsp">4、updateBook.jsp</h6>
<pre><code class="language-java">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;书籍列表&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;!-- 引入 Bootstrap --&gt;
    &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class=&quot;container&quot;&gt;

    &lt;div class=&quot;row clearfix&quot;&gt;
        &lt;div class=&quot;col-md-12 column&quot;&gt;
            &lt;div class=&quot;page-header&quot;&gt;
                &lt;h1&gt;
                    &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;
                &lt;/h1&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-4 column&quot;&gt;
            &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/toAddBook&quot;&gt;新增&lt;/a&gt;
            &lt;a class=&quot;btn btn-primary&quot; href=&quot;${pageContext.request.contextPath}/book/allBook&quot;&gt;显示所有书籍&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;col-md-4 column&quot;&gt;
            &lt;span style=&quot;color: red&quot;&gt;${msg}&lt;/span&gt;
            &lt;%--查询书籍--%&gt;
            &lt;form class=&quot;form-inline&quot; action=&quot;${pageContext.request.contextPath}/book/queryBookName&quot; method=&quot;post&quot; style=&quot;float: right&quot;&gt;
                &lt;input type=&quot;text&quot; name=&quot;queryBookName&quot; class=&quot;form-control&quot; placeholder=&quot;请输入要查询的书籍名称&quot;&gt;
                &lt;input type=&quot;submit&quot; value=&quot;查询&quot; class=&quot;btn btn-primary&quot;&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;row clearfix&quot;&gt;
        &lt;div class=&quot;col-md-12 column&quot;&gt;
            &lt;table class=&quot;table table-hover table-striped&quot;&gt;
                &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;书籍编号&lt;/th&gt;
                    &lt;th&gt;书籍名字&lt;/th&gt;
                    &lt;th&gt;书籍数量&lt;/th&gt;
                    &lt;th&gt;书籍详情&lt;/th&gt;
                    &lt;th&gt;操作&lt;/th&gt;
                &lt;/tr&gt;
                &lt;/thead&gt;

                &lt;tbody&gt;
                &lt;c:forEach var=&quot;book&quot; items=&quot;${requestScope.get('list')}&quot;&gt;
                    &lt;tr&gt;
                        &lt;td&gt;${book.getBookID()}&lt;/td&gt;
                        &lt;td&gt;${book.getBookName()}&lt;/td&gt;
                        &lt;td&gt;${book.getBookCounts()}&lt;/td&gt;
                        &lt;td&gt;${book.getDetail()}&lt;/td&gt;
                        &lt;td&gt;
                            &lt;a href=&quot;${pageContext.request.contextPath}/book/toUpdateBook?id=${book.bookID}&quot;&gt;修改&lt;/a&gt; |
                            &lt;a href=&quot;${pageContext.request.contextPath}/book/deleteBook/${book.bookID}&quot;&gt;删除&lt;/a&gt;
                        &lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/c:forEach&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
]]></content>
    </entry>
</feed>