<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://totoroay.github.io/</id>
    <title>totoroay</title>
    <updated>2020-05-28T02:36:15.933Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://totoroay.github.io/"/>
    <link rel="self" href="https://totoroay.github.io/atom.xml"/>
    <subtitle>每天学习5小时！！！</subtitle>
    <logo>https://totoroay.github.io/images/avatar.png</logo>
    <icon>https://totoroay.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, totoroay</rights>
    <entry>
        <title type="html"><![CDATA[总结]]></title>
        <id>https://totoroay.github.io/post/zong-jie/</id>
        <link href="https://totoroay.github.io/post/zong-jie/">
        </link>
        <updated>2020-05-27T13:32:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="三层架构-mvc">三层架构 + MVC</h2>
<p>​	目的：架构   ---&gt;   解耦</p>
<p>开发框架</p>
<ul>
<li>Spring<br>
IOC		AOP</li>
</ul>
<p>​							IOC ：控制反转</p>
<p>​									约泡：<br>
​											泡温泉，泡茶.....泡友</p>
<p>​											附近的人，打招呼。加微信，聊天，天天聊，---&gt;约泡</p>
<p>​									浴场(容器) :温泉， 茶庄，泡友<br>
​											直接进温泉，就有人和你一起了!</p>
<p>​									原来我们都是自己一步步操作，现在交给容器了!我们需要什么就去拿就可以了</p>
<p>​							AOP :切面(本质，动态代理)<br>
​								为了解决什么?不影响业务本来的情况下，实现动态增加功能，大量应用在日志，事务...等等</p>
<p>方面</p>
<p>​				Spring是一个轻量级的Java开源框架，容器</p>
<p>​				目的:解决企业开发的复杂性问题</p>
<p>​				Spring是春天，觉得他是春天，也十分复杂，配置文件!</p>
<ul>
<li>SpringBoot</li>
</ul>
<p>​				SpringBoot并不是新东西，就是Spring的升级版!</p>
<pre><code>			新一代JavaEE的开发标准，开箱即用! &gt;拿过来就可以用! 它自动帮我们配置了非常多的东西，我们拿来即用!
</code></pre>
<p>​				特性:约定大于配置!</p>
<p>随着公司体系越来越大，用户越来越多!</p>
<h2 id="微服务架构-新架构">微服务架构---&gt;新架构</h2>
<p>​		模块化，功能化!</p>
<p>​		用户，支付，签到，娱乐，..... ;</p>
<p>​		人越来越多：一台服务器解决不了；再增加服务器 ! 	 横向解决问题</p>
<p>​		假设A服务器占用98%资源，B服务器只占用了10% 。——负载均衡;</p>
<p>​		将原来的整体项目，分成模块化，用户就是一个单独的项目，签到也是一个单独的项目， 项目和项目之前需要通信，如何通信?</p>
<p>​		用户非常多，而签到十分少!			给用户多一点服务器，给签到少一点服务器!</p>
<p>微服务架构问题?</p>
<p>分布式架构会遇到的四个核心问题?</p>
<ol>
<li>这么多服务，客户端该如何去访问?</li>
<li>这么多服务，服务之间如何进行通信?</li>
<li>这么多服务，如何治理呢?</li>
<li>服务挂了，怎么办?</li>
</ol>
<p>解决方案:</p>
<p>​	SpringCloud,是一套生态，就是来解决以上分布式架构的4个问题</p>
<p>​	想使用SpringCloud,必须要掌握SpringBoot,因为SpringCloud是基 于SpringBoot;</p>
<ol>
<li>
<p>Spring Cloud NetFlix ，出来了一套解决方案! 一站式解决方案。我们都可以直接去这里拿?</p>
<p>​	Api网关，zuul组件</p>
<p>​	Feign --&gt; HttpClient ---&gt; HTTP的通信方式，同步并阻塞</p>
<p>​	服务注册与发现，Eureka</p>
<p>​	熔断机制，Hystrix</p>
<p>​</p>
<p>​	2018年年底，NetFlix宣布无限期停止维护。生态不再维护，就会脱节。</p>
</li>
<li>
<p>Apache Dubbo zookeeper，第二套解决系统</p>
<p>​	API ：	没有! 	要么找第三方组件，要么自己实现</p>
<p>​	Dubbo是一个高性能的基于Java实现的RPC通信框架！ 	2.6.x</p>
<p>​	服务注册与发现，zookeeper: 动物园管理者(Hadoop ，Hive)</p>
<p>​	没有：	借助了Hystrix</p>
<p>​</p>
<p>​	不完善，Dubbo	关注Dubbo 3.0</p>
</li>
<li>
<p>SpringCloud Alibaba	一站式解决方案 !</p>
</li>
</ol>
<p>目前，又提出了一种方案:</p>
<p>​			服务网格：下一代微服务标准，Service Mesh</p>
<p>​			代表解决方案: istio (未来可能需要掌握! )</p>
<p>万变不离其宗，一通百通!</p>
<ol>
<li>
<p>API网关，服务路由</p>
<ol start="2">
<li>
<p>HTTP，RPC框架，异步调用</p>
</li>
<li>
<p>服务注册与发现，高可用</p>
</li>
<li>
<p>熔断机制，服务降级</p>
</li>
</ol>
</li>
</ol>
<p>为什么要解决这个问题？ 本质：网络是不可靠的！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot17：Dubbo和Zookeeper集成]]></title>
        <id>https://totoroay.github.io/post/springboot17dubbo-he-zookeeper-ji-cheng/</id>
        <link href="https://totoroay.github.io/post/springboot17dubbo-he-zookeeper-ji-cheng/">
        </link>
        <updated>2020-05-27T13:26:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分布式理论">分布式理论</h2>
<h3 id="什么是分布式系统">什么是分布式系统？</h3>
<p>在《分布式系统原理与范型》一书中有如下定义：“分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统”；</p>
<p>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是<strong>利用更多的机器，处理更多的数据</strong>。</p>
<p>分布式系统（distributed system）是建立在网络之上的软件系统。</p>
<p>首先需要明确的是，只有当单个节点的处理能力无法满足日益增长的计算、存储任务的时候，且硬件的提升（加内存、加磁盘、使用更好的CPU）高昂到得不偿失的时候，应用程序也不能进一步优化的时候，我们才需要考虑分布式系统。因为，分布式系统要解决的问题本身就是和单机系统一样的，而由于分布式系统多节点、通过网络通信的拓扑结构，会引入很多单机系统没有的问题，为了解决这些问题又会引入更多的机制、协议，带来更多的问题。。。</p>
<h3 id="dubbo文档">Dubbo文档</h3>
<p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，急需<strong>一个治理系统</strong>确保架构有条不紊的演进。</p>
<p>在Dubbo的官网文档有这样一张图</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1590586302295.png" alt="" loading="lazy"></figure>
<p><strong>单一应用架构</strong></p>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1590586288719.png" alt="" loading="lazy"></figure>
<p>适用于小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</p>
<p><strong>缺点：</strong></p>
<p>1、性能扩展比较难</p>
<p>2、协同开发问题</p>
<p>3、不利于升级维护</p>
<p><strong>垂直应用架构</strong></p>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1590586274078.png" alt="" loading="lazy"></figure>
<p>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p>
<p>缺点：公用模块无法重复利用，开发性的浪费</p>
<p><strong>分布式服务架构</strong></p>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的**分布式服务框架(RPC)**是关键。</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1590586260927.png" alt="" loading="lazy"></figure>
<p><strong>流动计算架构</strong></p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心</strong>(SOA)[ Service Oriented Architecture]是关键。</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1590586246100.png" alt="" loading="lazy"></figure>
<h2 id="什么是rpc">什么是RPC</h2>
<p>RPC【Remote Procedure Call】是指远程过程调用，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即程序员无论是调用本地的还是远程的函数，本质上编写的调用代码基本相同。</p>
<p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。为什么要用RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯，由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用。RPC就是要像调用本地的函数一样去调远程函数；</p>
<p>推荐阅读文章：https://www.jianshu.com/p/2accc2840a1b</p>
<p><strong>RPC基本原理</strong></p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1590586232150.png" alt="" loading="lazy"></figure>
<p><strong>步骤解析：</strong></p>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1590586217542.png" alt="" loading="lazy"></figure>
<p>RPC两个核心模块：通讯，序列化。</p>
<h2 id="测试环境搭建">测试环境搭建</h2>
<h3 id="dubbo">Dubbo</h3>
<p>Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<p>dubbo官网 http://dubbo.apache.org/zh-cn/index.html</p>
<p>1.了解Dubbo的特性</p>
<p>2.查看官方文档</p>
<p><strong>dubbo基本概念</strong></p>
<figure data-type="image" tabindex="8"><img src="https://totoroay.github.io//post-images/1590586201905.png" alt="" loading="lazy"></figure>
<p><strong>服务提供者</strong>（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者</strong>（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>注册中心</strong>（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</p>
<p><strong>监控中心</strong>（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</p>
<p><strong>调用关系说明</strong></p>
<p>l 服务容器负责启动，加载，运行服务提供者。</p>
<p>l 服务提供者在启动时，向注册中心注册自己提供的服务。</p>
<p>l 服务消费者在启动时，向注册中心订阅自己所需的服务。</p>
<p>l 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p>l 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p>l 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>
<h3 id="dubbo环境搭建">dubbo环境搭建</h3>
<p>点进dubbo官方文档，推荐我们使用Zookeeper 注册中心</p>
<p>什么是zookeeper呢？可以查看</p>
<h3 id="window下安装zookeeper">Window下安装zookeeper</h3>
<p>1、下载地址	https://zookeeper.apache.org/releases.html	下载3.4.14版本</p>
<p>2、运行/bin/zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件；</p>
<p>可能遇到问题：闪退 !</p>
<p>解决方案：编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。</p>
<figure data-type="image" tabindex="9"><img src="https://totoroay.github.io//post-images/1590586180661.png" alt="" loading="lazy"></figure>
<p>3、修改zoo.cfg配置文件</p>
<p>将conf文件夹下面的zoo_sample.cfg复制一份改名为zoo.cfg即可。</p>
<p>注意几个重要位置：</p>
<p>dataDir=./  临时数据存储的目录（可写相对路径）</p>
<p>clientPort=2181  zookeeper的端口号</p>
<p>修改完成后再次启动zookeeper</p>
<p>4、使用zkCli.cmd测试</p>
<p>ls /：列出zookeeper根下保存的所有节点</p>
<pre><code>[zk: 127.0.0.1:2181(CONNECTED) 0] ls /
[zookeeper]
</code></pre>
<p>create -e /totoroay 2333：创建一个totoroay节点，值为2333</p>
<p>get /totoroay：获取/totoroay节点的值</p>
<p>我们再来查看一下节点</p>
<figure data-type="image" tabindex="10"><img src="https://totoroay.github.io//post-images/1590586156814.png" alt="" loading="lazy"></figure>
<h3 id="window下安装dubbo-admin">window下安装dubbo-admin</h3>
<p>dubbo本身并不是一个服务软件。它其实就是一个jar包，能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。</p>
<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序dubbo-admin，不过这个监控即使不装也不影响使用。</p>
<p>我们这里来安装一下：</p>
<p><strong>1、下载dubbo-admin</strong></p>
<p>地址 ：https://github.com/apache/dubbo-admin/tree/master</p>
<p><strong>2、解压进入目录</strong></p>
<p>修改 dubbo-admin\src\main\resources \application.properties 指定zookeeper地址</p>
<pre><code class="language-properties">server.port=7001
spring.velocity.cache=false
spring.velocity.charset=UTF-8
spring.velocity.layout-url=/templates/default.vm
spring.messages.fallback-to-system-locale=false
spring.messages.basename=i18n/message
spring.root.password=root
spring.guest.password=guest

dubbo.registry.address=zookeeper://127.0.0.1:2181
</code></pre>
<p><strong>3、在项目目录下</strong>打包dubbo-admin</p>
<pre><code class="language-properties">mvn clean package -Dmaven.test.skip=true
</code></pre>
<p><strong>第一次打包的过程有点慢，需要耐心等待！直到成功！</strong></p>
<p>4、执行 dubbo-admin\target 下的dubbo-admin-0.0.1-SNAPSHOT.jar</p>
<pre><code class="language-shell">java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
</code></pre>
<p>【注意：zookeeper的服务一定要打开！】</p>
<p>执行完毕，我们去访问一下 http://localhost:7001/ ， 这时候我们需要输入登录账户和密码，我们都是默认的root-root；</p>
<p>登录成功后，查看界面</p>
<figure data-type="image" tabindex="11"><img src="https://totoroay.github.io//post-images/1590586111130.png" alt="" loading="lazy"></figure>
<p>安装完成！</p>
<h2 id="springboot-dubbo-zookeeper">SpringBoot + Dubbo + zookeeper</h2>
<h3 id="框架搭建">框架搭建</h3>
<p><strong>1. 启动zookeeper ！</strong></p>
<p><strong>2. IDEA创建一个空项目；</strong></p>
<p><strong>3.创建一个模块，实现服务提供者：provider-server ， 选择web依赖即可</strong></p>
<p><strong>4.项目创建完毕，我们写一个服务，比如卖票的服务；</strong></p>
<p>编写接口</p>
<pre><code class="language-java">package com.totoroay.service;

public interface TicketService {
    String getTicket();

}
</code></pre>
<p>编写实现类</p>
<pre><code class="language-java">package com.totoroay.service.serviceimpl;

import com.totoroay.service.TicketService;

public class TicketServiceImpl implements TicketService {
    @Override
    public String getTicket() {
        return &quot;study&quot;;
    }
}
</code></pre>
<p><strong>5.创建一个模块，实现服务消费者：consumer-server ， 选择web依赖即可</strong></p>
<p><strong>6.项目创建完毕，我们写一个服务，比如用户的服务；</strong></p>
<p>编写service</p>
<pre><code class="language-java">package com.totoroay.service;

public class UserService {
	//我们需要去拿去注册中心的服务
}
</code></pre>
<p><strong>需求：现在我们的用户想使用买票的服务，这要怎么弄呢 ？</strong></p>
<h3 id="服务提供者">服务提供者</h3>
<p><strong>1、将服务提供者注册到注册中心，我们需要整合Dubbo和zookeeper，所以需要导包</strong></p>
<p><strong>我们从dubbo官网进入github，看下方的帮助文档，找到dubbo-springboot，找到依赖包</strong></p>
<pre><code class="language-xml">&lt;!-- Dubbo Spring Boot Starter --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;    
</code></pre>
<p><strong>zookeeper的包我们去maven仓库下载，zkclient；</strong></p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;
   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
   &lt;version&gt;0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>【新版的坑】zookeeper及其依赖包，解决日志冲突，还需要剔除日志依赖；</strong></p>
<pre><code class="language-xml">&lt;!-- 引入zookeeper --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
   &lt;version&gt;3.4.14&lt;/version&gt;
   &lt;!--排除这个slf4j-log4j12--&gt;
   &lt;exclusions&gt;
       &lt;exclusion&gt;
           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
       &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>2、在springboot配置文件中配置dubbo相关属性！</strong></p>
<pre><code class="language-properties">#当前应用名字
dubbo.application.name=provider-server
#注册中心地址
dubbo.registry.address=zookeeper://127.0.0.1:2181
#扫描指定包下服务
dubbo.scan.base-packages=com.totoroay.service
</code></pre>
<p><strong>3、在service的实现类中配置服务注解，发布服务！注意导包问题</strong></p>
<pre><code class="language-java">package com.totoroay.service.serviceimpl;

import com.totoroay.service.TicketService;
import org.apache.dubbo.config.annotation.Service;
import org.springframework.stereotype.Component;
@Service    //可以被扫描到，项目启动时自动注册到注册中心，dubbo中的service而不是springboot中的
@Component  //使用了dubbo后尽量不要使用springboot中的service注解
public class TicketServiceImpl implements TicketService {
    @Override
    public String getTicket() {
        return &quot;study...&quot;;
    }
}
</code></pre>
<p><strong>逻辑理解 ：应用启动起来，dubbo就会扫描指定的包下带有@component注解的服务，将它发布在指定的注册中心中！</strong></p>
<h3 id="服务消费者">服务消费者</h3>
<p><strong>1、导入依赖，和之前的依赖一样；</strong></p>
<pre><code class="language-xml">&lt;!--dubbo--&gt;
&lt;!-- Dubbo Spring Boot Starter --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
   &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
   &lt;version&gt;2.7.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--zookeeper--&gt;
&lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;
   &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
   &lt;version&gt;0.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- 引入zookeeper --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
   &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
   &lt;version&gt;2.12.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
   &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
   &lt;version&gt;3.4.14&lt;/version&gt;
   &lt;!--排除这个slf4j-log4j12--&gt;
   &lt;exclusions&gt;
       &lt;exclusion&gt;
           &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
           &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
       &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、<strong>配置参数</strong></p>
<pre><code class="language-properties">#当前应用名字
dubbo.application.name=consumer-server
#注册中心地址
dubbo.registry.address=zookeeper://127.0.0.1:2181
</code></pre>
<p><strong>3. 本来正常步骤是需要将服务提供者的接口打包，然后用pom文件导入，我们这里使用简单的方式，直接将服务的接口拿过来，路径必须保证正确，即和服务提供者相同；</strong></p>
<figure data-type="image" tabindex="12"><img src="https://totoroay.github.io//post-images/1590586083526.png" alt="" loading="lazy"></figure>
<p><strong>4. 完善消费者的服务类</strong></p>
<pre><code class="language-java">package com.totoroay.service;

import org.apache.dubbo.config.annotation.Reference;
import org.springframework.stereotype.Service;

@Service    //放到spring容器中
public class UserService {
    //我们需要去拿去注册中心的服务
    @Reference  //引用    pom坐标   可以定义路径相同的接口名
    TicketService ticketService;

    public void bugTicket(){
        String ticket = ticketService.getTicket();
        System.out.println(&quot;在注册中心买到：&quot;+ticket);
    }
}
</code></pre>
<p><strong>5. 测试类编写；</strong></p>
<pre><code class="language-java">package com.totoroay;

import com.totoroay.service.UserService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ConsumerServerApplicationTests {
	@Autowired
	UserService userService;

	@Test
	void contextLoads() {
		userService.bugTicket();
	}

}
</code></pre>
<h3 id="启动测试">启动测试</h3>
<p><strong>1. 开启zookeeper</strong></p>
<p><strong>2. 打开dubbo-admin实现监控【可以不用做】</strong></p>
<p><strong>3. 开启服务者</strong></p>
<p><strong>4. 消费者消费测试，结果：</strong></p>
<figure data-type="image" tabindex="13"><img src="https://totoroay.github.io//post-images/1590586075873.png" alt="" loading="lazy"></figure>
<p><strong>监控中心 ：</strong></p>
<figure data-type="image" tabindex="14"><img src="https://totoroay.github.io//post-images/1590586064155.png" alt="" loading="lazy"></figure>
<p><mark><strong>ok , 这就是SpingBoot + dubbo + zookeeper实现分布式开发的应用，其实就是一个服务拆分的思想</strong></mark></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 命令模式]]></title>
        <id>https://totoroay.github.io/post/ming-ling-mo-shi/</id>
        <link href="https://totoroay.github.io/post/ming-ling-mo-shi/">
        </link>
        <updated>2020-05-27T03:16:57.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1590549483270.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1590549475047.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1590549469038.png" alt="" loading="lazy"></figure>
<p><strong>代码实现</strong></p>
<pre><code class="language-java">package command;
//接受者：  录音机
public class Radio {
    public void play(){
        System.out.println(&quot;播放&quot;);
    }

    public void rewind(){
        System.out.println(&quot;倒带&quot;);
    }

    public void stop(){
        System.out.println(&quot;暂停&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package command;
//抽象命令类
public interface Command {
    public void execute();
}
</code></pre>
<pre><code class="language-java">package command;
//具体命令类：    播放
public class PlayCommand implements Command {
    private Radio radio;

    public PlayCommand(Radio radio){
        this.radio = radio;
    }

    @Override
    public void execute() {
        this.radio.play();
    }
}
</code></pre>
<pre><code class="language-java">package command;
//具体命令类：    倒带
public class RewindCommand implements Command {
    private Radio radio;

    public RewindCommand(Radio radio){
        this.radio = radio;
    }

    @Override
    public void execute() {
        this.radio.rewind();
    }
}
</code></pre>
<pre><code class="language-java">package command;
//具体命令类：    暂停
public class StopCommand implements Command {
    private Radio radio;

    public StopCommand(Radio radio){
        this.radio = radio;
    }

    @Override
    public void execute() {
        this.radio.stop();
    }
}
</code></pre>
<pre><code class="language-java">package command;
//请求者角色：    键盘
public class Keyboard {
    private Command playCommand;
    private Command rewindCommand;
    private Command stopCommand;

    public void setPlayCommand(Command playCommand) {
        this.playCommand = playCommand;
    }

    public void setRewindCommand(Command rewindCommand) {
        this.rewindCommand = rewindCommand;
    }

    public void setStopCommand(Command stopCommand) {
        this.stopCommand = stopCommand;
    }

    public void play(){
        playCommand.execute();
    }

    public void rewind(){
        playCommand.execute();
    }

    public void stop(){
        playCommand.execute();
    }
}
</code></pre>
<pre><code class="language-java">package command;
//测试类
public class CommandRadio {
    public static void main(String[] args) {
        //创建接受者对象
        Radio radio = new Radio();

        PlayCommand playCommand = new PlayCommand(radio);
        RewindCommand rewindCommand = new RewindCommand(radio);
        StopCommand stopCommand = new StopCommand(radio);

        Keyboard keyboard = new Keyboard();
        keyboard.setPlayCommand(playCommand);
        keyboard.setRewindCommand(rewindCommand);
        keyboard.setStopCommand(stopCommand);

        keyboard.play();
        keyboard.rewind();
        keyboard.stop();
    }
}
</code></pre>
<p><strong>测试结果</strong></p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1590549458525.png" alt="" loading="lazy"></figure>
<hr>
<hr>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1590549451000.png" alt="" loading="lazy"></figure>
<p><img src="https://totoroay.github.io//post-images/1590549447508.png" alt="" loading="lazy">)</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1590549443248.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[策略模式]]></title>
        <id>https://totoroay.github.io/post/ce-lue-mo-shi/</id>
        <link href="https://totoroay.github.io/post/ce-lue-mo-shi/">
        </link>
        <updated>2020-05-26T10:03:56.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1590487636583.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1590487631317.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1590487627733.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1590487622002.png" alt="" loading="lazy"></figure>
<p><mark><strong>代码实现</strong></mark></p>
<hr>
<pre><code class="language-java">package totoroay.strategy;
//抽象策略类     计算器
public interface ICalculator {
    int calc(int a, int b);
}
</code></pre>
<pre><code class="language-java">package totoroay.strategy;
//具体策略类     加法
public class Add implements ICalculator {
    @Override
    public int calc(int a, int b) {
        return a + b;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.strategy;
//具体策略类     减法
public class Sub implements ICalculator {
    @Override
    public int calc(int a, int b) {
        return a - b;
    }
}
</code></pre>
<p>还有乘法、除法可自行添加</p>
<pre><code class="language-java">package totoroay.strategy;
//环境类       （上下文）
public class Context {
    private  ICalculator iCalculator;

    public Context(ICalculator calculator){
        this.iCalculator = calculator;
    }

    public int calc(int a, int b){
        return this.iCalculator.calc(a, b);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.strategy;
//测试类
public class StrategyCalculator {
    public static void main(String[] args) {
        ICalculator add = new Add();
        Context context = new Context(add);
        int calc = context.calc(9, 3);
        System.out.println(calc);

        ICalculator sub = new Sub();
        Context context1 = new Context(sub);
        int calc1 = context1.calc(9, 3);
        System.out.println(calc1);
    }
}
</code></pre>
<p><strong>结果</strong></p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1590487614464.png" alt="" loading="lazy"></figure>
<hr>
<hr>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1590487601532.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1590487597916.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://totoroay.github.io//post-images/1590487593590.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[模板方法模式]]></title>
        <id>https://totoroay.github.io/post/mo-ban-fang-fa-mo-shi/</id>
        <link href="https://totoroay.github.io/post/mo-ban-fang-fa-mo-shi/">
        </link>
        <updated>2020-05-26T07:37:38.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1590481321608.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1590481317221.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1590481312474.png" alt="" loading="lazy"></figure>
<hr>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1590481307391.png" alt="" loading="lazy"></figure>
<hr>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1590481302138.png" alt="" loading="lazy"></figure>
<p><strong>代码实现</strong></p>
<hr>
<pre><code class="language-java">package totoroay.templatemethod;

//抽象类   炒菜流程
public abstract class CookVegetable {
    //具体方法
    public void wash(){
        System.out.println(&quot;洗菜&quot;);
    }

    public void pouroil(){
        System.out.println(&quot;倒油下锅&quot;);
    }

    public void fry(){
        System.out.println(&quot;炒菜&quot;);
    }

    //抽象方法  放调料
    public abstract void seasoning();

    //模板方法
    public void cook(){
        this.wash();
        this.pouroil();
        this.fry();
        this.seasoning();
        System.out.println(&quot;菜炒好了&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.templatemethod;

//具体子类  炒白菜
public class Cabbage extends CookVegetable {
    @Override
    public void pouroil() {
        System.out.println(&quot;少放油&quot;);
    }

    @Override
    public void seasoning() {
        System.out.println(&quot;加一点盐&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.templatemethod;

//具体子类  炒茄子
public class Eggplant extends CookVegetable {
    public void wash(){
        System.out.println(&quot;洗菜，去皮&quot;);
    }

    @Override
    public void seasoning() {
        System.out.println(&quot;加辣椒酱&quot;);
    }
}
</code></pre>
<pre><code>package totoroay.templatemethod;
//测试类
public class TemplateMethodCook {
    public static void main(String[] args) {
        Cabbage cabbage = new Cabbage();
        cabbage.cook();
        System.out.println(&quot;================================&quot;);
        Eggplant eggplant = new Eggplant();
        eggplant.cook();
    }
}
</code></pre>
<p><strong>结果</strong></p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1590481294414.png" alt="" loading="lazy"></figure>
<hr>
<hr>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1590481289104.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://totoroay.github.io//post-images/1590481285356.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://totoroay.github.io//post-images/1590481281105.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[组合模式]]></title>
        <id>https://totoroay.github.io/post/zu-he-mo-shi/</id>
        <link href="https://totoroay.github.io/post/zu-he-mo-shi/">
        </link>
        <updated>2020-05-26T07:35:05.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1590549387102.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1590549382195.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1590549376448.png" alt="" loading="lazy"></figure>
<p><strong>代码实现</strong></p>
<pre><code class="language-java">package totoroay.composite;

import java.util.ArrayList;
//透明组合模式
public class CompositePattern {
    public static void main(String[] args){
        Component c0=new Composite();
        Component c1=new Composite();
        Component leaf1=new Leaf(&quot;1&quot;);
        Component leaf2=new Leaf(&quot;2&quot;);
        Component leaf3=new Leaf(&quot;3&quot;);
        c0.add(leaf1);
        c0.add(c1);
        c1.add(leaf2);
        c1.add(leaf3);
        c0.operation();
    }
}
//抽象构件，补充代码
interface Component{
    public void add(Component c);
    public void remove(Component c);
    public Component getChild(int i);
    public void operation();
}
//树叶构件，补充代码
class Leaf implements Component{
    private String name;

    public Leaf(String name){
        this.name = name;
    }

    public void add(Component c){}
    public void remove(Component c){}

    public Component getChild(int i){
        return null;
    }

    public void operation(){
        System.out.println(&quot;树叶&quot;+name+&quot;： 被访问！&quot;);
    }
}
//树枝构件，补充代码
class Composite implements Component{
    private ArrayList&lt;Component&gt; children = new ArrayList&lt;Component&gt;();

    public void add(Component c){
        children.add(c);
    }

    public void remove(Component c){
        children.remove(c);
    }

    public Component getChild(int i){
        return children.get(i);
    }

    public void operation(){
        for(Object obj : children){
            ((Component)obj).operation();
        }
    }
}
</code></pre>
<p><strong>测试结果</strong></p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1590549364974.png" alt="" loading="lazy"></figure>
<hr>
<hr>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1590549321666.png" alt="" loading="lazy"></figure>
<p><strong>代码实现</strong></p>
<pre><code class="language-java">package totoroay.composite;

import java.util.ArrayList;
import java.util.List;
//安全组合模式
public class FileComposite {
    public static void main(String[] args) {
        Folder diskC = new Folder(&quot;C:\\&quot;);
        Folder windows = new Folder(&quot;---Windows&quot;);
        Folder system32 = new Folder(&quot;------system32&quot;);
        File calcFile = new File(&quot;---------calc.exe&quot;);
        File pingFile = new File(&quot;---------ping.exe&quot;);

        diskC.addDir(windows);
        windows.addDir(system32);
        system32.addDir(calcFile);
        system32.addDir(pingFile);

        diskC.print();
    }
}

//抽象根类：Component，补充代码
abstract class Directory{
    protected String name;

    public Directory(String name){
        this.name = name;
    }

    public abstract void print();
}

//叶子节点：Leaf，补充代码
class File extends Directory{
    public File(String name){
        super(name);
    }

    public void print(){
        System.out.println(this.name + &quot;: file&quot;);
    }
}

//树枝节点：Composite，补充代码
class Folder extends Directory{
    private List&lt;Directory&gt; mDirs;

    public Folder(String name){
        super(name);
        this.mDirs = new ArrayList&lt;Directory&gt;();
    }

    public void print(){
        System.out.println(this.name + &quot;: Folder&quot;);
        for(Directory dir : this.mDirs){
            dir.print();
        }
    }

    public boolean addDir(Directory dir){
        return this.mDirs.add(dir);
    }

    public boolean removeDir(Directory dir){
        return this.mDirs.remove(dir);
    }

    public Directory getDir(int index){
        return this.mDirs.get(index);
    }
}
</code></pre>
<p><strong>测试结果</strong></p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1590549312922.png" alt="" loading="lazy"></figure>
<hr>
<hr>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1590549307689.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://totoroay.github.io//post-images/1590549303591.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot15：异步、定时、邮件任务]]></title>
        <id>https://totoroay.github.io/post/springboot15yi-bu-ding-shi-you-jian-ren-wu/</id>
        <link href="https://totoroay.github.io/post/springboot15yi-bu-ding-shi-you-jian-ren-wu/">
        </link>
        <updated>2020-05-24T06:46:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="异步任务">异步任务</h2>
<p>1、创建一个service包</p>
<p>2、创建一个类AsyncService</p>
<p>异步处理还是非常常用的，比如我们在网站上发送邮件，后台会去发送邮件，此时前台会造成响应不动，直到邮件发送完毕，响应才会成功，所以我们一般会采用多线程的方式去处理这些任务。</p>
<p>编写方法，假装正在处理数据，使用线程设置一些延时，模拟同步等待的情况；</p>
<pre><code class="language-java">@Service
public class AsyncService {

   public void hello(){
       try {
           Thread.sleep(3000);
      } catch (InterruptedException e) {
           e.printStackTrace();
      }
       System.out.println(&quot;数据处理中....&quot;);
  }
}
</code></pre>
<p>3、编写controller包</p>
<p>4、编写AsyncController类</p>
<p>我们去写一个Controller测试一下</p>
<pre><code class="language-java">@RestController
public class AsyncController {

   @Autowired
   AsyncService asyncService;

   @GetMapping(&quot;/hello&quot;)
   public String hello(){
       asyncService.hello();
       return &quot;success&quot;;
  }

}
</code></pre>
<p>5、访问http://localhost:8080/hello进行测试，3秒后出现success，这是同步等待的情况。</p>
<p>问题：我们如果想让用户直接得到消息，就在后台使用多线程的方式进行处理即可，但是每次都需要自己手动去编写多线程的实现的话，太麻烦了，我们只需要用一个简单的办法，在我们的方法上加一个简单的注解即可，如下：</p>
<p>6、给hello方法添加@Async注解；</p>
<pre><code class="language-java">//告诉Spring这是一个异步方法
@Async
public void hello(){
   try {
       Thread.sleep(3000);
  } catch (InterruptedException e) {
       e.printStackTrace();
  }
   System.out.println(&quot;数据处理中....&quot;);
}
</code></pre>
<p>SpringBoot就会自己开一个线程池，进行调用！但是要让这个注解生效，我们还需要在主程序上添加一个注解@EnableAsync ，开启异步注解功能；</p>
<pre><code class="language-java">@EnableAsync //开启异步注解功能
@SpringBootApplication
public class SpringbootTaskApplication {

   public static void main(String[] args) {
       SpringApplication.run(SpringbootTaskApplication.class, args);
  }

}
</code></pre>
<p>7、重启测试，网页瞬间响应，后台代码依旧执行！</p>
<h2 id="邮件任务">邮件任务</h2>
<p>邮件发送，在我们的日常开发中，也非常的多，Springboot也帮我们做了支持</p>
<ul>
<li>邮件发送需要引入spring-boot-start-mail</li>
<li>SpringBoot 自动配置MailSenderAutoConfiguration</li>
<li>定义MailProperties内容，配置在application.yml中</li>
<li>自动装配JavaMailSender</li>
<li>测试邮件发送</li>
</ul>
<p><strong>测试：</strong></p>
<p>1、引入pom依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>看它引入的依赖，可以看到 jakarta.mail</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;com.sun.mail&lt;/groupId&gt;
   &lt;artifactId&gt;jakarta.mail&lt;/artifactId&gt;
   &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、查看自动配置类：MailSenderAutoConfiguration</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1590302826170.png" alt="" loading="lazy"></figure>
<p><mark><strong>这个类中存在bean，JavaMailSenderImpl</strong></mark></p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1590302821421.png" alt="" loading="lazy"></figure>
<p>然后我们去看下配置文件</p>
<pre><code class="language-java">@ConfigurationProperties(
   prefix = &quot;spring.mail&quot;
)
public class MailProperties {
   private static final Charset DEFAULT_CHARSET;
   private String host;
   private Integer port;
   private String username;
   private String password;
   private String protocol = &quot;smtp&quot;;
   private Charset defaultEncoding;
   private Map&lt;String, String&gt; properties;
   private String jndiName;
}
</code></pre>
<p>3、配置文件：</p>
<pre><code class="language-properties">spring.mail.username=2650334417@qq.com
spring.mail.password=你的qq授权码
spring.mail.host=smtp.qq.com
# qq需要配置ssl
spring.mail.properties.mail.smtp.ssl.enable=true
</code></pre>
<p>获取授权码：在QQ邮箱中的设置-&gt;账户-&gt;开启pop3和smtp服务</p>
<p>4、Spring单元测试</p>
<pre><code class="language-java">@Autowired
JavaMailSenderImpl mailSender;

@Test
public void contextLoads() {
   // 邮件设置1：一个简单的邮件
   SimpleMailMessage message = new SimpleMailMessage();
   message.setSubject(&quot;通知&quot;);
   message.setText(&quot;还不滚去学习！！！&quot;);

   message.setTo(&quot;3026925139@qq.com&quot;);
   message.setFrom(&quot;2650334417@qq.com&quot;);
   mailSender.send(message);
}

@Test
public void contextLoads2() throws MessagingException {
   // 邮件设置2：一个复杂的邮件
   MimeMessage mimeMessage = mailSender.createMimeMessage();
   // 组装
   MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);

   helper.setSubject(&quot;通知-pluse&quot;);
   helper.setText(&quot;&lt;p style='color:red'&gt;还不滚去学习！！！&lt;/p&gt;&quot;,true);

   //发送附件
   helper.addAttachment(&quot;作业1.png&quot;,new File(&quot;C:\\Users\\aYang\\Pictures\\作业1.png&quot;));
   helper.addAttachment(&quot;2.jpg&quot;,new File(&quot;C:\\Users\\aYang\\Pictures\\2.jpg&quot;));

   helper.setTo(&quot;3026925139@qq.com&quot;);
   helper.setFrom(&quot;2650334417@qq.com&quot;);

   mailSender.send(mimeMessage);
}
</code></pre>
<p>查看邮箱，邮件接收成功！</p>
<p>我们只需要使用Thymeleaf进行前后端结合即可开发自己网站邮件收发功能了！</p>
<h2 id="定时任务">定时任务</h2>
<p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。</p>
<ul>
<li>TaskExecutor接口	任务执行者</li>
<li>TaskScheduler接口	任务调度者</li>
</ul>
<p>两个注解：</p>
<ul>
<li>@EnableScheduling		开启定时功能的注解</li>
<li>@Scheduled		什么时候执行</li>
</ul>
<p>**cron表达式：**自行百度</p>
<p><strong>测试步骤：</strong></p>
<p>1、创建一个ScheduledService</p>
<p>我们里面存在一个hello方法，他需要定时执行，怎么处理呢？</p>
<pre><code class="language-java">@Service
public class ScheduledService {
   
   //秒   分   时     日   月   周几
   //0 * * * * MON-FRI
   //注意cron表达式的用法；
   @Scheduled(cron = &quot;0 * * * * 0-7&quot;)
   public void hello(){
       System.out.println(&quot;还不滚去学习！！！&quot;);
  }
}
</code></pre>
<p>2、这里写完定时任务之后，我们需要在主程序上增加@EnableScheduling 开启定时任务功能</p>
<pre><code class="language-java">@EnableAsync //开启异步注解功能
@EnableScheduling //开启基于注解的定时任务
@SpringBootApplication
public class SpringbootTaskApplication {

   public static void main(String[] args) {
       SpringApplication.run(SpringbootTaskApplication.class, args);
  }

}
</code></pre>
<p>3、我们来详细了解下cron表达式；</p>
<p>https://cron.qqe2.com/</p>
<p>4、常用的表达式</p>
<pre><code>（1）0/2 * * * * ?   表示每2秒 执行任务
（1）0 0/2 * * * ?   表示每2分钟 执行任务
（1）0 0 2 1 * ?   表示在每月的1日的凌晨2点调整任务
（2）0 15 10 ? * MON-FRI   表示周一到周五每天上午10:15执行作业
（3）0 15 10 ? 6L 2002-2006   表示2002-2006年的每个月的最后一个星期五上午10:15执行作
（4）0 0 10,14,16 * * ?   每天上午10点，下午2点，4点
（5）0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时
（6）0 0 12 ? * WED   表示每个星期三中午12点
（7）0 0 12 * * ?   每天中午12点触发
（8）0 15 10 ? * *   每天上午10:15触发
（9）0 15 10 * * ?     每天上午10:15触发
（10）0 15 10 * * ?   每天上午10:15触发
（11）0 15 10 * * ? 2005   2005年的每天上午10:15触发
（12）0 * 14 * * ?     在每天下午2点到下午2:59期间的每1分钟触发
（13）0 0/5 14 * * ?   在每天下午2点到下午2:55期间的每5分钟触发
（14）0 0/5 14,18 * * ?     在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
（15）0 0-5 14 * * ?   在每天下午2点到下午2:05期间的每1分钟触发
（16）0 10,44 14 ? 3 WED   每年三月的星期三的下午2:10和2:44触发
（17）0 15 10 ? * MON-FRI   周一至周五的上午10:15触发
（18）0 15 10 15 * ?   每月15日上午10:15触发
（19）0 15 10 L * ?   每月最后一日的上午10:15触发
（20）0 15 10 ? * 6L   每月的最后一个星期五上午10:15触发
（21）0 15 10 ? * 6L 2002-2005   2002年至2005年的每月的最后一个星期五上午10:15触发
（22）0 15 10 ? * 6#3   每月的第三个星期五上午10:15触发
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot14：集成Swagger]]></title>
        <id>https://totoroay.github.io/post/springboot14ji-cheng-swagger/</id>
        <link href="https://totoroay.github.io/post/springboot14ji-cheng-swagger/">
        </link>
        <updated>2020-05-24T06:43:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="swagger简介">Swagger简介</h2>
<p><strong>前后端分离</strong></p>
<ul>
<li>前端 -&gt; 前端控制层、视图层</li>
<li>后端 -&gt; 后端控制层、服务层、数据访问层</li>
<li>前后端通过API进行交互</li>
<li>前后端相对独立且松耦合</li>
</ul>
<p><strong>产生的问题</strong></p>
<ul>
<li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li>
</ul>
<p><strong>Swagger</strong></p>
<ul>
<li>号称世界上最流行的API框架</li>
<li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li>
<li>直接运行，在线测试API</li>
<li>支持多种语言 （如：Java，PHP等）</li>
<li>官网：https://swagger.io/</li>
</ul>
<h2 id="springboot集成swagger">SpringBoot集成Swagger</h2>
<p><strong>SpringBoot集成Swagger</strong> =&gt; <strong>springfox</strong>，两个jar包</p>
<ul>
<li><strong>Springfox-swagger2</strong></li>
<li>swagger-springmvc</li>
</ul>
<p><strong>使用Swagger</strong></p>
<p>要求：jdk 1.8 + 否则swagger2无法运行</p>
<p>步骤：</p>
<p>1、新建一个SpringBoot-web项目</p>
<p>2、添加Maven依赖</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;io.springfox&lt;/groupId&gt;
   &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
   &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;io.springfox&lt;/groupId&gt;
   &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
   &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、编写HelloController，测试确保运行成功！</p>
<p>4、要使用Swagger，我们需要编写一个配置类-SwaggerConfig来配置 Swagger</p>
<pre><code class="language-java">@Configuration //配置类
@EnableSwagger2// 开启Swagger2的自动配置
public class SwaggerConfig {  
}
</code></pre>
<p>5、访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面；</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1590302719691.png" alt="" loading="lazy"></figure>
<h2 id="配置swagger">配置Swagger</h2>
<p>1、Swagger实例Bean是Docket，所以在SwaggerConfig中通过配置Docket实例来配置Swaggger。</p>
<pre><code class="language-java">@Bean //配置docket以配置Swagger具体参数
public Docket docket() {
   return new Docket(DocumentationType.SWAGGER_2);
}
</code></pre>
<p>2、可以通过apiInfo()属性配置文档信息</p>
<pre><code class="language-java">//配置文档信息
private ApiInfo apiInfo() {
   Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);
   return new ApiInfo(
           &quot;Swagger学习&quot;, // 标题
           &quot;学习演示如何配置Swagger&quot;, // 描述
           &quot;v1.0&quot;, // 版本
           &quot;http://terms.service.url/组织链接&quot;, // 组织链接
           contact, // 联系人信息
           &quot;Apach 2.0 许可&quot;, // 许可
           &quot;许可链接&quot;, // 许可连接
           new ArrayList&lt;&gt;()// 扩展
  );
}
</code></pre>
<p>3、Docket 实例关联上 apiInfo()</p>
<pre><code class="language-java">@Bean
public Docket docket() {
   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());
}
</code></pre>
<p>4、重启项目，访问测试 http://localhost:8080/swagger-ui.html  看下效果；</p>
<h2 id="配置扫描接口">配置扫描接口</h2>
<p>1、构建Docket时通过select()方法配置怎么扫描接口。</p>
<pre><code class="language-java">@Bean
public Docket docket() {
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.totoroay.controller&quot;))
      .build();
}
</code></pre>
<p>2、重启项目测试，由于我们配置根据包的路径扫描接口，所以我们只能看到一个类</p>
<p>3、除了通过包路径配置扫描接口外，还可以通过配置其他方式扫描接口，这里注释一下所有的配置方式：</p>
<pre><code class="language-java">any() // 扫描所有，项目中的所有接口都会被扫描到
none() // 不扫描接口
// 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求
withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)
// 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口
withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)
basePackage(final String basePackage) // 根据包路径扫描接口
</code></pre>
<p>4、除此之外，我们还可以配置接口扫描过滤：</p>
<pre><code class="language-java">@Bean
public Docket docket() {
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.totoroay.controller&quot;))
       // 配置如何通过path过滤,即这里只扫描请求以/totoroay开头的接口
      .paths(PathSelectors.ant(&quot;/totoroay/**&quot;))
      .build();
}
</code></pre>
<p>5、这里的可选值还有</p>
<pre><code class="language-java">any() // 任何请求都扫描
none() // 任何请求都不扫描
regex(final String pathRegex) // 通过正则表达式控制
ant(final String antPattern) // 通过ant()控制
</code></pre>
<h2 id="配置swagger开关">配置Swagger开关</h2>
<p>1、通过enable()方法配置是否启用swagger，如果是false，swagger将不能在浏览器中访问了</p>
<pre><code class="language-java">@Bean
public Docket docket() {
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .enable(false) //配置是否启用Swagger，如果是false，在浏览器将无法访问
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.totoroay.controller&quot;))
       // 配置如何通过path过滤,即这里只扫描请求以/totoroay开头的接口
      .paths(PathSelectors.ant(&quot;/totoroay/**&quot;))
      .build();
}
</code></pre>
<p>2、如何动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示？</p>
<pre><code class="language-java">@Bean
public Docket docket(Environment environment) {
   // 设置要显示swagger的环境
   Profiles of = Profiles.of(&quot;dev&quot;);
   // 判断当前是否处于该环境
   // 通过 enable() 接收此参数判断是否要显示
   boolean b = environment.acceptsProfiles(of);
   
   return new Docket(DocumentationType.SWAGGER_2)
      .apiInfo(apiInfo())
      .enable(b) //配置是否启用Swagger，如果是false，在浏览器将无法访问
      .select()// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口
      .apis(RequestHandlerSelectors.basePackage(&quot;com.totoroay.controller&quot;))
       // 配置如何通过path过滤,即这里只扫描请求以/kuang开头的接口
      .paths(PathSelectors.ant(&quot;/totoroay/**&quot;))
      .build();
}
</code></pre>
<p>3、可以在项目中增加一个dev以及prod的配置文件查看效果！</p>
<h2 id="配置api分组">配置API分组</h2>
<p>1、如果没有配置分组，默认是default。通过groupName()方法即可配置分组：</p>
<pre><code class="language-java">@Bean
public Docket docket(Environment environment) {
   return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())
      .groupName(&quot;hello&quot;) // 配置分组
       // 省略配置....
}
</code></pre>
<p>2、重启项目查看分组</p>
<p>3、如何配置多个分组？配置多个分组只需要配置多个docket即可：</p>
<pre><code>@Bean
public Docket docket1(){
   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);
}
@Bean
public Docket docket2(){
   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group2&quot;);
}
@Bean
public Docket docket3(){
   return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group3&quot;);
}
</code></pre>
<p>4、重启项目查看即可</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1590302695137.png" alt="" loading="lazy"></figure>
<h2 id="实体配置">实体配置</h2>
<p>1、新建一个实体类</p>
<pre><code class="language-java">@ApiModel(&quot;用户实体&quot;)
public class User {
   @ApiModelProperty(&quot;用户名&quot;)
   public String username;
   @ApiModelProperty(&quot;密码&quot;)
   public String password;
}
</code></pre>
<p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p>
<pre><code class="language-java">@RequestMapping(&quot;/getUser&quot;)
public User getUser(){
   return new User();
}
</code></pre>
<p>3、重启查看测试</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1590302687762.png" alt="" loading="lazy"></figure>
<p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p>
<p>@ApiModel为类添加注释</p>
<p>@ApiModelProperty为类属性添加注释</p>
<h2 id="常用注解">常用注解</h2>
<p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th>简单说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Api(tags = &quot;xxx模块说明&quot;)</td>
<td>作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(&quot;xxx接口说明&quot;)</td>
<td>作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(&quot;xxxPOJO说明&quot;)</td>
<td>作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value = &quot;xxx属性说明&quot;,hidden = true)</td>
<td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(&quot;xxx参数说明&quot;)</td>
<td>作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
</tbody>
</table>
<p>我们也可以给请求的接口配置一些注释</p>
<pre><code class="language-java">@ApiOperation(&quot;totoroay的接口&quot;)
@PostMapping(&quot;/totoroay&quot;)
@ResponseBody
public String kuang(@ApiParam(&quot;这个名字会被返回&quot;)String username){
   return username;
}
</code></pre>
<p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p>
<p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>
<p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>
<h2 id="总结">总结</h2>
<ul>
<li>可以通过Swagger给一些比较难理解的属性或接口，增加注释信息</li>
<li>接口文档实时更新</li>
<li>可以在线测试</li>
</ul>
<p>注意：项目正式上线关闭Swagger</p>
<h2 id="拓展其他皮肤">拓展：其他皮肤</h2>
<p>1、bootstrap-ui  <strong>访问 http://localhost:8080/doc.html</strong></p>
<pre><code class="language-xml">&lt;!-- 引入swagger-bootstrap-ui包 /doc.html--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;
   &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;
   &lt;version&gt;1.9.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、Layui-ui  <strong>访问 http://localhost:8080/docs.html</strong></p>
<pre><code>&lt;!-- 引入swagger-ui-layer包 /docs.html--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.github.caspar-chen&lt;/groupId&gt;
   &lt;artifactId&gt;swagger-ui-layer&lt;/artifactId&gt;
   &lt;version&gt;1.1.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、mg-ui  <strong>访问 http://localhost:8080/document.html</strong></p>
<pre><code>&lt;!-- 引入swagger-ui-layer包 /document.html--&gt;
&lt;dependency&gt;
   &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;
   &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;
   &lt;version&gt;1.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[享元模式]]></title>
        <id>https://totoroay.github.io/post/xiang-yuan-mo-shi/</id>
        <link href="https://totoroay.github.io/post/xiang-yuan-mo-shi/">
        </link>
        <updated>2020-05-19T12:54:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589893007462.png" alt="" loading="lazy"></figure>
<ul>
<li>内部状态：
<ul>
<li><mark>不会随着环境的改变而改变</mark>的可共享部分</li>
</ul>
</li>
<li>外部状态：
<ul>
<li><mark>随环境改变而改变</mark>的不可共享部分</li>
</ul>
</li>
</ul>
<p><img src="https://totoroay.github.io//post-images/1589893002631.png" alt="" loading="lazy"><br>
<strong>实例</strong></p>
<pre><code class="language-java">package totoroay.flyweight;
// 抽象享元     火车票
public interface ITicket {
    void showInfo(String level);
}
</code></pre>
<pre><code class="language-java">package totoroay.flyweight;
// 具体享元
public class TrainTicket implements ITicket {
    private String from;
    private String to;
    private int price;

    public TrainTicket(String from, String to) {
        this.from = from;
        this.to = to;
    }

    @Override
    public void showInfo(String level) {
        if (level.equals(&quot;一等座&quot;))
            this.price=50;
        else
            this.price=42;
        System.out.println(String.format(&quot;%s==&gt;%s: %s价格: %d 元&quot;, this.from, this.to, level, this.price));
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.flyweight;

import java.util.HashMap;
import java.util.Map;

// 享元工厂
public class TicketFactory {
    private static Map&lt;String, ITicket&gt; sTicketPool = new HashMap&lt;String, ITicket&gt;();

    public static ITicket queryTicket(String from, String to) {
        String key = from + &quot;==&gt;&quot; + to;
        // 如果有，从缓存中拿
        if (TicketFactory.sTicketPool.containsKey(key)) {
            System.out.println(&quot;使用缓存&quot;);
            return TicketFactory.sTicketPool.get(key);
        }

        // 如果没有，生成，并放入缓存
        System.out.println(&quot;第一次&quot;);
        TrainTicket trainTicket = new TrainTicket(from, to);
        TicketFactory.sTicketPool.put(key, trainTicket);
        return trainTicket;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.flyweight;
// 客户
public class TicketFlyweight {
    public static void main(String[] args) {
        // 非享元
        ITicket ticket1 = TicketFactory.queryTicket(&quot;南极&quot;, &quot;北极&quot;);
        ticket1.showInfo(&quot;一等座&quot;);

        ITicket ticket2 = TicketFactory.queryTicket(&quot;南极&quot;, &quot;北极&quot;);
        ticket2.showInfo(&quot;二等座&quot;);
    }
}
</code></pre>
<p><strong>测试结果</strong></p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589892993118.png" alt="" loading="lazy"></figure>
<p><strong>结构分析</strong></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589892988665.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589892985099.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589892979921.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1589892973488.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot12：集成SpringSecurity]]></title>
        <id>https://totoroay.github.io/post/springboot12ji-cheng-springsecurity/</id>
        <link href="https://totoroay.github.io/post/springboot12ji-cheng-springsecurity/">
        </link>
        <updated>2020-05-18T13:32:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安全简介">安全简介</h2>
<p>在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p>
<p>市面上存在比较有名的：Shiro，Spring Security ！</p>
<p>这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？</p>
<p>首先我们看下它的官网介绍：Spring Security官网地址</p>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p>
<p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p>
<p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</p>
<p>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</p>
<p>从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。</p>
<p>怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。</p>
<p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>
<p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</p>
<h2 id="实验环境搭建">实验环境搭建</h2>
<p>1、新建一个初始的springboot项目web模块，thymeleaf模块</p>
<p>2、导入静态资源</p>
<p>3、controller跳转！</p>
<pre><code class="language-java">package com.totoroay.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class RouteController {
    @RequestMapping({&quot;/&quot;,&quot;/index&quot;,&quot;/index.html&quot;})
    public String index(){
        return &quot;index&quot;;
    }

    @RequestMapping(&quot;/toLogin&quot;)
    public String toLogin(){
        return &quot;views/login&quot;;
    }

    @RequestMapping(&quot;/level1/{id}&quot;)
    public String level1(@PathVariable(&quot;id&quot;) int id){
        return &quot;views/level1/&quot;+id;
    }
    @RequestMapping(&quot;/level2/{id}&quot;)
    public String level2(@PathVariable(&quot;id&quot;) int id){
        return &quot;views/level2/&quot;+id;
    }
    @RequestMapping(&quot;/level3/{id}&quot;)
    public String level3(@PathVariable(&quot;id&quot;) int id){
        return &quot;views/level3/&quot;+id;
    }
}
</code></pre>
<p>4、测试实验环境是否OK！</p>
<h2 id="认识springsecurity">认识SpringSecurity</h2>
<p>Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p>
<p>记住几个类：</p>
<ul>
<li>WebSecurityConfigurerAdapter：自定义Security策略</li>
<li>AuthenticationManagerBuilder：自定义认证策略</li>
<li>@EnableWebSecurity：开启WebSecurity模式</li>
</ul>
<p>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p>
<p><strong>“认证”（Authentication）</strong></p>
<p>身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。</p>
<p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p>
<p><strong>“授权” （Authorization）</strong></p>
<p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p>
<p>这个概念是通用的，而不是只在Spring Security 中存在。</p>
<h2 id="认证和授权">认证和授权</h2>
<p>目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能</p>
<p>1、引入 Spring Security 模块</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、编写 Spring Security 配置类</p>
<p>参考官网：https://spring.io/projects/spring-security</p>
<p>查看我们自己项目中的版本，找到对应的帮助文档：</p>
<p>https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5#servlet-applications8.16.4</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589808847466.png" alt="" loading="lazy"></figure>
<p>3、编写基础配置类</p>
<pre><code class="language-java">package com.totoroay.config;

import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        
    }
}
</code></pre>
<p>4、定制请求的授权规则</p>
<pre><code class="language-java">@Override
protected void configure(HttpSecurity http) throws Exception {
   // 定制请求的授权规则
   // 首页所有人可以访问
   http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()
  .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)
  .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
  .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);
}
</code></pre>
<p>5、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！</p>
<p>6、在configure()方法中加入以下配置，开启自动配置的登录功能！</p>
<pre><code class="language-java">// 开启自动配置的登录功能
// /login 请求来到登录页
// /login?error 重定向到这里表示登录失败
http.formLogin();
</code></pre>
<p>7、测试一下：发现，没有权限的时候，会跳转到登录的页面！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589808839089.png" alt="" loading="lazy"></figure>
<p>8、查看刚才登录页的注释信息；</p>
<p>我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法</p>
<pre><code class="language-java">//定义认证规则
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception{

        //在内存中定义，也可以在jdbc中去拿....
        auth.inMemoryAuthentication()
                .withUser(&quot;totoroay&quot;).password(&quot;totoroay&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
                .and()
                .withUser(&quot;root&quot;).password(&quot;root&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;)
                .and()
                .withUser(&quot;guest&quot;).password(&quot;guest&quot;).roles(&quot;vip1&quot;);
    }
</code></pre>
<p>9、测试，我们可以使用这些账号登录进行测试！发现会报错！</p>
<p>There is no PasswordEncoder mapped for the id “null”</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589808831367.png" alt="" loading="lazy"></figure>
<p>10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码</p>
<pre><code class="language-java">// 缓存
//定义认证规则
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
   //在内存中定义，也可以在jdbc中去拿....
   //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。
   //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密
   //spring security 官方推荐的是使用bcrypt加密方式。
   
   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
          .withUser(&quot;totoroay&quot;).password(new BCryptPasswordEncoder().encode(&quot;totoroay&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
          .and()
          .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;root&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;)
          .and()
          .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;guest&quot;)).roles(&quot;vip1&quot;);
}
</code></pre>
<pre><code class="language-java">// 数据库
@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    // ensure the passwords are encoded properly
    UserBuilder users = User.withDefaultPasswordEncoder();
    auth
        .jdbcAuthentication()
            .dataSource(dataSource)
            .withDefaultSchema()
            .withUser(users.username(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;))
            .withUser(users.username(&quot;admin&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;,&quot;ADMIN&quot;));
}
</code></pre>
<p>11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定</p>
<h2 id="权限控制和注销">权限控制和注销</h2>
<p>1、开启自动配置的注销的功能</p>
<pre><code class="language-java">//定制请求的授权规则
@Override
protected void configure(HttpSecurity http) throws Exception {
   //....
   //开启自动配置的注销的功能
      // /logout 注销请求
   http.logout();
}
</code></pre>
<p>2、我们在前端，增加一个注销的按钮，index.html 导航栏中</p>
<pre><code class="language-html">&lt;a class=&quot;item&quot; th:href=&quot;@{/logout}&quot;&gt;
   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销
&lt;/a&gt;
</code></pre>
<p>3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！</p>
<p>4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？</p>
<pre><code class="language-java">// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页
http.logout().logoutSuccessUrl(&quot;/&quot;);
</code></pre>
<p>5、测试，注销完毕后，发现跳转到首页OK</p>
<p>6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？</p>
<p>我们需要结合thymeleaf中的一些功能</p>
<p>sec：authorize=&quot;isAuthenticated()&quot;:是否认证登录！来显示不同的页面</p>
<p>Maven依赖：</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
   &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;
   &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>7、修改我们的 前端页面</p>
<ol>
<li>导入命名空间</li>
</ol>
<pre><code>xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;
</code></pre>
<p>​		修改导航栏，增加认证判断</p>
<pre><code class="language-html">&lt;!--登录注销--&gt;
&lt;div class=&quot;right menu&quot;&gt;

   &lt;!--如果未登录--&gt;
   &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot; th:href=&quot;@{/login}&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录
       &lt;/a&gt;
   &lt;/div&gt;

   &lt;!--如果已登录--&gt;
   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt;
          用户名：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;
          角色：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;
       &lt;/a&gt;
   &lt;/div&gt;

   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot; th:href=&quot;@{/logout}&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销
       &lt;/a&gt;
   &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面；</p>
<p>9、如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 <code>http.csrf().disable();</code></p>
<pre><code class="language-java">http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求
http.logout().logoutSuccessUrl(&quot;/&quot;);
</code></pre>
<p>10、我们继续将下面的角色功能块认证完成！</p>
<pre><code class="language-html">&lt;!-- sec:authorize=&quot;hasRole('vip1')&quot; --&gt;
&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole('vip1')&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level1/1}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level1/2}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level1/3}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole('vip2')&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level2/1}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level2/2}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level2/3}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole('vip3')&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level3/1}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level3/2}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level3/3}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>11、测试一下！</p>
<p>12、权限控制和注销搞定！</p>
<h2 id="记住我">记住我</h2>
<p>现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单</p>
<p>1、开启记住我功能</p>
<pre><code class="language-java">//定制请求的授权规则
@Override
protected void configure(HttpSecurity http) throws Exception {
//。。。。。。。。。。。
   //记住我
   http.rememberMe();
}
</code></pre>
<p>2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！</p>
<p>思考：如何实现的呢？其实非常简单</p>
<p>我们可以查看浏览器的cookie</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589808811830.png" alt="" loading="lazy"></figure>
<p>3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589808804512.png" alt="" loading="lazy"></figure>
<p>4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！</p>
<h2 id="定制登录页">定制登录页</h2>
<p>现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？</p>
<p>1、在刚才的登录页配置后面指定 loginpage</p>
<pre><code class="language-java">http.formLogin().loginPage(&quot;/toLogin&quot;);
</code></pre>
<p>2、然后前端也需要指向我们自己定义的 login请求</p>
<pre><code class="language-xml">&lt;a class=&quot;item&quot; th:href=&quot;@{/toLogin}&quot;&gt;
   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录
&lt;/a&gt;
</code></pre>
<p>3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post:</p>
<p>在 loginPage()源码中的注释上有写明：</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1589808795276.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;form th:action=&quot;@{/login}&quot; method=&quot;post&quot;&gt;
   &lt;div class=&quot;field&quot;&gt;
       &lt;label&gt;Username&lt;/label&gt;
       &lt;div class=&quot;ui left icon input&quot;&gt;
           &lt;input type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;&gt;
           &lt;i class=&quot;user icon&quot;&gt;&lt;/i&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;div class=&quot;field&quot;&gt;
       &lt;label&gt;Password&lt;/label&gt;
       &lt;div class=&quot;ui left icon input&quot;&gt;
           &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
           &lt;i class=&quot;lock icon&quot;&gt;&lt;/i&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;input type=&quot;submit&quot; class=&quot;ui blue submit button&quot;/&gt;
&lt;/form&gt;
</code></pre>
<p>4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！</p>
<pre><code class="language-java">http.formLogin()
  .usernameParameter(&quot;username&quot;)
  .passwordParameter(&quot;password&quot;)
  .loginPage(&quot;/toLogin&quot;)
  .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求
</code></pre>
<p>5、在登录页增加记住我的多选框</p>
<pre><code class="language-html">&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我
</code></pre>
<p>6、后端验证处理！</p>
<pre><code class="language-java">//定制记住我的参数！
http.rememberMe().rememberMeParameter(&quot;remember&quot;);
</code></pre>
<p>7、测试，OK</p>
<h2 id="完整配置代码">完整配置代码</h2>
<pre><code class="language-java">package com.totoroay.config;

import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

   //定制请求的授权规则
   @Override
   protected void configure(HttpSecurity http) throws Exception {

       http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()
      .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)
      .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
      .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);


       //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！
           // /login 请求来到登录页
           // /login?error 重定向到这里表示登录失败
       http.formLogin()
          .usernameParameter(&quot;username&quot;)
          .passwordParameter(&quot;password&quot;)
          .loginPage(&quot;/toLogin&quot;)
          .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求

       //开启自动配置的注销的功能
           // /logout 注销请求
           // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页

       http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求
       http.logout().logoutSuccessUrl(&quot;/&quot;);

       //记住我
       http.rememberMe().rememberMeParameter(&quot;remember&quot;);
  }

   //定义认证规则
   @Override
   protected void configure(AuthenticationManagerBuilder auth) throws Exception {
       //在内存中定义，也可以在jdbc中去拿....
       //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。
       //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密
       //spring security 官方推荐的是使用bcrypt加密方式。

       auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
              .withUser(&quot;totoroay&quot;).password(new BCryptPasswordEncoder().encode(&quot;totoroay&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
              .and()
              .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;root&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;)
              .and()
              .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;guest&quot;)).roles(&quot;vip1&quot;);
  }
}
</code></pre>
]]></content>
    </entry>
</feed>