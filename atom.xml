<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://totoroay.github.io/</id>
    <title>totoroay</title>
    <updated>2020-05-08T09:37:41.600Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://totoroay.github.io/"/>
    <link rel="self" href="https://totoroay.github.io/atom.xml"/>
    <subtitle>每天学习5小时！！！</subtitle>
    <logo>https://totoroay.github.io/images/avatar.png</logo>
    <icon>https://totoroay.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, totoroay</rights>
    <entry>
        <title type="html"><![CDATA[Spring：自动装配及使用注解开发]]></title>
        <id>https://totoroay.github.io/post/springzi-dong-zhuang-pei-ji-shi-yong-zhu-jie-kai-fa/</id>
        <link href="https://totoroay.github.io/post/springzi-dong-zhuang-pei-ji-shi-yong-zhu-jie-kai-fa/">
        </link>
        <updated>2020-05-08T09:36:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自动装配">自动装配</h2>
<blockquote>
<p>自动装配说明</p>
</blockquote>
<ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li>
</ul>
<p>Spring中bean有三种装配机制，分别是：</p>
<ol>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ol>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<ol>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li>
</ol>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p>
<blockquote>
<p>测试环境搭建</p>
</blockquote>
<p>1、新建一个项目</p>
<p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p>
<pre><code class="language-java">package com.totoroay.pojo;

public class Cat {
    public void shout(){
        System.out.println(&quot;喵&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.totoroay.pojo;

public class Dog {
    public void shout(){
        System.out.println(&quot;汪&quot;);
    }
}
</code></pre>
<p>3、新建一个用户类 User</p>
<pre><code class="language-java">public class User {
   private Cat cat;
   private Dog dog;
   private String name;
}
</code></pre>
<p>4、编写Spring配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
   &lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;&gt;
       &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
       &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;
       &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
   &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="language-java">public class MyTest {
   @Test
   public void testMethodAutowire() {
       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       User user = (User) context.getBean(&quot;user&quot;);
       user.getCat().shout();
       user.getDog().shout();
  }
}
</code></pre>
<p>结果正常输出，环境OK</p>
<blockquote>
<p>byName</p>
</blockquote>
<p><strong>autowire byName (按名称自动装配)</strong></p>
<p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p>
<p>采用自动装配将避免这些错误，并且使配置简单化。</p>
<p>测试：</p>
<p>1、修改bean配置，增加一个属性  autowire=&quot;byName&quot;</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; autowire=&quot;byName&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>2、再次测试，结果依旧成功输出！</p>
<p>3、我们将 cat 的bean id修改为 catXXX</p>
<p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p>
<p><strong>小结：</strong></p>
<p>当一个bean节点带有 autowire byName的属性时。</p>
<ol>
<li>
<p>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</p>
</li>
<li>
<p>去spring容器中寻找是否有此字符串名称id的对象。</p>
</li>
<li>
<p>如果有，就取出注入；如果没有，就报空指针异常。</p>
</li>
</ol>
<blockquote>
<p>byType</p>
</blockquote>
<p><strong>autowire byType (按类型自动装配)</strong></p>
<p>使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。</p>
<pre><code>NoUniqueBeanDefinitionException
</code></pre>
<p>测试：</p>
<p>1、将user的bean配置修改一下 ： autowire=&quot;byType&quot;</p>
<p>2、测试，正常输出</p>
<p>3、在注册一个cat 的bean对象！</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; autowire=&quot;byType&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>4、测试，报错：NoUniqueBeanDefinitionException</p>
<p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
<h2 id="使用注解">使用注解</h2>
<blockquote>
<p>使用注解</p>
</blockquote>
<p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p>
<p>准备工作：利用注解的方式注入属性。</p>
<p>1、在spring配置文件中引入context文件头</p>
<pre><code class="language-xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;

http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
</code></pre>
<p>2、开启属性注解支持！</p>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;/&gt;
    &lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="autowired">@Autowired</h4>
<ul>
<li>@Autowired是按类型自动转配的，不支持id匹配。</li>
<li>需要导入 spring-aop的包！</li>
</ul>
<p>测试：</p>
<p>1、将User类中的set方法去掉，使用@Autowired注解</p>
<pre><code class="language-java">public class User {
   @Autowired
   private Cat cat;
   @Autowired
   private Dog dog;
   private String name;

   public Cat getCat() {
       return cat;
  }
   public Dog getDog() {
       return dog;
  }
   public String getName() {
       return str;
  }
}
</code></pre>
<p>2、此时配置文件内容</p>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
</code></pre>
<p>3、测试，成功输出结果！</p>
<p>【科普时间】</p>
<p>@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p>
<pre><code>//如果允许对象为null，设置required = false,默认为true
@Autowired(required = false)
private Cat cat;
</code></pre>
<h4 id="qualifier">@Qualifier</h4>
<ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用。</li>
</ul>
<p>测试实验步骤：</p>
<p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog1&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;dog2&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
</code></pre>
<p>2、没有加Qualifier测试，直接报错</p>
<p>3、在属性上添加Qualifier注解</p>
<pre><code class="language-java">@Autowired
@Qualifier(value = &quot;cat2&quot;)
private Cat cat;
@Autowired
@Qualifier(value = &quot;dog2&quot;)
private Dog dog;
</code></pre>
<p>测试，成功输出！</p>
<h4 id="resource">@Resource</h4>
<ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
<p>实体类：</p>
<pre><code class="language-java">public class User {
   //如果允许对象为null，设置required = false,默认为true
   @Resource(name = &quot;cat2&quot;)
   private Cat cat;
   @Resource
   private Dog dog;
   private String str;
}
</code></pre>
<p>beans.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;/&gt;
</code></pre>
<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>实体类上只保留注解</p>
<pre><code class="language-java">@Resource
private Cat cat;
@Resource
private Dog dog;
</code></pre>
<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<h3 id="小结">小结</h3>
<p>@Autowired与@Resource异同：</p>
<p>1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</p>
<p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p>
<h2 id="使用注解开发">使用注解开发</h2>
<p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588930619093.png" alt="" loading="lazy"></figure>
<p>在配置文件当中，还得要引入一个context约束</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    
    &lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;
    &lt;context:component-scan base-package=&quot;com.totoroay.pojo&quot;/&gt;
    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<blockquote>
<p>Bean的实现</p>
</blockquote>
<p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p>
<p>1、配置扫描哪些包下的注解</p>
<pre><code class="language-xml">&lt;!--指定注解扫描包--&gt;
&lt;context:component-scan base-package=&quot;com.totoroay.pojo&quot;/&gt;
</code></pre>
<p>2、在指定包下编写类，增加注解</p>
<pre><code class="language-java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User {
   public String name = &quot;totoroay&quot;;
}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void test(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    User user = context.getBean(&quot;user&quot;, User.class);
    System.out.println(user.getName());
}
</code></pre>
<blockquote>
<p>属性注入</p>
</blockquote>
<p>使用注解注入属性</p>
<p>1、可以不用提供set方法，直接在直接名上添加@value(&quot;值&quot;)</p>
<pre><code class="language-java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User {
   @Value(&quot;totoroay&quot;)
   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
   public String name;
}
</code></pre>
<p>2、如果提供了set方法，也可以在set方法上添加@value(&quot;值&quot;);</p>
<pre><code class="language-java">@Component(&quot;user&quot;)
public class User {

   public String name;

   @Value(&quot;totoroay&quot;)
   public void setName(String name) {
       this.name = name;
  }
}
</code></pre>
<blockquote>
<p>衍生注解</p>
</blockquote>
<p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p>
<p><strong>@Component三个衍生注解</strong></p>
<p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li>@Controller：web层</li>
<li>@Service：service层</li>
<li>@Repository：dao层</li>
</ul>
<p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<blockquote>
<p>自动装配注解</p>
</blockquote>
<p>在Bean的自动装配已经讲过了，可以回顾！</p>
<blockquote>
<p>作用域</p>
</blockquote>
<p>@scope</p>
<ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式（原型模式）。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li>
</ul>
<pre><code class="language-java">@Controller(&quot;user&quot;)
@Scope(&quot;prototype&quot;)
public class User {
   @Value(&quot;totoroay&quot;)
   public String name;
}
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p><strong>XML与注解比较</strong></p>
<ul>
<li>XML可以适用任何场景 ，结构清晰，维护方便</li>
<li>注解不是自己提供的类使用不了，开发简单方便</li>
</ul>
<p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p>
<ul>
<li>xml管理Bean</li>
<li>注解完成属性注入</li>
<li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li>
</ul>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;  
</code></pre>
<p>作用：</p>
<ul>
<li>
<p>进行注解驱动注册，从而使注解生效</p>
</li>
<li>
<p>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</p>
</li>
<li>
<p>如果不扫描包，就需要手动配置bean</p>
</li>
<li>
<p>如果不加注解驱动，则注入的值为null！</p>
</li>
</ul>
<blockquote>
<p>基于Java类进行配置</p>
</blockquote>
<p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p>
<p>测试：</p>
<p>1、编写一个实体类，Dog</p>
<pre><code class="language-java">@Component  //将这个类标注为Spring的一个组件，放到容器中！
public class Dog {
   public String name = &quot;dog&quot;;
}
</code></pre>
<p>2、新建一个config配置包，编写一个MyConfig配置类</p>
<pre><code class="language-java">@Configuration  //代表这是一个配置类
public class MyConfig {

   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！
   public Dog dog(){
       return new Dog();
  }

}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void test2(){
   ApplicationContext applicationContext =
           new AnnotationConfigApplicationContext(MyConfig.class);
   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);
   System.out.println(dog.name);
}
</code></pre>
<p>4、成功输出结果！</p>
<p><strong>导入其他配置如何做呢？</strong></p>
<p>1、我们再编写一个配置类！</p>
<pre><code class="language-java">@Configuration  //代表这是一个配置类
public class MyConfig2 {
}
</code></pre>
<p>2、在之前的配置类中我们来选择导入这个配置类</p>
<pre><code class="language-ja">@Configuration
@Import(MyConfig2.class)  //导入合并其他配置类，类似于配置文件中的 inculde 标签
public class MyConfig {

   @Bean
   public Dog dog(){
       return new Dog();
  }

}
</code></pre>
<p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot06：Web开发静态资源处理]]></title>
        <id>https://totoroay.github.io/post/springboot06web-kai-fa-jing-tai-zi-yuan-chu-li/</id>
        <link href="https://totoroay.github.io/post/springboot06web-kai-fa-jing-tai-zi-yuan-chu-li/">
        </link>
        <updated>2020-05-08T05:39:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自动装配">自动装配</h2>
<p>springboot 到底帮我们配置了什么？我们能不能进行修改？能修改哪些东西？能不能扩展</p>
<ul>
<li>xxxAutoConfiguration	向容器中自动配置组件</li>
<li>xxxProperties	自动配置类 ，装配配置文件中自定义的一些内容</li>
</ul>
<p>要解决的问题：</p>
<ul>
<li>导入静态资源......</li>
<li>首页</li>
<li>jsp，模板引擎  Thymeleaf</li>
<li>装配扩展SpringMVC</li>
<li>增删改查</li>
<li>拦截器</li>
<li>国际化</li>
</ul>
<h2 id="web开发静态资源处理">Web开发静态资源处理</h2>
<h3 id="静态资源映射规则">静态资源映射规则</h3>
<p><strong>首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！</strong></p>
<p>写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？</p>
<p>如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！</p>
<p><strong>我们先来聊聊这个静态资源映射规则：</strong></p>
<p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</p>
<p>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</p>
<p>有一个方法：addResourceHandlers 添加资源处理</p>
<pre><code class="language-java">@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    if (!this.resourceProperties.isAddMappings()) {
        // 已禁用默认资源处理
        logger.debug(&quot;Default resource handling disabled&quot;);
        return;
    }
    // 缓存控制
    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
    // webjars 配置
    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)
                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)
                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
    // 静态资源配置
    String staticPathPattern = this.mvcProperties.getStaticPathPattern();
    if (!registry.hasMappingForPattern(staticPathPattern)) {
        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))
                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
}
</code></pre>
<p>读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源；</p>
<h3 id="什么是webjars-呢">什么是webjars 呢？</h3>
<p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p>
<p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p>
<p>网站：https://www.webjars.org</p>
<p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;3.5.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>导入完毕，查看webjars目录结构，并访问Jquery.js文件！</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588916489459.png" alt="" loading="lazy"></figure>
<p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：http://localhost:8080/webjars/jquery/3.5.1/jquery.js</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588916482138.png" alt="" loading="lazy"></figure>
<h3 id="第二种静态资源映射规则">第二种静态资源映射规则</h3>
<p>那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p>
<p>我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：</p>
<pre><code class="language-java">// 进入方法
public String[] getStaticLocations() {
    return this.staticLocations;
}
// 找到对应的值
private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
// 找到路径
private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { 
    &quot;classpath:/META-INF/resources/&quot;,
  &quot;classpath:/resources/&quot;, 
    &quot;classpath:/static/&quot;, 
    &quot;classpath:/public/&quot; 
};
</code></pre>
<p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p>
<p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p>
<pre><code>&quot;classpath:/METAINF/resources/&quot;
&quot;classpath:/resources/&quot;
&quot;classpath:/static/&quot;
&quot;classpath:/public/&quot;
</code></pre>
<p><mark>resources &gt; static(默认)  &gt; public</mark></p>
<p>我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p>
<p>比如我们访问 http://localhost:8080/1.js , 他就会去这些文件夹中寻找对应的静态资源文件；</p>
<h3 id="自定义静态资源路径">自定义静态资源路径</h3>
<p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p>
<pre><code class="language-properties">spring.resources.static-locations=classpath:/coding/,classpath:/totoroay/
</code></pre>
<p>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！</p>
<h2 id="首页处理">首页处理</h2>
<p>静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！</p>
<pre><code class="language-java">@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
                                                           FormattingConversionService mvcConversionService,
                                                           ResourceUrlProvider mvcResourceUrlProvider) {
    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页
        this.mvcProperties.getStaticPathPattern());
    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
    return welcomePageHandlerMapping;
}
</code></pre>
<p>点进去继续看</p>
<pre><code class="language-java">private Optional&lt;Resource&gt; getWelcomePage() {
    String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());
    // ::是java8 中新引入的运算符
    // Class::function的时候function是属于Class的，应该是静态方法。
    // this::function的funtion是属于这个对象的。
    // 简而言之，就是一种语法糖而已，是一种简写
    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();
}
// 欢迎页就是一个location下的的 index.html 而已
private Resource getIndexHtml(String location) {
    return this.resourceLoader.getResource(location + &quot;index.html&quot;);
}
</code></pre>
<p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。</p>
<p>比如我访问  http://localhost:8080/ ，就会找静态资源文件夹下的 index.html</p>
<p>在static目录下新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试  http://localhost:8080/  看结果！</p>
<p><mark><strong>关于网站图标说明</strong>：</mark></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588916438545.png" alt="" loading="lazy"></figure>
<p>将图标改名为favicon.ico放在public目录下即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot05：自动配置原理]]></title>
        <id>https://totoroay.github.io/post/springboot05zi-dong-pei-zhi-yuan-li/</id>
        <link href="https://totoroay.github.io/post/springboot05zi-dong-pei-zhi-yuan-li/">
        </link>
        <updated>2020-05-07T11:43:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springboot05自动配置原理">SpringBoot05：自动配置原理</h1>
<h2 id="自动配置原理">自动配置原理</h2>
<p>配置文件到底能写什么？怎么写？</p>
<p>SpringBoot官方文档中有大量的配置，我们无法全部记住</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588852012088.jpg" alt="" loading="lazy"></figure>
<blockquote>
<p>分析自动配置原理</p>
</blockquote>
<p>我们以**HttpEncodingAutoConfiguration（Http编码自动配置）**为例解释自动配置原理;</p>
<pre><code class="language-java">//表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件；
@Configuration 

//启动指定类的ConfigurationProperties功能；
  //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；
  //并把HttpProperties加入到ioc容器中
@EnableConfigurationProperties({HttpProperties.class}) 

//Spring底层@Conditional注解
  //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；
  //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效
@ConditionalOnWebApplication(
    type = Type.SERVLET
)

//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
@ConditionalOnClass({CharacterEncodingFilter.class})

//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；
  //如果不存在，判断也是成立的
  //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
@ConditionalOnProperty(
    prefix = &quot;spring.http.encoding&quot;,
    value = {&quot;enabled&quot;},
    matchIfMissing = true
)

public class HttpEncodingAutoConfiguration {
    //他已经和SpringBoot的配置文件映射了
    private final Encoding properties;
    //只有一个有参构造器的情况下，参数的值就会从容器中拿
    public HttpEncodingAutoConfiguration(HttpProperties properties) {
        this.properties = properties.getEncoding();
    }
    
    //给容器中添加一个组件，这个组件的某些值需要从properties中获取
    @Bean
    @ConditionalOnMissingBean //判断容器没有这个组件？
    public CharacterEncodingFilter characterEncodingFilter() {
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));
        return filter;
    }
    //。。。。。。。
}
</code></pre>
<p><strong>一句话总结 ：根据当前不同的条件判断，决定这个配置类是否生效！</strong></p>
<ul>
<li>一但这个配置类生效；这个配置类就会给容器中添加各种组件；</li>
<li>这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</li>
<li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；</li>
<li>配置文件能配置什么就可以参照某个功能对应的这个属性类</li>
</ul>
<pre><code class="language-java">//从配置文件中获取指定的值和bean的属性进行绑定
@ConfigurationProperties(prefix = &quot;spring.http&quot;) 
public class HttpProperties {
    // .....
}
</code></pre>
<p>我们去配置文件里面试试前缀，看提示！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588852045330.png" alt="" loading="lazy"></figure>
<p><strong>这就是自动装配的原理！</strong></p>
<blockquote>
<p>精髓</p>
</blockquote>
<p>1、SpringBoot启动会加载大量的自动配置类</p>
<p>2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；</p>
<p>3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）</p>
<p>4、给容器中自动配置类添加组件的时候，会从xxxproperties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；</p>
<p>**xxxxAutoConfigurartion：自动配置类；**给容器中添加组件</p>
<p><strong>xxxxProperties:封装配置文件中相关属性；</strong></p>
<blockquote>
<p>了解：@Conditional</p>
</blockquote>
<p>了解完自动装配的原理后，我们来关注一个细节问题，<strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588851996746.jpg" alt="" loading="lazy"></figure>
<p><strong>那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载了这么多的配置类，但不是所有的都生效了。</strong></p>
<p>我们怎么知道哪些自动配置类生效？</p>
<p><strong>我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</strong></p>
<pre><code class="language-yaml">#开启springboot的调试类
debug=true
</code></pre>
<p><strong>Positive matches:（自动配置类启用的：正匹配）</strong></p>
<p><strong>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</strong></p>
<p><strong>Unconditional classes: （没有条件的类）</strong></p>
<p>【演示：查看输出的日志】</p>
<p>掌握吸收理解原理，即可以不变应万变！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot04：JSR303数据校验及多环境切换]]></title>
        <id>https://totoroay.github.io/post/springboot04jsr303-shu-ju-xiao-yan-ji-duo-huan-jing-qie-huan/</id>
        <link href="https://totoroay.github.io/post/springboot04jsr303-shu-ju-xiao-yan-ji-duo-huan-jing-qie-huan/">
        </link>
        <updated>2020-05-07T05:46:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="jsr303数据校验">JSR303数据校验</h2>
<p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；</p>
<pre><code class="language-java">@Component // 注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated  // 数据校验
public class Person {

    @Email(message=&quot;邮箱格式错误&quot;) // name必须是邮箱格式
    private String name;
    // 后面自行补全
}
</code></pre>
<p>运行结果 ：default message [不是一个合法的电子邮件地址];</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588830441091.png" alt="" loading="lazy"></figure>
<p><strong>使用数据校验，可以保证数据的正确性；</strong></p>
<blockquote>
<p>常见参数</p>
</blockquote>
<pre><code class="language-yaml">@NotNull(message=&quot;名字不能为空&quot;)
private String userName;
@Max(value=120,message=&quot;年龄最大不能查过120&quot;)
private int age;
@Email(message=&quot;邮箱格式错误&quot;)
private String email;

空检查
@Null       验证对象是否为null
@NotNull    验证对象是否不为null, 无法查检长度为0的字符串
@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.
@NotEmpty   检查约束元素是否为NULL或者是EMPTY.
    
Booelan检查
@AssertTrue     验证 Boolean 对象是否为 true  
@AssertFalse    验证 Boolean 对象是否为 false  
    
长度检查
@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  
@Length(min=, max=) string is between min and max included.

日期检查
@Past       验证 Date 和 Calendar 对象是否在当前时间之前  
@Future     验证 Date 和 Calendar 对象是否在当前时间之后  
@Pattern    验证 String 对象是否符合正则表达式的规则
    
.......等等
除此以外，我们还可以自定义一些数据校验规则
</code></pre>
<h2 id="多环境切换">多环境切换</h2>
<p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；</p>
<blockquote>
<p>多配置文件</p>
</blockquote>
<p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；</p>
<p><strong>例如：</strong></p>
<p>application-test.properties 代表测试环境配置</p>
<p>application-dev.properties 代表开发环境配置</p>
<p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>；</p>
<p>我们需要通过一个配置来选择需要激活的环境：</p>
<pre><code>#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；
#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；
spring.profiles.active=dev
</code></pre>
<blockquote>
<p>yaml的多文档块</p>
</blockquote>
<p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p>
<pre><code class="language-yaml">server:
  port: 8081
#选择要激活那个环境块
spring:
  profiles:
    active: dev

---
server:
  port: 8083
spring:
  profiles: dev #配置环境的名称


---

server:
  port: 8084
spring:
  profiles: test #配置环境的名称
</code></pre>
<p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p>
<blockquote>
<p>配置文件加载位置</p>
</blockquote>
<p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p>
<p>官方外部配置文件说明参考文档</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588830456817.png" alt="" loading="lazy"></figure>
<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p>
<pre><code>优先级1：项目路径下的config文件夹配置文件
优先级2：项目路径下配置文件
优先级3：资源路径下的config文件夹配置文件
优先级4：资源路径下配置文件
</code></pre>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p>
<p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p>
<pre><code class="language-yaml">#配置项目的访问路径
server.servlet.context-path=/totoroay
</code></pre>
<blockquote>
<p>拓展，运维小技巧</p>
</blockquote>
<p>指定位置加载配置文件</p>
<p>我们还可以通过spring.config.location来改变默认的配置文件位置</p>
<p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p>
<pre><code>java -jar spring-boot-config.jar --spring.config.location=F:/application.properties
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[桥接模式]]></title>
        <id>https://totoroay.github.io/post/qiao-jie-mo-shi/</id>
        <link href="https://totoroay.github.io/post/qiao-jie-mo-shi/">
        </link>
        <updated>2020-05-06T12:15:57.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://totoroay.github.io//post-images/1588767488196.png" alt="" loading="lazy"><br>
<strong><mark>实例分析</mark></strong></p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588767482381.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">package totoroay.bridge;
// 品牌
public interface Brand {
    void info();
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 苹果品牌
public class Apple implements Brand {
    @Override
    public void info() {
        System.out.print(&quot;苹果&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 联想品牌
public class Lenovo implements Brand {
    @Override
    public void info() {
        System.out.print(&quot;联想&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 抽象的电脑类型类
public abstract class Computer {
    // 组合品牌
    protected Brand brand;

    public Computer(Brand brand) {
        this.brand = brand;
    }

    public void info(){
        brand.info();
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 笔记本电脑
public class Notebook extends Computer {
    public Notebook(Brand brand) {
        super(brand);
    }

    public void info(){
        brand.info();
        System.out.print(&quot;笔记本&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.bridge;
// 台式机
public class Desktop extends Computer {
    public Desktop(Brand brand) {
        super(brand);
    }

    public void info(){
        brand.info();
        System.out.print(&quot;台式机&quot;);
    }
}

</code></pre>
<pre><code class="language-java">package totoroay.bridge;

public class test {
    public static void main(String[] args) {
        // 苹果笔记本
        Notebook notebook = new Notebook(new Apple());
        notebook.info();
        System.out.println(&quot;\n&quot;);
        // 联想台式机
        Desktop desktop = new Desktop(new Lenovo());
        desktop.info();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588767473029.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588767468462.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588767463245.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适配器模式]]></title>
        <id>https://totoroay.github.io/post/gua-pei-qi-mo-shi/</id>
        <link href="https://totoroay.github.io/post/gua-pei-qi-mo-shi/">
        </link>
        <updated>2020-05-06T09:37:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="适配器模式">适配器模式</h1>
<p><strong>结构型模式</strong></p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588757927882.png" alt="" loading="lazy"></figure>
<p><mark><strong>适配器模式</strong></mark></p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588757921508.png" alt="" loading="lazy"></figure>
<p>主要角色：</p>
<ul>
<li>目标接口</li>
<li>适配器类</li>
<li>适配者类</li>
</ul>
<h2 id="继承实现">继承实现</h2>
<pre><code class="language-java">package totoroay.adapter;
// 被适配的类：网线
public class Adapted {
    public void request(){
        System.out.println(&quot;连接网线上网&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 客户端：电脑，想上网
public class Computer {
    public void net(){
        // 上网的具体实现，找一个转接器
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 接口：转换器的抽象实现
public interface NetToUsb {
    // 处理请求，把网线插到转接器上
    void handleRequest();
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 适配器类：转换器的具体实现
// 类适配器：继承实现（不推荐使用）
public class Adapter extends Adapted implements NetToUsb{
    @Override
    public void handleRequest() {
        super.request();// 可以上网了
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.adapter;
// 客户端：电脑，想上网
public class Computer {
    // 电脑需要连接转接器
    public void net(NetToUsb adapter){
        // 上网的具体实现，找一个转接器
        adapter.handleRequest();
    }

    public static void main(String[] args) {
        Computer computer = new Computer();
        Adapted adapted = new Adapted();
        Adapter adapter = new Adapter();
        computer.net(adapter);
    }
}
</code></pre>
<h2 id="组合实现推荐使用">组合实现（推荐使用）</h2>
<pre><code class="language-java">package totoroay.adapter;
// 适配器类：转换器的具体实现
// 对象适配器：组合实现（推荐使用）
public class AdapterPlus implements NetToUsb{
    private Adapted adapted;

    public AdapterPlus(Adapted adapted){
        this.adapted = adapted;
    }
    @Override
    public void handleRequest() {
        adapted.request();
    }
}
</code></pre>
<pre><code class="language-java">public static void main(String[] args) {
        Computer computer = new Computer();
        Adapted adapted = new Adapted();
        Adapter adapter = new Adapter();
        computer.net(adapter);
		System.out.println(&quot;=================&quot;);
    
        AdapterPlus adapterPlus = new AdapterPlus(adapted);
        computer.net(adapterPlus);
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588757906285.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代理/静态代理-模式]]></title>
        <id>https://totoroay.github.io/post/dai-li-jing-tai-dai-li-mo-shi/</id>
        <link href="https://totoroay.github.io/post/dai-li-jing-tai-dai-li-mo-shi/">
        </link>
        <updated>2020-05-05T10:12:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="静态代理">静态代理</h2>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588685234201.png" alt="" loading="lazy"></figure>
<p>角色分析</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色，代理真实角色后，一般会做一些附属操作</li>
<li>客户：访问代理对象的人</li>
</ul>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 抽象角色
public interface Rent {
    void rent();
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 真实角色
public class Host implements Rent{
    public void rent() {
        System.out.println(&quot;房东要出租房子&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 代理角色
public class Proxy {
    private Host host;

    public Proxy() {}

    public Proxy(Host host) {
        this.host = host;
    }

    public void rent(){
        host.rent();
        seehouse();
    }

    public void seehouse(){
        System.out.println(&quot;看房&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo1;
// 客户
public class Client {
    public static void main(String[] args) {
        Host host = new Host();
        Proxy proxy = new Proxy(host);
        proxy.rent();
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588685225293.png" alt="" loading="lazy"></figure>
<p>代理模式的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹！不用去关注一些公共的业务</li>
<li>公共也就交给代理角色！实现了业务的分工</li>
<li>公共业务发生扩展的时候，方便集中管理！</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，代码量翻倍，开发效率会变低</li>
</ul>
<h2 id="加深理解">加深理解</h2>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588685218011.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 抽象角色
public interface UserService {
    void add();
    void delate();
    void update();
    void query();
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 真实角色
public class UserServiceImpl implements UserService{

    public void add() {
        System.out.println(&quot;增加用户&quot;);
    }

    public void delate() {
        System.out.println(&quot;删除用户&quot;);
    }

    public void update() {
        System.out.println(&quot;修改用户&quot;);
    }

    public void query() {
        System.out.println(&quot;查询用户&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 代理角色
public class UserServiceImplProxy {
    private UserServiceImpl userService;

    public UserServiceImpl getUserService() {
        return userService;
    }

    public void setUserService(UserServiceImpl userService) {
        this.userService = userService;
    }

    public void add(){
        userService.add();
        this.log(&quot;增加&quot;);
    }
    public void delate(){
        userService.delate();
    }
    public void update(){
        userService.update();
    }
    public void query(){
        userService.query();
    }

    public void log(String msg){
        System.out.println(&quot;[Debug] &quot;+msg+&quot;错误&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo2;
// 客户
public class Client {
    public static void main(String[] args) {
        UserServiceImpl userService = new UserServiceImpl();
        UserServiceImplProxy proxy = new UserServiceImplProxy();
        proxy.setUserService(userService);
        proxy.add();
        proxy.delate();
        proxy.update();
        proxy.query();
    }
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588685206797.png" alt="" loading="lazy"></figure>
<h2 id="动态代理">动态代理</h2>
<ul>
<li>动态代理和静态代理角色一样</li>
<li>动态代理的代理类是动态生成的，不是我们直接写好的！</li>
<li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理
<ul>
<li>基于接口---JDK 动态代理	【代码实现】</li>
<li>基于类：cglib</li>
<li>java字节码：javasist</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy：代理，InvocationHandler</p>
<pre><code class="language-java">package totoroay.proxy.demo3;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyInvocationHandler implements InvocationHandler {
    //被代理的接口
    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    // 生成，得到代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }

    // 处理代理实例并返回结果(实现代理类方法)
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object invoke = method.invoke(target,args);
        return invoke;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.proxy.demo3;

import totoroay.proxy.demo2.UserService;
import totoroay.proxy.demo2.UserServiceImpl;

public class Client {
    public static void main(String[] args) {
        //真实对象
        UserServiceImpl userService = new UserServiceImpl();
        // 代理角色
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        // 设置要代理的对象
        pih.setTarget(userService);
        // 动态生成代理类
        UserService proxy = (UserService) pih.getProxy();
        proxy.add();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[建造者模式]]></title>
        <id>https://totoroay.github.io/post/jian-zao-zhe-mo-shi/</id>
        <link href="https://totoroay.github.io/post/jian-zao-zhe-mo-shi/">
        </link>
        <updated>2020-05-05T09:50:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="建造者模式">建造者模式</h1>
<p><img src="https://totoroay.github.io//post-images/1588672365938.png" alt="" loading="lazy"><br>
<img src="https://totoroay.github.io//post-images/1588672372510.png" alt="" loading="lazy"></p>
<h6 id="demo1"><mark>demo1</mark></h6>
<pre><code class="language-java">package totoroay.builder.demo1;
// 抽象的建造者：方法
public abstract class Builder {
    abstract void buildA();// 地基
    abstract void buildB();// 钢筋工程
    abstract void buildC();// 铺电线
    abstract void buildD();// 粉刷

    // 完工：得到产品
    abstract Product getProduct();
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;
// 产品：房子
public class Product {
    private String buildA;// 地基
    private String buildB;// 钢筋工程
    private String buildC;// 铺电线
    private String buildD;// 粉刷
    
    //get,set,toString方法自己补全
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;
// 具体的建造者：工人
public class Worker extends Builder {
    private Product product;

    // 工人生产产品
    public Worker() {
        product = new Product();
    }

    @Override
    void buildA() {
        product.setBuildA(&quot;地基&quot;);
        System.out.println(&quot;地基&quot;);
    }

    @Override
    void buildB() {
        product.setBuildB(&quot;钢筋工程&quot;);
        System.out.println(&quot;钢筋工程&quot;);
    }

    @Override
    void buildC() {
        product.setBuildC(&quot;铺电线&quot;);
        System.out.println(&quot;铺电线&quot;);
    }

    @Override
    void buildD() {
        product.setBuildD(&quot;粉刷&quot;);
        System.out.println(&quot;粉刷&quot;);
    }

    @Override
    Product getProduct() {
        return product;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;
// 指挥：核心。负责指挥构建一个工程，有它决定
public class Director {
    // 指挥具体的工人建房子
    public Product builder(Builder builder){
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();
        return builder.getProduct();
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo1;

public class Test {
    public static void main(String[] args) {
        // 指挥
        Director director = new Director();
        // 指挥具体的工人完成产品
        Product builder = director.builder(new Worker());
        System.out.println(builder.toString());
    }
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588672354974.png" alt="" loading="lazy"></figure>
<h6 id="demo2"><mark>demo2</mark></h6>
<pre><code class="language-java">package totoroay.builder.demo2;
// 抽象的建造者：方法
public abstract class Builder {
    // 静态内部类方式
    abstract Builder buildA(String msg);// 汉堡
    abstract Builder buildB(String msg);// 可乐
    abstract Builder buildC(String msg);// 薯条
    abstract Builder buildD(String msg);// 甜品

    // 完工：得到产品
    abstract Product getProduct();
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo2;
// 产品：套餐
public class Product {
    private String buildA = &quot;汉堡&quot;;// 汉堡
    private String buildB = &quot;可乐&quot;;// 可乐
    private String buildC = &quot;薯条&quot;;// 薯条
    private String buildD = &quot;甜品&quot;;// 甜品
    
    //get,set,toString方法自己补全
}
</code></pre>
<pre><code class="language-java">package totoroay.builder.demo2;
// 具体的建造者
public class Worker extends Builder {
    private Product product;

    public Worker(){
        product = new Product();
    }

    @Override
    Builder buildA(String msg) {
        product.setBuildA(msg);
        return this;
    }

    @Override
    Builder buildB(String msg) {
        product.setBuildB(msg);
        return this;
    }

    @Override
    Builder buildC(String msg) {
        product.setBuildC(msg);
        return this;
    }

    @Override
    Builder buildD(String msg) {
        product.setBuildD(msg);
        return this;
    }

    @Override
    Product getProduct() {
        return product;
    }
}

</code></pre>
<pre><code class="language-java">package totoroay.builder.demo2;

public class Test {
    public static void main(String[] args) {
        // 服务员，默认套餐
        Worker worker = new Worker();
        Product product = worker.getProduct();
        System.out.println(product.toString());

        // 另一个服务员
        Worker worker1 = new Worker();
        // 链式编程
        Product product1 = worker1.buildA(&quot;牛肉汉堡&quot;).buildB(&quot;大杯可乐&quot;)
                .getProduct();
        System.out.println(product1.toString());
    }
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588672343175.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588672337519.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：依赖注入（DI）]]></title>
        <id>https://totoroay.github.io/post/springyi-lai-zhu-ru-di/</id>
        <link href="https://totoroay.github.io/post/springyi-lai-zhu-ru-di/">
        </link>
        <updated>2020-05-05T04:10:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="dependency-injection">Dependency Injection</h2>
<blockquote>
<p>概念</p>
</blockquote>
<ul>
<li>依赖注入（Dependency Injection,DI）。</li>
<li>依赖 : 指Bean对象的创建依赖于容器 . Bean对象的依赖资源 .</li>
<li>注入 : 指Bean对象所依赖的资源 , 由容器来设置和装配</li>
</ul>
<blockquote>
<p>构造器注入</p>
</blockquote>
<p>我们在之前的案例已经讲过了</p>
<blockquote>
<p>Set 注入 （重点）</p>
</blockquote>
<p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is .</p>
<p>测试pojo类 :</p>
<p>Address.java</p>
<pre><code class="language-java">package com.totoroay.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Address {
    private String address;
}

</code></pre>
<p>Student.java</p>
<pre><code class="language-java">package com.totoroay.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.*;
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbies;
    private Map&lt;String,String&gt; card;
    private Set&lt;String&gt; games;
    private String wife;
    private Properties info;
}
</code></pre>
<p>beans.xml：<mark><strong>各种注入方式</strong></mark></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--pojo，bean注入，注意点：这里的值是一个引用，ref--&gt;
    &lt;bean id=&quot;address&quot; class=&quot;com.totoroay.pojo.Address&quot;&gt;
        &lt;property name=&quot;address&quot; value=&quot;武汉&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;student&quot; class=&quot;com.totoroay.pojo.Student&quot;&gt;
        &lt;!--string，常量注入--&gt;
        &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
        &lt;!--pojo，bean注入，注意点：这里的值是一个引用，ref--&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
        &lt;!--array，数组注入--&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;java&lt;/value&gt;
                &lt;value&gt;paython&lt;/value&gt;
                &lt;value&gt;php&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--list，List注入--&gt;
        &lt;property name=&quot;hobbies&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;打游戏&lt;/value&gt;
                &lt;value&gt;打篮球&lt;/value&gt;
                &lt;value&gt;编程&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--map，Map注入--&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;14381983491084&quot;/&gt;
                &lt;entry key=&quot;银行卡&quot; value=&quot;1231238798798798&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--set--&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;lol&lt;/value&gt;
                &lt;value&gt;coc&lt;/value&gt;
                &lt;value&gt;coc&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;!--null，Null注入--&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;
        &lt;!--Properties注入--&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;学号&quot;&gt;20178213718&lt;/prop&gt;
                &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试结果：</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588651878727.png" alt="" loading="lazy"></figure>
<blockquote>
<p>Bean的作用域</p>
</blockquote>
<p>在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 .</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588651855715.png" alt="" loading="lazy"></figure>
<p>几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境。</p>
<h4 id="singleton">Singleton</h4>
<p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，<mark>默认</mark>，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean定义成singleton，可以这样配置：</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; scope=&quot;singleton&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;33&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@Test
public void test03(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userbeans.xml&quot;);
    User user = context.getBean(&quot;user&quot;, User.class);
    User user2 = context.getBean(&quot;user&quot;, User.class);
    System.out.println(user==user2);
}
</code></pre>
<h4 id="prototype">Prototype</h4>
<p>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; scope=&quot;prototype&quot;/&gt;
</code></pre>
<h4 id="request">Request</h4>
<p>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt;
</code></pre>
<p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p>
<h4 id="session">Session</h4>
<p>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p>
<pre><code class="language-xml"> &lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;
</code></pre>
<p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot03：yaml配置注入]]></title>
        <id>https://totoroay.github.io/post/springboot03yaml-pei-zhi-zhu-ru/</id>
        <link href="https://totoroay.github.io/post/springboot03yaml-pei-zhi-zhu-ru/">
        </link>
        <updated>2020-05-04T12:12:40.000Z</updated>
        <content type="html"><![CDATA[<h3 id="配置文件">配置文件</h3>
<p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p>
<ul>
<li>
<p>application.properties</p>
</li>
<li>
<ul>
<li>语法结构 ：key=value</li>
</ul>
</li>
<li>
<p>application.yml</p>
</li>
<li>
<ul>
<li>语法结构 ：key：空格 value</li>
</ul>
</li>
</ul>
<p>**配置文件的作用 ：**修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p>
<p>比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！</p>
<pre><code class="language-properties">server.port=8081
</code></pre>
<h3 id="yaml概述">yaml概述</h3>
<p>YAML是 &quot;YAML Ain't a Markup Language&quot; （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）</p>
<p><strong>这种语言以数据<strong><strong>作</strong></strong>为中心，而不是以标记语言为重点！</strong></p>
<p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p>
<p>传统xml配置：</p>
<pre><code class="language-xml">&lt;server&gt;    
    &lt;port&gt;8081&lt;port&gt;
&lt;/server&gt;
</code></pre>
<p>yaml配置：</p>
<pre><code class="language-yaml">server：  prot: 8080
</code></pre>
<h3 id="yaml基础语法">yaml基础语法</h3>
<p>说明：语法要求严格！</p>
<p>1、空格不能省略</p>
<p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p>
<p>3、属性和值的大小写都是十分敏感的。</p>
<p><strong>字面量：普通的值  [ 数字，布尔值，字符串  ]</strong></p>
<p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p>
<pre><code class="language-yaml">k: v
</code></pre>
<p>注意：</p>
<ul>
<li>
<p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p>
<p>比如 ：name: &quot;totoroay\n ayoung&quot;  输出 ：totoroay 换行  ayoung</p>
</li>
<li>
<p>'' 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p>
<p>比如 ：name: ‘totoroay\n ayoung’  输出 ：totoroay  \n  ayoung</p>
</li>
</ul>
<p><strong>对象、Map（键值对）</strong></p>
<pre><code class="language-yaml">#对象、Map格式k:     v1:    v2:
</code></pre>
<p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p>
<pre><code class="language-yaml">student:
	name: totoroay    age: 99
</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">student: {name: totoroay,age: 99}
</code></pre>
<p><strong>数组（ List、set ）</strong></p>
<p>用 - 值表示数组中的一个元素,比如：</p>
<pre><code class="language-yaml">pets:
 - cat
 - dog
 - pig
</code></pre>
<p>行内写法</p>
<pre><code class="language-yaml">pets: [cat,dog,pig]
</code></pre>
<p><strong>修改SpringBoot的默认端口号</strong></p>
<p>配置文件中添加，端口号的参数，就可以切换端口；</p>
<pre><code class="language-yaml">server:  
  port: 8081
</code></pre>
<h3 id="yaml注入配置文件">yaml注入配置文件</h3>
<p>yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！</p>
<blockquote>
<p>yaml注入配置文件</p>
</blockquote>
<p>1、在springboot项目中的resources目录下新建一个文件 application.yml</p>
<p>2、编写一个实体类 Dog；</p>
<pre><code class="language-java">package com.totoroay.pojo;

@Component  //注册bean到容器中
public class Dog {
    private String name;
    private Integer age;
    
    //有参无参构造、get、set方法、toString()方法  
}
</code></pre>
<p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p>
<pre><code class="language-java">@Component //注册bean
public class Dog {
    @Value(&quot;阿黄&quot;)
    private String name;
    @Value(&quot;9&quot;)
    private Integer age;
}
</code></pre>
<p>4、在SpringBoot的测试类下注入狗狗输出一下；</p>
<pre><code class="language-java">@SpringBootTest
class Springboot02ConofigApplicationTests {

    @Autowired //将狗狗自动注入进来
    Dog dog;

    @Test
    void contextLoads() {
        System.out.println(dog); //打印看下狗狗对象
    }

}
</code></pre>
<p>结果成功输出，@Value注入成功，这是我们原来的办法对吧。</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588594490094.png" alt="" loading="lazy"></figure>
<p>5、我们在编写一个复杂一点的实体类：Person 类</p>
<pre><code class="language-java">@Component //注册bean到容器中
public class Person {
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
    
    //有参无参构造、get、set方法、toString()方法  
}
</code></pre>
<p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p>
<pre><code class="language-yaml">person:
  name: totoroay
  age: 19
  happy: false
  birth: 1999/09/09
  maps: {k1: v1,k2: v2}
  lists:
    - code
    - girl
    - music
    - game
  dog:
    name: 阿花
    age: 9
</code></pre>
<p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p>
<pre><code class="language-java">/*
@ConfigurationProperties作用：
将配置文件中配置的每一个属性的值，映射到这个组件中；
告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定
参数 prefix = “person” : 将配置文件中的person下面的所有属性一一对应
*/
@Component //注册bean
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;
}
</code></pre>
<p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588594502287.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588594507982.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
  &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<p>9、确认以上配置都OK之后，我们去测试类中测试一下：</p>
<pre><code class="language-java">@SpringBootTest
class DemoApplicationTests {

    @Autowired
    Person person; //将person自动注入进来

    @Test
    public void contextLoads() {
        System.out.println(person); //打印person信息
    }

}
</code></pre>
<p>结果：所有值全部注入成功！</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588594519838.png" alt="" loading="lazy"></figure>
<p><strong>yaml配置注入到实体类完全OK！</strong></p>
<p>课堂测试：</p>
<p>1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败</p>
<p>2、在配置一个person2，然后将 @ConfigurationProperties(prefix = &quot;person2&quot;) 指向我们的person2；</p>
<h3 id="加载指定的配置文件">加载指定的配置文件</h3>
<p>**@PropertySource ：**加载指定的配置文件；</p>
<p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p>
<p>1、我们去在resources目录下新建一个<strong>person.properties</strong>文件</p>
<pre><code class="language-properties">name=zy
</code></pre>
<p>2、然后在我们的代码中指定加载person.properties文件</p>
<pre><code class="language-java">@PropertySource(value = &quot;classpath:person.properties&quot;)
@Component //注册bean
public class Person {

    @Value(&quot;${name}&quot;)
    private String name;

    ......  
}
</code></pre>
<p>3、再次输出测试一下：指定配置文件绑定成功！</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1588594529477.png" alt="" loading="lazy"></figure>
<h3 id="配置文件占位符">配置文件占位符</h3>
<p>配置文件还可以编写占位符生成随机数</p>
<pre><code class="language-yaml">person:
    name: totoroay${random.uuid} # 随机uuid
    age: ${random.int}  # 随机int
    happy: false
    birth: 1999/09/09
    maps: {k1: v1,k2: v2}
    lists:
      - code
      - girl
      - music
      - game
    dog:
      name: ${person.hello:other}_旺财
      age: 1
</code></pre>
<h3 id="回顾properties配置">回顾properties配置</h3>
<p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！</p>
<p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p>
<p>settings--&gt;FileEncodings 中配置；</p>
<p><img src="https://totoroay.github.io//post-images/1588594536690.png" alt="" loading="lazy"><br>
<strong>测试步骤：</strong></p>
<p>1、新建一个实体类User</p>
<pre><code class="language-java">@Component //注册bean
public class User {
    private String name;
    private int age;
    private String sex;
}
</code></pre>
<p>2、编辑配置文件 user.properties</p>
<pre><code class="language-properties">user1.name=kuangshenuser1.age=18user1.sex=男
</code></pre>
<p>3、我们在User类上使用@Value来进行注入！</p>
<pre><code class="language-java">@Component //注册bean
@PropertySource(value = &quot;classpath:user.properties&quot;)
public class User {
    //直接使用@value
    @Value(&quot;${user.name}&quot;) //从配置文件中取值
    private String name;
    @Value(&quot;#{9*2}&quot;)  // #{SPEL} Spring表达式
    private int age;
    @Value(&quot;男&quot;)  // 字面量
    private String sex;
}
</code></pre>
<p>4、Springboot测试</p>
<pre><code class="language-java">@SpringBootTest
class DemoApplicationTests {

    @Autowired
    User user;

    @Test
    public void contextLoads() {
        System.out.println(user);
    }

}
</code></pre>
<p>结果正常输出：</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1588594546320.png" alt="" loading="lazy"></figure>
<h3 id="对比小结">对比小结</h3>
<p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1588594553170.png" alt="" loading="lazy"></figure>
<p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p>
<p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p>
<p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p>
<p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p>
<p><strong>结论：</strong></p>
<p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p>
<p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p>
<p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！</p>
]]></content>
    </entry>
</feed>