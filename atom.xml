<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://totoroay.github.io/</id>
    <title>totoroay</title>
    <updated>2020-05-13T11:06:29.847Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://totoroay.github.io/"/>
    <link rel="self" href="https://totoroay.github.io/atom.xml"/>
    <subtitle>每天学习5小时！！！</subtitle>
    <logo>https://totoroay.github.io/images/avatar.png</logo>
    <icon>https://totoroay.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, totoroay</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot09：页面国际化]]></title>
        <id>https://totoroay.github.io/post/springboot09ye-mian-guo-ji-hua/</id>
        <link href="https://totoroay.github.io/post/springboot09ye-mian-guo-ji-hua/">
        </link>
        <updated>2020-05-13T11:02:37.000Z</updated>
        <content type="html"><![CDATA[<p>有的时候，我们的网站会去涉及中英文甚至多语言的切换，这时候我们就需要学习国际化了！</p>
<h2 id="准备工作">准备工作</h2>
<p>先在IDEA中统一设置properties的编码问题！</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589367893729.png" alt="" loading="lazy"></figure>
<p>编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！</p>
<h2 id="配置文件编写">配置文件编写</h2>
<p>1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件</p>
<p>2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹自动合并了！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589367886727.png" alt="" loading="lazy"></figure>
<p>3、我们可以在这上面去新建一个文件；</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589367880956.png" alt="" loading="lazy"></figure>
<p>弹出如下页面：我们再添加一个英文的；</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589367876189.png" alt="" loading="lazy"></figure>
<p><strong>4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图；</strong></p>
<p>这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589367871076.png" alt="" loading="lazy"></figure>
<p>然后去查看我们的配置文件；</p>
<p>login.properties ：默认</p>
<pre><code class="language-properties">login.btn=登录
login.password=密码
login.remember=记住我
login.tip=请登录
login.username=用户名
</code></pre>
<p>英文：</p>
<pre><code class="language-properties">login.btn=sign in
login.password=password
login.remember=remember me
login.tip=Please sign in
login.username=username
</code></pre>
<p>中文：</p>
<pre><code class="language-properties">login.btn=登录
login.password=密码
login.remember=记住我
login.tip=请登录
login.username=用户名
</code></pre>
<p>OK，配置文件步骤搞定！</p>
<h2 id="配置文件生效探究">配置文件生效探究</h2>
<p>我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration</p>
<p>里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource；</p>
<pre><code class="language-java">@Bean
@ConfigurationProperties(prefix = &quot;spring.messages&quot;)
public MessageSourceProperties messageSourceProperties() {
	return new MessageSourceProperties();
}


// 获取 properties 传递过来的值进行判断
@Bean
public MessageSource messageSource(MessageSourceProperties properties) {
    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
    if (StringUtils.hasText(properties.getBasename())) {
        // 设置国际化文件的基础名（去掉语言国家代码的）
        messageSource.setBasenames(
            StringUtils.commaDelimitedListToStringArray(
                                       StringUtils.trimAllWhitespace(properties.getBasename())));
    }
    if (properties.getEncoding() != null) {
        messageSource.setDefaultEncoding(properties.getEncoding().name());
    }
    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
    Duration cacheDuration = properties.getCacheDuration();
    if (cacheDuration != null) {
        messageSource.setCacheMillis(cacheDuration.toMillis());
    }
    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
    return messageSource;
}
</code></pre>
<p>我们真实 的情况是放在了i18n目录下，所以我们要去配置这个messages的路径；</p>
<pre><code class="language-properties">spring.messages.basename=i18n/login
</code></pre>
<h2 id="配置页面国际化值">配置页面国际化值</h2>
<p>去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{...}。我们去页面测试下：</p>
<p>IDEA还有提示，非常智能的</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1589367857228.png" alt="" loading="lazy"></figure>
<p>我们可以去启动项目，访问一下，发现已经自动识别为中文的了！</p>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1589367851133.png" alt="" loading="lazy"></figure>
<p><strong>但是我们想要更好！可以根据按钮自动切换中文英文！</strong></p>
<h2 id="配置国际化解析">配置国际化解析</h2>
<p>在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！</p>
<p>我们去我们WebMvcAutoConfiguration自动配置文件，寻找一下！看到SpringBoot默认配置：</p>
<pre><code class="language-java">@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)
public LocaleResolver localeResolver() {
    // 容器中没有就自己配，有的话就用用户配置的
    if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {
        return new FixedLocaleResolver(this.mvcProperties.getLocale());
    }
    // 接收头国际化分解
    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
    return localeResolver;
}
</code></pre>
<p>AcceptHeaderLocaleResolver 这个类中有一个方法</p>
<pre><code class="language-java">public Locale resolveLocale(HttpServletRequest request) {
    Locale defaultLocale = this.getDefaultLocale();
    // 默认的就是根据请求头带来的区域信息获取Locale进行国际化
    if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) {
        return defaultLocale;
    } else {
        Locale requestLocale = request.getLocale();
        List&lt;Locale&gt; supportedLocales = this.getSupportedLocales();
        if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) {
            Locale supportedLocale = this.findSupportedLocale(request, supportedLocales);
            if (supportedLocale != null) {
                return supportedLocale;
            } else {
                return defaultLocale != null ? defaultLocale : requestLocale;
            }
        } else {
            return requestLocale;
        }
    }
}
</code></pre>
<p>那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！</p>
<p>我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！</p>
<p>修改一下前端页面的跳转连接：</p>
<pre><code class="language-html">&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;
&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html(language='zh_CN')}&quot;&gt;中文&lt;/a&gt;
&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html(language='en_US')}&quot;&gt;English&lt;/a&gt;
</code></pre>
<p>我们去写一个处理的组件类！</p>
<pre><code class="language-java">package com.totoroay.config;

import org.springframework.util.StringUtils;
import org.springframework.web.servlet.LocaleResolver;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Locale;

public class MyLocaleResolver implements LocaleResolver {
    // 解析请求
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        // 获取请求中的语言参数
        String language = request.getParameter(&quot;language&quot;);
        // 默认
        Locale locale = Locale.getDefault();
        // 如果请求中的链接携带了国际化的参数
        if (!StringUtils.isEmpty(language)) {
            // zh_CN
            String[] split = language.split(&quot;_&quot;);
            // 国家，地区
            locale = new Locale(split[0], split[1]);
        }
        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {

    }
}
</code></pre>
<p>为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MyMvcConfig下添加bean；</p>
<pre><code class="language-java">// 自定义国际化组件
@Bean
public LocaleResolver localeResolver(){
    return new MyLocaleResolver();
}
</code></pre>
<p><strong>我们重启项目，来访问一下，发现点击按钮可以实现成功切换！搞定收工！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[外观模式]]></title>
        <id>https://totoroay.github.io/post/wai-guan-mo-shi/</id>
        <link href="https://totoroay.github.io/post/wai-guan-mo-shi/">
        </link>
        <updated>2020-05-12T06:59:11.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589266822489.png" alt="" loading="lazy"></figure>
<p><strong>模式结构：主要角色</strong></p>
<ul>
<li>外观角色
<ul>
<li>为多个子系统对外提供一个共同的接口</li>
</ul>
</li>
<li>子系统角色
<ul>
<li>实现系统的部分功能，客户可以通过外观角色访问他</li>
</ul>
</li>
<li>客户角色
<ul>
<li>通过一个外观角色访问各个子系统的功能</li>
</ul>
</li>
</ul>
<pre><code class="language-java">package totoroay.facade;
// 子系统：cpu
public class CPU {
    public void startup() {
        System.out.println(&quot;cpu startup...&quot;);
    }

    public void shutdown() {
        System.out.println(&quot;cpu shutdown...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.facade;
// 子系统：memory
public class Memory {
    public void startup() {
        System.out.println(&quot;memory startup...&quot;);
    }

    public void shutdown() {
        System.out.println(&quot;memory shutdown...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.facade;
// 子系统：disk
public class Disk {
    public void startup() {
        System.out.println(&quot;disk startup...&quot;);
    }

    public void shutdown() {
        System.out.println(&quot;disk shutdown...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.facade;
// 外观角色：Computer
public class Computer {
    private CPU cpu;
    private Memory memory;
    private Disk disk;

    public Computer() {
        cpu = new CPU();
        memory = new Memory();
        disk = new Disk();
    }

    public void startup(){
        System.out.println(&quot;computer startup...&quot;);
        cpu.startup();
        memory.startup();
        disk.startup();
        System.out.println(&quot;computer start successful...&quot;);
    }

    public void shutdown() {
        System.out.println(&quot;computer shutdown...&quot;);
        cpu.shutdown();
        memory.shutdown();
        disk.shutdown();
        System.out.println(&quot;computer shutdown successful...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.facade;
// 客户角色：
public class ComputerFacade {
    public static void main(String[] args) {
        Computer computer = new Computer();
        computer.startup();
        System.out.println(&quot;电脑运行中...&quot;);

        computer.shutdown();
    }
}
</code></pre>
<p><strong>结果</strong></p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589266814798.png" alt="" loading="lazy"></figure>
<p><strong>结构分析</strong></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589266811218.png" alt="" loading="lazy"></figure>
<p><strong>应用场景</strong></p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589266806093.png" alt="" loading="lazy"></figure>
<p><strong>扩展：系统升级！！！</strong></p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589266801540.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[装饰模式]]></title>
        <id>https://totoroay.github.io/post/zhuang-shi-mo-shi/</id>
        <link href="https://totoroay.github.io/post/zhuang-shi-mo-shi/">
        </link>
        <updated>2020-05-12T06:56:33.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589266708394.png" alt="" loading="lazy"></figure>
<p><strong>模式结构：包含的角色</strong></p>
<ul>
<li>抽象构件角色：
<ul>
<li>定义一个抽象接口以规范准备接收附加责任的对象</li>
</ul>
</li>
<li>具体构件角色：
<ul>
<li>实现抽象构件，通过装饰角色为其添加一些职责</li>
</ul>
</li>
<li>抽象装饰角色：
<ul>
<li>继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能</li>
</ul>
</li>
<li>具体装饰角色：
<ul>
<li>实现抽象装饰的相关方法，并给具体构件对象添加附加的责任</li>
</ul>
</li>
</ul>
<pre><code class="language-java">package totoroay.decorator;
// 抽象构件：奶茶
public interface MilkTea {
    String milkTeaName();
    int milkTeaPrice();
}
</code></pre>
<pre><code class="language-java">package totoroay.decorator;
// 具体构件：珍珠奶茶
public class PearlMilkTea implements MilkTea {
    @Override
    public String milkTeaName() {
        return &quot;珍珠奶茶&quot;;
    }

    @Override
    public int milkTeaPrice() {
        return 10;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.decorator;
// 具体构件：港式奶茶
public class HongKongMilkTea implements MilkTea {
    @Override
    public String milkTeaName() {
        return &quot;港式奶茶&quot;;
    }

    @Override
    public int milkTeaPrice() {
        return 12;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.decorator;
// 抽象装饰：奶茶口味
public abstract class Taste implements MilkTea {
    @Override
    public String milkTeaName() {
        return null;
    }

    @Override
    public int milkTeaPrice() {
        return 0;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.decorator;
// 具体装饰：加椰果
public class AddYeGuoTaste extends Taste {
    private String description = &quot;加椰果&quot;;
    private MilkTea milkTea;

    public AddYeGuoTaste(MilkTea milkTea) {
        this.milkTea = milkTea;
    }

    @Override
    public String milkTeaName() {
        return milkTea.milkTeaName() + &quot;  &quot; + description;
    }

    @Override
    public int milkTeaPrice() {
        return milkTea.milkTeaPrice()+2;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.decorator;
// 具体装饰：加布丁
public class AddBuDingTaste extends Taste {
    private String description = &quot;加布丁&quot;;
    private MilkTea milkTea;

    public AddBuDingTaste(MilkTea milkTea) {
        this.milkTea = milkTea;
    }

    @Override
    public String milkTeaName() {
        return milkTea.milkTeaName() + &quot;  &quot; + description;
    }

    @Override
    public int milkTeaPrice() {
        return milkTea.milkTeaPrice()+2;
    }
}
</code></pre>
<p><strong>测试</strong></p>
<pre><code class="language-java">package totoroay.decorator;

public class test {
    public static void main(String[] args) {
        MilkTea pearlMilkTea = new PearlMilkTea();
        System.out.println(pearlMilkTea.milkTeaName()+&quot;  &quot;+pearlMilkTea.milkTeaPrice());
        MilkTea hongKongMilkTea = new HongKongMilkTea();
        System.out.println(hongKongMilkTea.milkTeaName()+&quot;  &quot;+hongKongMilkTea.milkTeaPrice());

        System.out.println(&quot;============&quot;);
        AddYeGuoTaste addYeGuoTaste = new AddYeGuoTaste(pearlMilkTea);
        System.out.println(addYeGuoTaste.milkTeaName()+&quot;  &quot;+addYeGuoTaste.milkTeaPrice());
        AddBuDingTaste addBuDingTaste = new AddBuDingTaste(hongKongMilkTea);
        System.out.println(addBuDingTaste.milkTeaName()+&quot;  &quot;+addBuDingTaste.milkTeaPrice());
    }
}
</code></pre>
<p><strong>结果</strong></p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589266697409.png" alt="" loading="lazy"></figure>
<p><strong>结构分析</strong></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589266693620.png" alt="" loading="lazy"></figure>
<p><strong>应用场景</strong></p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589266688028.png" alt="" loading="lazy"></figure>
<p><strong>扩展</strong></p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589266682246.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1589266673645.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot08：MVC自动配置原理]]></title>
        <id>https://totoroay.github.io/post/springboot08mvc-zi-dong-pei-zhi-yuan-li/</id>
        <link href="https://totoroay.github.io/post/springboot08mvc-zi-dong-pei-zhi-yuan-li/">
        </link>
        <updated>2020-05-10T12:50:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="官网阅读">官网阅读</h2>
<p>在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。</p>
<p>只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！</p>
<p>地址 ：https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</p>
<pre><code class="language-java">Spring MVC Auto-configuration
    
    
// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。
Spring Boot provides auto-configuration for Spring MVC that works well with most applications.
// 自动配置在Spring默认设置的基础上添加了以下功能：
The auto-configuration adds the following features on top of Spring’s defaults:
// 包含视图解析器
Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.
// 支持静态资源文件夹的路径，以及webjars
Support for serving static resources, including support for WebJars 
// 自动注册了Converter：
// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型
// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】
Automatic registration of Converter, GenericConverter, and Formatter beans.
// HttpMessageConverters
// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；
Support for HttpMessageConverters (covered later in this document).
// 定义错误代码生成规则的
Automatic registration of MessageCodesResolver (covered later in this document).
// 首页定制
Static index.html support.
// 图标定制
Custom Favicon support (covered later in this document).
// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！
Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).

/*
如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己
的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供
RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义
实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。
*/
If you want to keep Spring Boot MVC features and you want to add additional MVC configuration 
(interceptors, formatters, view controllers, and other features), you can add your own 
@Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide 
custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or 
ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.

// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。
If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.
</code></pre>
<p>我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？</p>
<h2 id="contentnegotiatingviewresolver-内容协商视图解析器"><strong>ContentNegotiatingViewResolver 内容协商视图解析器</strong></h2>
<p>自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器；</p>
<p>即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。</p>
<p>我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！</p>
<pre><code class="language-java">@Bean
@ConditionalOnBean(ViewResolver.class)
@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)
public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {
    ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
    resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class));
    // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级
    resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
    return resolver;
}
</code></pre>
<p>我们可以点进这类看看！找到对应的解析视图的代码；</p>
<pre><code class="language-java">@Nullable // 注解说明：@Nullable 即参数可为null
public View resolveViewName(String viewName, Locale locale) throws Exception {
    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
    Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);
    List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());
    if (requestedMediaTypes != null) {
        // 获取候选的视图对象
        List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);
        // 选择一个最适合的视图对象，然后把这个对象返回
        View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);
        if (bestView != null) {
            return bestView;
        }
    }
    // .....
}
</code></pre>
<p>我们继续点进去看，他是怎么获得候选的视图的呢？</p>
<p>getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！</p>
<pre><code> Iterator var5 = this.viewResolvers.iterator();
</code></pre>
<p>所以得出结论：<strong>ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的</strong></p>
<p>我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！</p>
<pre><code class="language-java">protected void initServletContext(ServletContext servletContext) {
    // 这里它是从beanFactory工具中获取容器中的所有视图解析器
    // ViewRescolver.class 把所有的视图解析器来组合的
    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();
    ViewResolver viewResolver;
    if (this.viewResolvers == null) {
        this.viewResolvers = new ArrayList(matchingBeans.size());
    }
    // ...............
}
</code></pre>
<p>既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？</p>
<p>我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；<strong>我们去实现一下</strong></p>
<p>1、我们在我们的主程序中去写一个视图解析器来试试；</p>
<pre><code class="language-java">@Bean //放到bean中
public ViewResolver myViewResolver(){
    return new MyViewResolver();
}

//我们写一个静态内部类，视图解析器就需要实现ViewResolver接口
private static class MyViewResolver implements ViewResolver{
    @Override
    public View resolveViewName(String s, Locale locale) throws Exception {
        return null;
    }
}
</code></pre>
<p>2、怎么看我们自己写的视图解析器有没有起作用呢？</p>
<p>我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589115089253.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589115082896.png" alt="" loading="lazy"></figure>
<p>所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！</p>
<h2 id="转换器和格式化器">转换器和格式化器</h2>
<p>在WebMvcAutoConfiguration.java中找到格式化转换器：</p>
<pre><code class="language-java">@Bean
@Override
public FormattingConversionService mvcConversionService() {
    // 拿到配置文件中的格式化规则
    WebConversionService conversionService = 
        new WebConversionService(this.mvcProperties.getDateFormat());
    addFormatters(conversionService);
    return conversionService;
}
</code></pre>
<p>点击去：</p>
<pre><code class="language-java">public String getDateFormat() {
    return this.dateFormat;
}

/**
* Date format to use. For instance, `dd/MM/yyyy`. 默认的
 */
private String dateFormat;
</code></pre>
<p>可以看到在我们的Properties文件中，我们可以进行自动配置它！</p>
<p>如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则：</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589115073930.png" alt="" loading="lazy"></figure>
<p>其余的就不一一举例了，大家可以下去多研究探讨即可！</p>
<h2 id="修改springboot的默认配置">修改SpringBoot的默认配置</h2>
<p>这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。</p>
<p>SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论；</p>
<p>SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的；</p>
<p>如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！</p>
<p><strong>扩展使用SpringMVC</strong>  官方文档如下：</p>
<p>If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.</p>
<p>我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig；</p>
<pre><code class="language-java">// 应为类型要求为WebMvcConfigurer，所以我们实现其接口
// 可以使用自定义类扩展MVC的功能
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // 浏览器发送/test ， 就会跳转到test页面；
        registry.addViewController(&quot;/totoroay&quot;).setViewName(&quot;test&quot;);
    }
}
</code></pre>
<p>我们去浏览器访问一下：</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589115065920.png" alt="" loading="lazy"></figure>
<p><strong>确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！</strong></p>
<p>我们可以去分析一下原理：</p>
<p>1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter</p>
<p>2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)</p>
<p>3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration</p>
<p>这个父类中有这样一段代码：</p>
<pre><code class="language-java">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
    
  // 从容器中获取所有的webmvcConfigurer
    @Autowired(required = false)
    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {
        if (!CollectionUtils.isEmpty(configurers)) {
            this.configurers.addWebMvcConfigurers(configurers);
        }
    }
}
</code></pre>
<p>4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个</p>
<pre><code class="language-java">protected void addViewControllers(ViewControllerRegistry registry) {
    this.configurers.addViewControllers(registry);
}
</code></pre>
<p>5、我们点进去看一下</p>
<pre><code class="language-java">public void addViewControllers(ViewControllerRegistry registry) {
    Iterator var2 = this.delegates.iterator();

    while(var2.hasNext()) {
        // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的
        WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();
        delegate.addViewControllers(registry);
    }

}
</code></pre>
<p>所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；</p>
<h2 id="全面接管springmvc">全面接管SpringMVC</h2>
<p>官方文档：</p>
<pre><code>If you want to take complete control of Spring MVC
you can add your own @Configuration annotated with @EnableWebMvc.
</code></pre>
<p>全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！</p>
<p>只需在我们的配置类中要加一个@EnableWebMvc。</p>
<p>我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效，我们可以去测试一下；</p>
<p>不加注解之前，访问首页：</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589115054327.png" alt="" loading="lazy"></figure>
<p>给配置类加上注解再重启：@EnableWebMvc</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1589115048051.png" alt="" loading="lazy"></figure>
<p>我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子；</p>
<p><strong>当然，我们开发中，不推荐使用全面接管SpringMVC</strong></p>
<p>思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码：</p>
<p>1、这里发现它是导入了一个类，我们可以继续进去看</p>
<pre><code class="language-java">@Import({DelegatingWebMvcConfiguration.class})
public @interface EnableWebMvc {
}
</code></pre>
<p>2、它继承了一个父类 WebMvcConfigurationSupport</p>
<pre><code class="language-java">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
  // ......
}
</code></pre>
<p>3、我们来回顾一下Webmvc自动配置类</p>
<pre><code class="language-java">@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
    ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {
    
}
</code></pre>
<p>总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了；</p>
<p>而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！</p>
<p><strong>在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：声明事务]]></title>
        <id>https://totoroay.github.io/post/springsheng-ming-shi-wu/</id>
        <link href="https://totoroay.github.io/post/springsheng-ming-shi-wu/">
        </link>
        <updated>2020-05-10T03:18:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="声明式事务">声明式事务</h2>
<ul>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
<li>事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。</li>
</ul>
<p><mark>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</mark></p>
<p><strong>事务四个属性ACID</strong></p>
<ol>
<li>
<p>原子性（atomicity）</p>
</li>
<li>
<ul>
<li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</li>
</ul>
</li>
<li>
<p>一致性（consistency）</p>
</li>
<li>
<ul>
<li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</li>
</ul>
</li>
<li>
<p>隔离性（isolation）</p>
</li>
<li>
<ul>
<li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li>
</ul>
</li>
<li>
<p>持久性（durability）</p>
</li>
<li>
<ul>
<li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</li>
</ul>
</li>
</ol>
<h2 id="测试">测试</h2>
<p>将上面的代码拷贝到一个新项目中</p>
<p>在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户；</p>
<pre><code class="language-java">//添加一个用户
int addUser(User user);

//根据id删除用户
int deleteUser(int id);
</code></pre>
<p>mapper文件，我们故意把 deletes 写错，测试！</p>
<pre><code class="language-java">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.totoroay.pojo.User&quot;&gt;
insert into user (id,name,pwd) values (#{id},#{name},#{pwd})
&lt;/insert&gt;

&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
deletes from user where id = #{id}
&lt;/delete
</code></pre>
<p>编写接口的实现类，在实现类中，我们去操作一波</p>
<pre><code class="language-java">public class UserDaoImpl extends SqlSessionDaoSupport implementsUserMapper {

   //增加一些操作
   public List&lt;User&gt; selectUser() {
       User user = new User(4,&quot;小明&quot;,&quot;123456&quot;);
       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
       mapper.addUser(user);
       mapper.deleteUser(4);
       return mapper.selectUser();
  }

   //新增
   public int addUser(User user) {
       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
       return mapper.addUser(user);
  }
   //删除
   public int deleteUser(int id) {
       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
       return mapper.deleteUser(id);
  }

}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@Test
public void test2(){
   ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);
   List&lt;User&gt; user = mapper.selectUser();
   System.out.println(user);
}
</code></pre>
<p>报错：sql异常，delete写错了</p>
<p>结果 ：插入成功！</p>
<p>没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要==<strong>事务！</strong>==</p>
<p>以前我们都需要自己手动管理事务，十分麻烦！</p>
<p>但是Spring给我们提供了事务管理，我们只需要配置即可；</p>
<h2 id="spring中的事务管理">Spring中的事务管理</h2>
<p>Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p>
<p><strong>编程式事务管理</strong></p>
<ul>
<li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li>
<li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li>
</ul>
<p><strong>声明式事务管理</strong></p>
<ul>
<li>一般情况下比编程式事务好用。</li>
<li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li>
<li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。</li>
</ul>
<p><strong>使用Spring管理事务，注意头文件的约束导入 : tx</strong></p>
<pre><code class="language-xml">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;

http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
</code></pre>
<p><strong>事务管理器</strong></p>
<ul>
<li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li>
<li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li>
</ul>
<p><strong>JDBC事务</strong></p>
<pre><code class="language-xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>配置好事务管理器后我们需要去配置事务的通知</strong></p>
<pre><code class="language-xml">&lt;!--配置事务通知--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
   &lt;tx:attributes&gt;
       &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;
       &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
       &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
       &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
       &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;
       &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;
       &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
   &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<p><strong>spring事务传播特性：</strong></p>
<p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<ul>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li>
</ul>
<p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p>
<p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p>
<p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p>
<p><strong>配置AOP</strong></p>
<p>导入aop的头文件！</p>
<pre><code class="language-xml">&lt;!--配置aop织入事务--&gt;
&lt;aop:config&gt;
   &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.totoroay.dao.*.*(..))&quot;/&gt;
   &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
<p><strong>进行测试</strong></p>
<p>删掉刚才插入的数据，再次测试！</p>
<pre><code class="language-java">@Test
public void test2(){
   ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);
   List&lt;User&gt; user = mapper.selectUser();
   System.out.println(user);
}
</code></pre>
<blockquote>
<p>思考问题？</p>
</blockquote>
<p>为什么需要配置事务？</p>
<ul>
<li>如果不配置，就需要我们手动提交控制事务；</li>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ SpringBoot07：Thymeleaf模板引擎]]></title>
        <id>https://totoroay.github.io/post/springboot07thymeleaf-mo-ban-yin-qing/</id>
        <link href="https://totoroay.github.io/post/springboot07thymeleaf-mo-ban-yin-qing/">
        </link>
        <updated>2020-05-09T13:11:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="thymeleaf">Thymeleaf</h2>
<p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p>
<p>jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，<strong>他现在默认是不支持jsp的</strong>。</p>
<p>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？</p>
<p><strong>SpringBoot推荐你可以来使用模板引擎：</strong></p>
<p>模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图：</p>
<p><img src="https://totoroay.github.io//post-images/1589030049112.png" alt="" loading="lazy"><br>
模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。</p>
<p>我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。</p>
<h2 id="引入thymeleaf">引入Thymeleaf</h2>
<p>怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：</p>
<p>Thymeleaf 官网：https://www.thymeleaf.org/</p>
<p>Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf</p>
<p>Spring官方文档：找到我们对应的版本</p>
<p>https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</p>
<p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p>
<pre><code class="language-xml">&lt;!--thymeleaf--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Maven会自动下载jar包，我们可以去看下下载的东西；</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589030040046.png" alt="" loading="lazy"></figure>
<h2 id="thymeleaf分析">Thymeleaf分析</h2>
<p>前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？</p>
<p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。</p>
<p>我们去找一下Thymeleaf的自动配置类：ThymeleafProperties</p>
<pre><code class="language-java">@ConfigurationProperties(
    prefix = &quot;spring.thymeleaf&quot;
)
public class ThymeleafProperties {
    private static final Charset DEFAULT_ENCODING;
    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;
    public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
    private boolean checkTemplate = true;
    private boolean checkTemplateLocation = true;
    private String prefix = &quot;classpath:/templates/&quot;;
    private String suffix = &quot;.html&quot;;
    private String mode = &quot;HTML&quot;;
    private Charset encoding;
}
</code></pre>
<p>我们可以在其中看到默认的前缀和后缀！</p>
<p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p>
<p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p>
<h2 id="测试">测试</h2>
<p>1、编写一个TestController</p>
<pre><code class="language-java">@Controller
public class TestController {
    
    @RequestMapping(&quot;/t1&quot;)
    public String test1(){
        //classpath:/templates/test.html
        return &quot;test&quot;;
    }
    
}
</code></pre>
<p>2、编写一个测试页面  test.html 放在 templates 目录下</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;测试页面&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、启动项目请求测试</p>
<h2 id="thymeleaf-语法学习">Thymeleaf 语法学习</h2>
<p>要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下；</p>
<p>Thymeleaf 官网：https://www.thymeleaf.org/ ， 简单看一下官网！我们去下载Thymeleaf的官方文档！</p>
<p><strong>我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示</strong></p>
<p>1、修改测试请求，增加数据传输；</p>
<pre><code class="language-java">@RequestMapping(&quot;/t1&quot;)
public String test1(Model model){
    //存入数据
    model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);
    //classpath:/templates/test.html
    return &quot;test&quot;;
}
</code></pre>
<p>2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。</p>
<p>我们可以去官方文档的#3中看一下命名空间拿来过来：</p>
<pre><code> xmlns:th=&quot;http://www.thymeleaf.org&quot;
</code></pre>
<p>3、我们去编写下前端页面</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;test&lt;/h1&gt;
&lt;!--所有的html元素都可以被thymeleaf替换:   th:元素名--&gt;
&lt;!--th:text就是将div中的内容设置为它指定的值，和Vue一样--&gt;
&lt;div th:text=&quot;${msg}&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4、启动测试</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589030024666.png" alt="" loading="lazy"></figure>
<p><strong>OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！</strong></p>
<p><strong>1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！</strong></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589030016433.jpg" alt="" loading="lazy"></figure>
<p><strong>2、我们能写哪些表达式呢？</strong></p>
<pre><code>Simple expressions:（表达式语法）
Variable Expressions: ${...}：获取变量值；OGNL；
    1）、获取对象的属性、调用方法
    2）、使用内置的基本对象：#18
         #ctx : the context object.
         #vars: the context variables.
         #locale : the context locale.
         #request : (only in Web Contexts) the HttpServletRequest object.
         #response : (only in Web Contexts) the HttpServletResponse object.
         #session : (only in Web Contexts) the HttpSession object.
         #servletContext : (only in Web Contexts) the ServletContext object.

    3）、内置的一些工具对象：
　　　　　　#execInfo : information about the template being processed.
　　　　　　#uris : methods for escaping parts of URLs/URIs
　　　　　　#conversions : methods for executing the configured conversion service (if any).
　　　　　　#dates : methods for java.util.Date objects: formatting, component extraction, etc.
　　　　　　#calendars : analogous to #dates , but for java.util.Calendar objects.
　　　　　　#numbers : methods for formatting numeric objects.
　　　　　　#strings : methods for String objects: contains, startsWith, prepending/appending, etc.
　　　　　　#objects : methods for objects in general.
　　　　　　#bools : methods for boolean evaluation.
　　　　　　#arrays : methods for arrays.
　　　　　　#lists : methods for lists.
　　　　　　#sets : methods for sets.
　　　　　　#maps : methods for maps.
　　　　　　#aggregates : methods for creating aggregates on arrays or collections.
==================================================================================

  Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；
  Message Expressions: #{...}：获取国际化内容
  Link URL Expressions: @{...}：定义URL；
  Fragment Expressions: ~{...}：片段引用表达式

Literals（字面量）
      Text literals: 'one text' , 'Another one!' ,…
      Number literals: 0 , 34 , 3.0 , 12.3 ,…
      Boolean literals: true , false
      Null literal: null
      Literal tokens: one , sometext , main ,…
      
Text operations:（文本操作）
    String concatenation: +
    Literal substitutions: |The name is ${name}|
    
Arithmetic operations:（数学运算）
    Binary operators: + , - , * , / , %
    Minus sign (unary operator): -
    
Boolean operations:（布尔运算）
    Binary operators: and , or
    Boolean negation (unary operator): ! , not
    
Comparisons and equality:（比较运算）
    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )
    Equality operators: == , != ( eq , ne )
    
Conditional operators:条件运算（三元运算符）
    If-then: (if) ? (then)
    If-then-else: (if) ? (then) : (else)
    Default: (value) ?: (defaultvalue)
    
Special tokens:
    No-Operation: _
</code></pre>
<p><strong>练习测试：</strong></p>
<p>1、 我们编写一个Controller，放一些数据</p>
<pre><code class="language-java">@RequestMapping(&quot;/t2&quot;)
public String test2(Map&lt;String,Object&gt; map){
    //存入数据
    map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;);
    map.put(&quot;users&quot;, Arrays.asList(&quot;qinjiang&quot;,&quot;kuangshen&quot;));
    //classpath:/templates/test.html
    return &quot;test&quot;;
}
</code></pre>
<p>2、测试页面取出数据</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;test&lt;/h1&gt;

&lt;div th:text=&quot;${msg}&quot;&gt;&lt;/div&gt;
&lt;!--不转义--&gt;
&lt;div th:utext=&quot;${msg}&quot;&gt;&lt;/div&gt;

&lt;!--遍历数据--&gt;
&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;
&lt;h4 th:each=&quot;user :${users}&quot; th:text=&quot;${user}&quot;&gt;&lt;/h4&gt;

&lt;h4&gt;
    &lt;!--行内写法：官网#12--&gt;
    &lt;span th:each=&quot;user:${users}&quot;&gt;[[${user}]]&lt;/span&gt;
&lt;/h4&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、启动项目测试</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589030000687.png" alt="" loading="lazy"></figure>
<p><strong>我们看完语法，很多样式，我们即使现在学习了，也会忘记，所以我们在学习过程中，需要使用什么，根据官方文档来查询，才是最重要的，要熟练使用官方文档！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：AOP]]></title>
        <id>https://totoroay.github.io/post/springaop/</id>
        <link href="https://totoroay.github.io/post/springaop/">
        </link>
        <updated>2020-05-09T05:50:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是aop">什么是AOP</h2>
<p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589003489694.png" alt="" loading="lazy"></figure>
<h2 id="aop在spring中的作用">Aop在Spring中的作用</h2>
<p><mark>提供声明式事务；允许用户自定义切面</mark></p>
<p><mark>以下名词需要了解下：</mark></p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ....</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589003480765.png" alt="" loading="lazy"></figure>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589003466003.png" alt="" loading="lazy"></figure>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<h2 id="使用spring实现aop">使用Spring实现Aop</h2>
<p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
   &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="第一种方式通过-spring-api-实现">第一种方式通过 Spring API 实现</h3>
<p>首先编写我们的业务接口和实现类</p>
<pre><code class="language-java">public interface UserService {

   public void add();

   public void delete();

   public void update();

   public void search();

}
</code></pre>
<pre><code class="language-java">public class UserServiceImpl implements UserService{

   @Override
   public void add() {
       System.out.println(&quot;增加用户&quot;);
  }

   @Override
   public void delete() {
       System.out.println(&quot;删除用户&quot;);
  }

   @Override
   public void update() {
       System.out.println(&quot;更新用户&quot;);
  }

   @Override
   public void search() {
       System.out.println(&quot;查询用户&quot;);
  }
}
</code></pre>
<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<pre><code class="language-java">// 前置增强
public class Log implements MethodBeforeAdvice {

   //method : 要执行的目标对象的方法
   //objects : 被调用的方法的参数
   //Object : 目标对象
   @Override
   public void before(Method method, Object[] objects, Object target) throwsThrowable {
       System.out.println( target.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);
  }
}
</code></pre>
<pre><code class="language-java">// 后置增强
public class AfterLog implements AfterReturningAdvice {
   //returnValue 返回值
   //method被调用的方法
   //args 被调用的方法的对象的参数
   //target 被调用的目标对象
   @Override
   public void afterReturning(Object returnValue, Method method, Object[] args,Object target) throws Throwable {
       System.out.println(&quot;执行了&quot; + target.getClass().getName()
       +&quot;的&quot;+method.getName()+&quot;方法,&quot;
       +&quot;返回值：&quot;+returnValue);
  }
}
</code></pre>
<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

   &lt;!--注册bean--&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.totoroay.service.UserServiceImpl&quot;/&gt;
   &lt;bean id=&quot;log&quot; class=&quot;com.totoroay.log.Log&quot;/&gt;
   &lt;bean id=&quot;afterLog&quot; class=&quot;com.totoroay.log.AfterLog&quot;/&gt;

   &lt;!--aop的配置--&gt;
   &lt;aop:config&gt;
       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;
       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;
       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="language-java">public class MyTest {
   @Test
   public void test(){
       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.search();
  }
}
</code></pre>
<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .</p>
<h3 id="第二种方式自定义类来实现aop">第二种方式自定义类来实现Aop</h3>
<p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<pre><code class="language-java">public class DiyPointcut {

   public void before(){
       System.out.println(&quot;---------方法执行前---------&quot;);
  }
   public void after(){
       System.out.println(&quot;---------方法执行后---------&quot;);
  }
   
}
</code></pre>
<p>去spring中配置</p>
<pre><code class="language-xml">&lt;!--第二种方式自定义实现--&gt;
&lt;!--注册bean--&gt;
&lt;bean id=&quot;diy&quot; class=&quot;com.totoroay.config.DiyPointcut&quot;/&gt;

&lt;!--aop的配置--&gt;
&lt;aop:config&gt;
   &lt;!--第二种方式：使用AOP的标签实现--&gt;
   &lt;aop:aspect ref=&quot;diy&quot;&gt;
       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;
       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class MyTest {
   @Test
   public void test(){
       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.add();
  }
}
</code></pre>
<h3 id="第三种方式使用注解实现">第三种方式使用注解实现</h3>
<p>第一步：编写一个注解实现的增强类</p>
<pre><code class="language-java">package com.totoroay.config;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect //标注这个类是一个切面
public class AnnotationPointcut {
   @Before(&quot;execution(* com.totoroay.service.UserServiceImpl.*(..))&quot;)
   public void before(){
       System.out.println(&quot;---------方法执行前---------&quot;);
  }

   @After(&quot;execution(* com.totoroay.service.UserServiceImpl.*(..))&quot;)
   public void after(){
       System.out.println(&quot;---------方法执行后---------&quot;);
  }

   @Around(&quot;execution(* com.totoroay.service.UserServiceImpl.*(..))&quot;)
   public void around(ProceedingJoinPoint jp) throws Throwable {
       System.out.println(&quot;环绕前&quot;);
       System.out.println(&quot;签名:&quot;+jp.getSignature());
       //执行目标方法proceed
       Object proceed = jp.proceed();
       System.out.println(&quot;环绕后&quot;);
       System.out.println(proceed);
  }
}
</code></pre>
<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<pre><code class="language-xml">&lt;!--第三种方式:注解实现--&gt;
&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.totoroay.config.AnnotationPointcut&quot;/&gt;
&lt;aop:aspectj-autoproxy/
</code></pre>
<p>aop:aspectj-autoproxy：说明</p>
<pre><code class="language-xml">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了

&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ngork内网穿透]]></title>
        <id>https://totoroay.github.io/post/ngork-nei-wang-chuan-tou/</id>
        <link href="https://totoroay.github.io/post/ngork-nei-wang-chuan-tou/">
        </link>
        <updated>2020-05-09T02:33:15.000Z</updated>
        <content type="html"><![CDATA[<p>1、到官网注册</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588997942816.png" alt="" loading="lazy"></figure>
<p>2、注册成功后开通隧道</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588997949246.png" alt="" loading="lazy"></figure>
<p>3、填写相关信息</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588997954532.png" alt="" loading="lazy"></figure>
<p>4、选择对应的版本，下载解压启动工具</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1588997960465.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1588997967933.png" alt="" loading="lazy"></figure>
<p>5、填写隧道id并回车</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1588997979308.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1588997988830.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://totoroay.github.io//post-images/1588997996995.png" alt="" loading="lazy"></figure>
<p>6、访问</p>
<ul>
<li>PC端启动项目后</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://totoroay.github.io//post-images/1588998006236.png" alt="" loading="lazy"></figure>
<ul>
<li>手机访问</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://totoroay.github.io//post-images/1588998018034.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://totoroay.github.io//post-images/1588998024505.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：自动装配及使用注解开发]]></title>
        <id>https://totoroay.github.io/post/springzi-dong-zhuang-pei-ji-shi-yong-zhu-jie-kai-fa/</id>
        <link href="https://totoroay.github.io/post/springzi-dong-zhuang-pei-ji-shi-yong-zhu-jie-kai-fa/">
        </link>
        <updated>2020-05-08T09:36:03.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自动装配">自动装配</h2>
<blockquote>
<p>自动装配说明</p>
</blockquote>
<ul>
<li>自动装配是使用spring满足bean依赖的一种方法</li>
<li>spring会在应用上下文中为某个bean寻找其依赖的bean。</li>
</ul>
<p>Spring中bean有三种装配机制，分别是：</p>
<ol>
<li>在xml中显式配置；</li>
<li>在java中显式配置；</li>
<li>隐式的bean发现机制和自动装配。</li>
</ol>
<p>这里我们主要讲第三种：自动化的装配bean。</p>
<p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p>
<ol>
<li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li>
<li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；</li>
</ol>
<p>组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少。</p>
<p><strong>推荐不使用自动装配xml配置 , 而使用注解 .</strong></p>
<blockquote>
<p>测试环境搭建</p>
</blockquote>
<p>1、新建一个项目</p>
<p>2、新建两个实体类，Cat  Dog  都有一个叫的方法</p>
<pre><code class="language-java">package com.totoroay.pojo;

public class Cat {
    public void shout(){
        System.out.println(&quot;喵&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package com.totoroay.pojo;

public class Dog {
    public void shout(){
        System.out.println(&quot;汪&quot;);
    }
}
</code></pre>
<p>3、新建一个用户类 User</p>
<pre><code class="language-java">public class User {
   private Cat cat;
   private Dog dog;
   private String name;
}
</code></pre>
<p>4、编写Spring配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

   &lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
   &lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;

   &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;&gt;
       &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt;
       &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt;
       &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
   &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>5、测试</p>
<pre><code class="language-java">public class MyTest {
   @Test
   public void testMethodAutowire() {
       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       User user = (User) context.getBean(&quot;user&quot;);
       user.getCat().shout();
       user.getDog().shout();
  }
}
</code></pre>
<p>结果正常输出，环境OK</p>
<blockquote>
<p>byName</p>
</blockquote>
<p><strong>autowire byName (按名称自动装配)</strong></p>
<p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p>
<p>采用自动装配将避免这些错误，并且使配置简单化。</p>
<p>测试：</p>
<p>1、修改bean配置，增加一个属性  autowire=&quot;byName&quot;</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; autowire=&quot;byName&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>2、再次测试，结果依旧成功输出！</p>
<p>3、我们将 cat 的bean id修改为 catXXX</p>
<p>4、再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p>
<p><strong>小结：</strong></p>
<p>当一个bean节点带有 autowire byName的属性时。</p>
<ol>
<li>
<p>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</p>
</li>
<li>
<p>去spring容器中寻找是否有此字符串名称id的对象。</p>
</li>
<li>
<p>如果有，就取出注入；如果没有，就报空指针异常。</p>
</li>
</ol>
<blockquote>
<p>byType</p>
</blockquote>
<p><strong>autowire byType (按类型自动装配)</strong></p>
<p>使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常。</p>
<pre><code>NoUniqueBeanDefinitionException
</code></pre>
<p>测试：</p>
<p>1、将user的bean配置修改一下 ： autowire=&quot;byType&quot;</p>
<p>2、测试，正常输出</p>
<p>3、在注册一个cat 的bean对象！</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot; autowire=&quot;byType&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>4、测试，报错：NoUniqueBeanDefinitionException</p>
<p>5、删掉cat2，将cat的bean名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将id属性去掉，也不影响结果。</p>
<p>这就是按照类型自动装配！</p>
<h2 id="使用注解">使用注解</h2>
<blockquote>
<p>使用注解</p>
</blockquote>
<p>jdk1.5开始支持注解，spring2.5开始全面支持注解。</p>
<p>准备工作：利用注解的方式注入属性。</p>
<p>1、在spring配置文件中引入context文件头</p>
<pre><code class="language-xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;

http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
</code></pre>
<p>2、开启属性注解支持！</p>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;/&gt;
    &lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
    &lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h4 id="autowired">@Autowired</h4>
<ul>
<li>@Autowired是按类型自动转配的，不支持id匹配。</li>
<li>需要导入 spring-aop的包！</li>
</ul>
<p>测试：</p>
<p>1、将User类中的set方法去掉，使用@Autowired注解</p>
<pre><code class="language-java">public class User {
   @Autowired
   private Cat cat;
   @Autowired
   private Dog dog;
   private String name;

   public Cat getCat() {
       return cat;
  }
   public Dog getDog() {
       return dog;
  }
   public String getName() {
       return str;
  }
}
</code></pre>
<p>2、此时配置文件内容</p>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;/&gt;
&lt;bean id=&quot;cat&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
</code></pre>
<p>3、测试，成功输出结果！</p>
<p>【科普时间】</p>
<p>@Autowired(required=false)  说明：false，对象可以为null；true，对象必须存对象，不能为null。</p>
<pre><code>//如果允许对象为null，设置required = false,默认为true
@Autowired(required = false)
private Cat cat;
</code></pre>
<h4 id="qualifier">@Qualifier</h4>
<ul>
<li>@Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配</li>
<li>@Qualifier不能单独使用。</li>
</ul>
<p>测试实验步骤：</p>
<p>1、配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog1&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;dog2&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
</code></pre>
<p>2、没有加Qualifier测试，直接报错</p>
<p>3、在属性上添加Qualifier注解</p>
<pre><code class="language-java">@Autowired
@Qualifier(value = &quot;cat2&quot;)
private Cat cat;
@Autowired
@Qualifier(value = &quot;dog2&quot;)
private Dog dog;
</code></pre>
<p>测试，成功输出！</p>
<h4 id="resource">@Resource</h4>
<ul>
<li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li>
<li>其次再进行默认的byName方式进行装配；</li>
<li>如果以上都不成功，则按byType的方式自动装配。</li>
<li>都不成功，则报异常。</li>
</ul>
<p>实体类：</p>
<pre><code class="language-java">public class User {
   //如果允许对象为null，设置required = false,默认为true
   @Resource(name = &quot;cat2&quot;)
   private Cat cat;
   @Resource
   private Dog dog;
   private String str;
}
</code></pre>
<p>beans.xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.totoroay.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;
&lt;bean id=&quot;cat2&quot; class=&quot;com.totoroay.pojo.Cat&quot;/&gt;

&lt;bean id=&quot;user&quot; class=&quot;com.totoroay.pojo.User&quot;/&gt;
</code></pre>
<p>测试：结果OK</p>
<p>配置文件2：beans.xml ， 删掉cat2</p>
<pre><code class="language-xml">&lt;bean id=&quot;dog&quot; class=&quot;com.kuang.pojo.Dog&quot;/&gt;
&lt;bean id=&quot;cat1&quot; class=&quot;com.kuang.pojo.Cat&quot;/&gt;
</code></pre>
<p>实体类上只保留注解</p>
<pre><code class="language-java">@Resource
private Cat cat;
@Resource
private Dog dog;
</code></pre>
<p>结果：OK</p>
<p>结论：先进行byName查找，失败；再进行byType查找，成功。</p>
<h3 id="小结">小结</h3>
<p>@Autowired与@Resource异同：</p>
<p>1、@Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。</p>
<p>2、@Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用</p>
<p>3、@Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。</p>
<p>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。</p>
<h2 id="使用注解开发">使用注解开发</h2>
<p>在spring4之后，想要使用注解形式，必须得要引入aop的包</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588930619093.png" alt="" loading="lazy"></figure>
<p>在配置文件当中，还得要引入一个context约束</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    
    &lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;
    &lt;context:component-scan base-package=&quot;com.totoroay.pojo&quot;/&gt;
    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
<blockquote>
<p>Bean的实现</p>
</blockquote>
<p>我们之前都是使用 bean 的标签进行bean注入，但是实际开发中，我们一般都会使用注解！</p>
<p>1、配置扫描哪些包下的注解</p>
<pre><code class="language-xml">&lt;!--指定注解扫描包--&gt;
&lt;context:component-scan base-package=&quot;com.totoroay.pojo&quot;/&gt;
</code></pre>
<p>2、在指定包下编写类，增加注解</p>
<pre><code class="language-java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User {
   public String name = &quot;totoroay&quot;;
}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void test(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    User user = context.getBean(&quot;user&quot;, User.class);
    System.out.println(user.getName());
}
</code></pre>
<blockquote>
<p>属性注入</p>
</blockquote>
<p>使用注解注入属性</p>
<p>1、可以不用提供set方法，直接在直接名上添加@value(&quot;值&quot;)</p>
<pre><code class="language-java">@Component(&quot;user&quot;)
// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;
public class User {
   @Value(&quot;totoroay&quot;)
   // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;totoroay&quot;/&gt;
   public String name;
}
</code></pre>
<p>2、如果提供了set方法，也可以在set方法上添加@value(&quot;值&quot;);</p>
<pre><code class="language-java">@Component(&quot;user&quot;)
public class User {

   public String name;

   @Value(&quot;totoroay&quot;)
   public void setName(String name) {
       this.name = name;
  }
}
</code></pre>
<blockquote>
<p>衍生注解</p>
</blockquote>
<p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p>
<p><strong>@Component三个衍生注解</strong></p>
<p>为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p>
<ul>
<li>@Controller：web层</li>
<li>@Service：service层</li>
<li>@Repository：dao层</li>
</ul>
<p>写上这些注解，就相当于将这个类交给Spring管理装配了！</p>
<blockquote>
<p>自动装配注解</p>
</blockquote>
<p>在Bean的自动装配已经讲过了，可以回顾！</p>
<blockquote>
<p>作用域</p>
</blockquote>
<p>@scope</p>
<ul>
<li>singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li>
<li>prototype：多例模式（原型模式）。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li>
</ul>
<pre><code class="language-java">@Controller(&quot;user&quot;)
@Scope(&quot;prototype&quot;)
public class User {
   @Value(&quot;totoroay&quot;)
   public String name;
}
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p><strong>XML与注解比较</strong></p>
<ul>
<li>XML可以适用任何场景 ，结构清晰，维护方便</li>
<li>注解不是自己提供的类使用不了，开发简单方便</li>
</ul>
<p><strong>xml与注解整合开发</strong> ：推荐最佳实践</p>
<ul>
<li>xml管理Bean</li>
<li>注解完成属性注入</li>
<li>使用过程中， 可以不用扫描，扫描是为了类上的注解</li>
</ul>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;  
</code></pre>
<p>作用：</p>
<ul>
<li>
<p>进行注解驱动注册，从而使注解生效</p>
</li>
<li>
<p>用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册</p>
</li>
<li>
<p>如果不扫描包，就需要手动配置bean</p>
</li>
<li>
<p>如果不加注解驱动，则注入的值为null！</p>
</li>
</ul>
<blockquote>
<p>基于Java类进行配置</p>
</blockquote>
<p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p>
<p>测试：</p>
<p>1、编写一个实体类，Dog</p>
<pre><code class="language-java">@Component  //将这个类标注为Spring的一个组件，放到容器中！
public class Dog {
   public String name = &quot;dog&quot;;
}
</code></pre>
<p>2、新建一个config配置包，编写一个MyConfig配置类</p>
<pre><code class="language-java">@Configuration  //代表这是一个配置类
public class MyConfig {

   @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！
   public Dog dog(){
       return new Dog();
  }

}
</code></pre>
<p>3、测试</p>
<pre><code class="language-java">@Test
public void test2(){
   ApplicationContext applicationContext =
           new AnnotationConfigApplicationContext(MyConfig.class);
   Dog dog = (Dog) applicationContext.getBean(&quot;dog&quot;);
   System.out.println(dog.name);
}
</code></pre>
<p>4、成功输出结果！</p>
<p><strong>导入其他配置如何做呢？</strong></p>
<p>1、我们再编写一个配置类！</p>
<pre><code class="language-java">@Configuration  //代表这是一个配置类
public class MyConfig2 {
}
</code></pre>
<p>2、在之前的配置类中我们来选择导入这个配置类</p>
<pre><code class="language-ja">@Configuration
@Import(MyConfig2.class)  //导入合并其他配置类，类似于配置文件中的 inculde 标签
public class MyConfig {

   @Bean
   public Dog dog(){
       return new Dog();
  }

}
</code></pre>
<p>关于这种Java类的配置方式，我们在之后的SpringBoot 和 SpringCloud中还会大量看到，我们需要知道这些注解的作用即可！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot06：Web开发静态资源处理]]></title>
        <id>https://totoroay.github.io/post/springboot06web-kai-fa-jing-tai-zi-yuan-chu-li/</id>
        <link href="https://totoroay.github.io/post/springboot06web-kai-fa-jing-tai-zi-yuan-chu-li/">
        </link>
        <updated>2020-05-08T05:39:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自动装配">自动装配</h2>
<p>springboot 到底帮我们配置了什么？我们能不能进行修改？能修改哪些东西？能不能扩展</p>
<ul>
<li>xxxAutoConfiguration	向容器中自动配置组件</li>
<li>xxxProperties	自动配置类 ，装配配置文件中自定义的一些内容</li>
</ul>
<p>要解决的问题：</p>
<ul>
<li>导入静态资源......</li>
<li>首页</li>
<li>jsp，模板引擎  Thymeleaf</li>
<li>装配扩展SpringMVC</li>
<li>增删改查</li>
<li>拦截器</li>
<li>国际化</li>
</ul>
<h2 id="web开发静态资源处理">Web开发静态资源处理</h2>
<h3 id="静态资源映射规则">静态资源映射规则</h3>
<p><strong>首先，我们搭建一个普通的SpringBoot项目，回顾一下HelloWorld程序！</strong></p>
<p>写请求非常简单，那我们要引入我们前端资源，我们项目中有许多的静态资源，比如css，js等文件，这个SpringBoot怎么处理呢？</p>
<p>如果我们是一个web应用，我们的main下会有一个webapp，我们以前都是将所有的页面导在这里面的，对吧！但是我们现在的pom呢，打包方式是为jar的方式，那么这种方式SpringBoot能不能来给我们写页面呢？当然是可以的，但是SpringBoot对于静态资源放置的位置，是有规定的！</p>
<p><strong>我们先来聊聊这个静态资源映射规则：</strong></p>
<p>SpringBoot中，SpringMVC的web配置都在 WebMvcAutoConfiguration 这个配置类里面；</p>
<p>我们可以去看看 WebMvcAutoConfigurationAdapter 中有很多配置方法；</p>
<p>有一个方法：addResourceHandlers 添加资源处理</p>
<pre><code class="language-java">@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    if (!this.resourceProperties.isAddMappings()) {
        // 已禁用默认资源处理
        logger.debug(&quot;Default resource handling disabled&quot;);
        return;
    }
    // 缓存控制
    Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
    CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
    // webjars 配置
    if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
        customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)
                                             .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)
                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
    // 静态资源配置
    String staticPathPattern = this.mvcProperties.getStaticPathPattern();
    if (!registry.hasMappingForPattern(staticPathPattern)) {
        customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)
                                             .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))
                                             .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));
    }
}
</code></pre>
<p>读一下源代码：比如所有的 /webjars/** ， 都需要去 classpath:/META-INF/resources/webjars/ 找对应的资源；</p>
<h3 id="什么是webjars-呢">什么是webjars 呢？</h3>
<p>Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可。</p>
<p>使用SpringBoot需要使用Webjars，我们可以去搜索一下：</p>
<p>网站：https://www.webjars.org</p>
<p>要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;3.5.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>导入完毕，查看webjars目录结构，并访问Jquery.js文件！</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1588916489459.png" alt="" loading="lazy"></figure>
<p>访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源，我们这里访问：http://localhost:8080/webjars/jquery/3.5.1/jquery.js</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1588916482138.png" alt="" loading="lazy"></figure>
<h3 id="第二种静态资源映射规则">第二种静态资源映射规则</h3>
<p>那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码；</p>
<p>我们去找staticPathPattern发现第二种映射规则 ：/** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：</p>
<pre><code class="language-java">// 进入方法
public String[] getStaticLocations() {
    return this.staticLocations;
}
// 找到对应的值
private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
// 找到路径
private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { 
    &quot;classpath:/META-INF/resources/&quot;,
  &quot;classpath:/resources/&quot;, 
    &quot;classpath:/static/&quot;, 
    &quot;classpath:/public/&quot; 
};
</code></pre>
<p>ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即上面数组的内容。</p>
<p>所以得出结论，以下四个目录存放的静态资源可以被我们识别：</p>
<pre><code>&quot;classpath:/METAINF/resources/&quot;
&quot;classpath:/resources/&quot;
&quot;classpath:/static/&quot;
&quot;classpath:/public/&quot;
</code></pre>
<p><mark>resources &gt; static(默认)  &gt; public</mark></p>
<p>我们可以在resources根目录下新建对应的文件夹，都可以存放我们的静态文件；</p>
<p>比如我们访问 http://localhost:8080/1.js , 他就会去这些文件夹中寻找对应的静态资源文件；</p>
<h3 id="自定义静态资源路径">自定义静态资源路径</h3>
<p>我们也可以自己通过配置文件来指定一下，哪些文件夹是需要我们放静态资源文件的，在application.properties中配置；</p>
<pre><code class="language-properties">spring.resources.static-locations=classpath:/coding/,classpath:/totoroay/
</code></pre>
<p>一旦自己定义了静态文件夹的路径，原来的自动配置就都会失效了！</p>
<h2 id="首页处理">首页处理</h2>
<p>静态资源文件夹说完后，我们继续向下看源码！可以看到一个欢迎页的映射，就是我们的首页！</p>
<pre><code class="language-java">@Bean
public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
                                                           FormattingConversionService mvcConversionService,
                                                           ResourceUrlProvider mvcResourceUrlProvider) {
    WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
        new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), // getWelcomePage 获得欢迎页
        this.mvcProperties.getStaticPathPattern());
    welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
    return welcomePageHandlerMapping;
}
</code></pre>
<p>点进去继续看</p>
<pre><code class="language-java">private Optional&lt;Resource&gt; getWelcomePage() {
    String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations());
    // ::是java8 中新引入的运算符
    // Class::function的时候function是属于Class的，应该是静态方法。
    // this::function的funtion是属于这个对象的。
    // 简而言之，就是一种语法糖而已，是一种简写
    return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst();
}
// 欢迎页就是一个location下的的 index.html 而已
private Resource getIndexHtml(String location) {
    return this.resourceLoader.getResource(location + &quot;index.html&quot;);
}
</code></pre>
<p>欢迎页，静态资源文件夹下的所有 index.html 页面；被 /** 映射。</p>
<p>比如我访问  http://localhost:8080/ ，就会找静态资源文件夹下的 index.html</p>
<p>在static目录下新建一个 index.html ，在我们上面的3个目录中任意一个；然后访问测试  http://localhost:8080/  看结果！</p>
<p><mark><strong>关于网站图标说明</strong>：</mark></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1588916438545.png" alt="" loading="lazy"></figure>
<p>将图标改名为favicon.ico放在public目录下即可</p>
]]></content>
    </entry>
</feed>