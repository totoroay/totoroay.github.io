<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://totoroay.github.io/</id>
    <title>totoroay</title>
    <updated>2020-05-18T13:36:47.933Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://totoroay.github.io/"/>
    <link rel="self" href="https://totoroay.github.io/atom.xml"/>
    <subtitle>每天学习5小时！！！</subtitle>
    <logo>https://totoroay.github.io/images/avatar.png</logo>
    <icon>https://totoroay.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, totoroay</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot12：集成SpringSecurity]]></title>
        <id>https://totoroay.github.io/post/springboot12ji-cheng-springsecurity/</id>
        <link href="https://totoroay.github.io/post/springboot12ji-cheng-springsecurity/">
        </link>
        <updated>2020-05-18T13:32:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="安全简介">安全简介</h2>
<p>在 Web 开发中，安全一直是非常重要的一个方面。安全虽然属于应用的非功能性需求，但是应该在应用开发的初期就考虑进来。如果在应用开发的后期才考虑安全的问题，就可能陷入一个两难的境地：一方面，应用存在严重的安全漏洞，无法满足用户的要求，并可能造成用户的隐私数据被攻击者窃取；另一方面，应用的基本架构已经确定，要修复安全漏洞，可能需要对系统的架构做出比较重大的调整，因而需要更多的开发时间，影响应用的发布进程。因此，从应用开发的第一天就应该把安全相关的因素考虑进来，并在整个应用的开发过程中。</p>
<p>市面上存在比较有名的：Shiro，Spring Security ！</p>
<p>这里需要阐述一下的是，每一个框架的出现都是为了解决某一问题而产生了，那么Spring Security框架的出现是为了解决什么问题呢？</p>
<p>首先我们看下它的官网介绍：Spring Security官网地址</p>
<p>Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p>
<p>Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p>
<p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它实际上是保护基于spring的应用程序的标准。</p>
<p>Spring Security是一个框架，侧重于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring安全性的真正强大之处在于它可以轻松地扩展以满足定制需求</p>
<p>从官网的介绍中可以知道这是一个权限框架。想我们之前做项目是没有使用框架是怎么控制权限的？对于权限 一般会细分为功能权限，访问权限，和菜单权限。代码会写的非常的繁琐，冗余。</p>
<p>怎么解决之前写权限代码繁琐，冗余的问题，一些主流框架就应运而生而Spring Scecurity就是其中的一种。</p>
<p>Spring 是一个非常流行和成功的 Java 应用开发框架。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分。用户认证指的是验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p>
<p>对于上面提到的两种应用情景，Spring Security 框架都有很好的支持。在用户认证方面，Spring Security 框架支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要认证、OpenID 和 LDAP 等。在用户授权方面，Spring Security 提供了基于角色的访问控制和访问控制列表（Access Control List，ACL），可以对应用中的领域对象进行细粒度的控制。</p>
<h2 id="实验环境搭建">实验环境搭建</h2>
<p>1、新建一个初始的springboot项目web模块，thymeleaf模块</p>
<p>2、导入静态资源</p>
<p>3、controller跳转！</p>
<pre><code class="language-java">package com.totoroay.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class RouteController {
    @RequestMapping({&quot;/&quot;,&quot;/index&quot;,&quot;/index.html&quot;})
    public String index(){
        return &quot;index&quot;;
    }

    @RequestMapping(&quot;/toLogin&quot;)
    public String toLogin(){
        return &quot;views/login&quot;;
    }

    @RequestMapping(&quot;/level1/{id}&quot;)
    public String level1(@PathVariable(&quot;id&quot;) int id){
        return &quot;views/level1/&quot;+id;
    }
    @RequestMapping(&quot;/level2/{id}&quot;)
    public String level2(@PathVariable(&quot;id&quot;) int id){
        return &quot;views/level2/&quot;+id;
    }
    @RequestMapping(&quot;/level3/{id}&quot;)
    public String level3(@PathVariable(&quot;id&quot;) int id){
        return &quot;views/level3/&quot;+id;
    }
}
</code></pre>
<p>4、测试实验环境是否OK！</p>
<h2 id="认识springsecurity">认识SpringSecurity</h2>
<p>Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！</p>
<p>记住几个类：</p>
<ul>
<li>WebSecurityConfigurerAdapter：自定义Security策略</li>
<li>AuthenticationManagerBuilder：自定义认证策略</li>
<li>@EnableWebSecurity：开启WebSecurity模式</li>
</ul>
<p>Spring Security的两个主要目标是 “认证” 和 “授权”（访问控制）。</p>
<p><strong>“认证”（Authentication）</strong></p>
<p>身份验证是关于验证您的凭据，如用户名/用户ID和密码，以验证您的身份。</p>
<p>身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用。</p>
<p><strong>“授权” （Authorization）</strong></p>
<p>授权发生在系统成功验证您的身份后，最终会授予您访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。</p>
<p>这个概念是通用的，而不是只在Spring Security 中存在。</p>
<h2 id="认证和授权">认证和授权</h2>
<p>目前，我们的测试环境，是谁都可以访问的，我们使用 Spring Security 增加上认证和授权的功能</p>
<p>1、引入 Spring Security 模块</p>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、编写 Spring Security 配置类</p>
<p>参考官网：https://spring.io/projects/spring-security</p>
<p>查看我们自己项目中的版本，找到对应的帮助文档：</p>
<p>https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5#servlet-applications8.16.4</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589808847466.png" alt="" loading="lazy"></figure>
<p>3、编写基础配置类</p>
<pre><code class="language-java">package com.totoroay.config;

import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        
    }
}
</code></pre>
<p>4、定制请求的授权规则</p>
<pre><code class="language-java">@Override
protected void configure(HttpSecurity http) throws Exception {
   // 定制请求的授权规则
   // 首页所有人可以访问
   http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()
  .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)
  .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
  .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);
}
</code></pre>
<p>5、测试一下：发现除了首页都进不去了！因为我们目前没有登录的角色，因为请求需要登录的角色拥有对应的权限才可以！</p>
<p>6、在configure()方法中加入以下配置，开启自动配置的登录功能！</p>
<pre><code class="language-java">// 开启自动配置的登录功能
// /login 请求来到登录页
// /login?error 重定向到这里表示登录失败
http.formLogin();
</code></pre>
<p>7、测试一下：发现，没有权限的时候，会跳转到登录的页面！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589808839089.png" alt="" loading="lazy"></figure>
<p>8、查看刚才登录页的注释信息；</p>
<p>我们可以定义认证规则，重写configure(AuthenticationManagerBuilder auth)方法</p>
<pre><code class="language-java">//定义认证规则
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception{

        //在内存中定义，也可以在jdbc中去拿....
        auth.inMemoryAuthentication()
                .withUser(&quot;totoroay&quot;).password(&quot;totoroay&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
                .and()
                .withUser(&quot;root&quot;).password(&quot;root&quot;).roles(&quot;vip1&quot;,&quot;vip2&quot;)
                .and()
                .withUser(&quot;guest&quot;).password(&quot;guest&quot;).roles(&quot;vip1&quot;);
    }
</code></pre>
<p>9、测试，我们可以使用这些账号登录进行测试！发现会报错！</p>
<p>There is no PasswordEncoder mapped for the id “null”</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589808831367.png" alt="" loading="lazy"></figure>
<p>10、原因，我们要将前端传过来的密码进行某种方式加密，否则就无法登录，修改代码</p>
<pre><code class="language-java">// 缓存
//定义认证规则
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception{
   //在内存中定义，也可以在jdbc中去拿....
   //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。
   //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密
   //spring security 官方推荐的是使用bcrypt加密方式。
   
   auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
          .withUser(&quot;totoroay&quot;).password(new BCryptPasswordEncoder().encode(&quot;totoroay&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
          .and()
          .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;root&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;)
          .and()
          .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;guest&quot;)).roles(&quot;vip1&quot;);
}
</code></pre>
<pre><code class="language-java">// 数据库
@Autowired
private DataSource dataSource;

@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    // ensure the passwords are encoded properly
    UserBuilder users = User.withDefaultPasswordEncoder();
    auth
        .jdbcAuthentication()
            .dataSource(dataSource)
            .withDefaultSchema()
            .withUser(users.username(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;))
            .withUser(users.username(&quot;admin&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;,&quot;ADMIN&quot;));
}
</code></pre>
<p>11、测试，发现，登录成功，并且每个角色只能访问自己认证下的规则！搞定</p>
<h2 id="权限控制和注销">权限控制和注销</h2>
<p>1、开启自动配置的注销的功能</p>
<pre><code class="language-java">//定制请求的授权规则
@Override
protected void configure(HttpSecurity http) throws Exception {
   //....
   //开启自动配置的注销的功能
      // /logout 注销请求
   http.logout();
}
</code></pre>
<p>2、我们在前端，增加一个注销的按钮，index.html 导航栏中</p>
<pre><code class="language-html">&lt;a class=&quot;item&quot; th:href=&quot;@{/logout}&quot;&gt;
   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销
&lt;/a&gt;
</code></pre>
<p>3、我们可以去测试一下，登录成功后点击注销，发现注销完毕会跳转到登录页面！</p>
<p>4、但是，我们想让他注销成功后，依旧可以跳转到首页，该怎么处理呢？</p>
<pre><code class="language-java">// .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页
http.logout().logoutSuccessUrl(&quot;/&quot;);
</code></pre>
<p>5、测试，注销完毕后，发现跳转到首页OK</p>
<p>6、我们现在又来一个需求：用户没有登录的时候，导航栏上只显示登录按钮，用户登录之后，导航栏可以显示登录的用户信息及注销按钮！还有就是，比如kuangshen这个用户，它只有 vip2，vip3功能，那么登录则只显示这两个功能，而vip1的功能菜单不显示！这个就是真实的网站情况了！该如何做呢？</p>
<p>我们需要结合thymeleaf中的一些功能</p>
<p>sec：authorize=&quot;isAuthenticated()&quot;:是否认证登录！来显示不同的页面</p>
<p>Maven依赖：</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
   &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;
   &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>7、修改我们的 前端页面</p>
<ol>
<li>导入命名空间</li>
</ol>
<pre><code>xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5&quot;
</code></pre>
<p>​		修改导航栏，增加认证判断</p>
<pre><code class="language-html">&lt;!--登录注销--&gt;
&lt;div class=&quot;right menu&quot;&gt;

   &lt;!--如果未登录--&gt;
   &lt;div sec:authorize=&quot;!isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot; th:href=&quot;@{/login}&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录
       &lt;/a&gt;
   &lt;/div&gt;

   &lt;!--如果已登录--&gt;
   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt;
          用户名：&lt;span sec:authentication=&quot;principal.username&quot;&gt;&lt;/span&gt;
          角色：&lt;span sec:authentication=&quot;principal.authorities&quot;&gt;&lt;/span&gt;
       &lt;/a&gt;
   &lt;/div&gt;

   &lt;div sec:authorize=&quot;isAuthenticated()&quot;&gt;
       &lt;a class=&quot;item&quot; th:href=&quot;@{/logout}&quot;&gt;
           &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 注销
       &lt;/a&gt;
   &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>8、重启测试，我们可以登录试试看，登录成功后确实，显示了我们想要的页面；</p>
<p>9、如果注销404了，就是因为它默认防止csrf跨站请求伪造，因为会产生安全问题，我们可以将请求改为post表单提交，或者在spring security中关闭csrf功能；我们试试：在 配置中增加 <code>http.csrf().disable();</code></p>
<pre><code class="language-java">http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求
http.logout().logoutSuccessUrl(&quot;/&quot;);
</code></pre>
<p>10、我们继续将下面的角色功能块认证完成！</p>
<pre><code class="language-html">&lt;!-- sec:authorize=&quot;hasRole('vip1')&quot; --&gt;
&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole('vip1')&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 1&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level1/1}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level1/2}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level1/3}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-1-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole('vip2')&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 2&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level2/1}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level2/2}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level2/3}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-2-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;column&quot; sec:authorize=&quot;hasRole('vip3')&quot;&gt;
   &lt;div class=&quot;ui raised segment&quot;&gt;
       &lt;div class=&quot;ui&quot;&gt;
           &lt;div class=&quot;content&quot;&gt;
               &lt;h5 class=&quot;content&quot;&gt;Level 3&lt;/h5&gt;
               &lt;hr&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level3/1}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-1&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level3/2}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-2&lt;/a&gt;&lt;/div&gt;
               &lt;div&gt;&lt;a th:href=&quot;@{/level3/3}&quot;&gt;&lt;i class=&quot;bullhorn icon&quot;&gt;&lt;/i&gt; Level-3-3&lt;/a&gt;&lt;/div&gt;
           &lt;/div&gt;
       &lt;/div&gt;
   &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>11、测试一下！</p>
<p>12、权限控制和注销搞定！</p>
<h2 id="记住我">记住我</h2>
<p>现在的情况，我们只要登录之后，关闭浏览器，再登录，就会让我们重新登录，但是很多网站的情况，就是有一个记住密码的功能，这个该如何实现呢？很简单</p>
<p>1、开启记住我功能</p>
<pre><code class="language-java">//定制请求的授权规则
@Override
protected void configure(HttpSecurity http) throws Exception {
//。。。。。。。。。。。
   //记住我
   http.rememberMe();
}
</code></pre>
<p>2、我们再次启动项目测试一下，发现登录页多了一个记住我功能，我们登录之后关闭 浏览器，然后重新打开浏览器访问，发现用户依旧存在！</p>
<p>思考：如何实现的呢？其实非常简单</p>
<p>我们可以查看浏览器的cookie</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589808811830.png" alt="" loading="lazy"></figure>
<p>3、我们点击注销的时候，可以发现，spring security 帮我们自动删除了这个 cookie</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589808804512.png" alt="" loading="lazy"></figure>
<p>4、结论：登录成功后，将cookie发送给浏览器保存，以后登录带上这个cookie，只要通过检查就可以免登录了。如果点击注销，则会删除这个cookie，具体的原理我们在JavaWeb阶段都讲过了，这里就不在多说了！</p>
<h2 id="定制登录页">定制登录页</h2>
<p>现在这个登录页面都是spring security 默认的，怎么样可以使用我们自己写的Login界面呢？</p>
<p>1、在刚才的登录页配置后面指定 loginpage</p>
<pre><code class="language-java">http.formLogin().loginPage(&quot;/toLogin&quot;);
</code></pre>
<p>2、然后前端也需要指向我们自己定义的 login请求</p>
<pre><code class="language-xml">&lt;a class=&quot;item&quot; th:href=&quot;@{/toLogin}&quot;&gt;
   &lt;i class=&quot;address card icon&quot;&gt;&lt;/i&gt; 登录
&lt;/a&gt;
</code></pre>
<p>3、我们登录，需要将这些信息发送到哪里，我们也需要配置，login.html 配置提交请求及方式，方式必须为post:</p>
<p>在 loginPage()源码中的注释上有写明：</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1589808795276.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">&lt;form th:action=&quot;@{/login}&quot; method=&quot;post&quot;&gt;
   &lt;div class=&quot;field&quot;&gt;
       &lt;label&gt;Username&lt;/label&gt;
       &lt;div class=&quot;ui left icon input&quot;&gt;
           &lt;input type=&quot;text&quot; placeholder=&quot;Username&quot; name=&quot;username&quot;&gt;
           &lt;i class=&quot;user icon&quot;&gt;&lt;/i&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;div class=&quot;field&quot;&gt;
       &lt;label&gt;Password&lt;/label&gt;
       &lt;div class=&quot;ui left icon input&quot;&gt;
           &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
           &lt;i class=&quot;lock icon&quot;&gt;&lt;/i&gt;
       &lt;/div&gt;
   &lt;/div&gt;
   &lt;input type=&quot;submit&quot; class=&quot;ui blue submit button&quot;/&gt;
&lt;/form&gt;
</code></pre>
<p>4、这个请求提交上来，我们还需要验证处理，怎么做呢？我们可以查看formLogin()方法的源码！我们配置接收登录的用户名和密码的参数！</p>
<pre><code class="language-java">http.formLogin()
  .usernameParameter(&quot;username&quot;)
  .passwordParameter(&quot;password&quot;)
  .loginPage(&quot;/toLogin&quot;)
  .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求
</code></pre>
<p>5、在登录页增加记住我的多选框</p>
<pre><code class="language-html">&lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; 记住我
</code></pre>
<p>6、后端验证处理！</p>
<pre><code class="language-java">//定制记住我的参数！
http.rememberMe().rememberMeParameter(&quot;remember&quot;);
</code></pre>
<p>7、测试，OK</p>
<h2 id="完整配置代码">完整配置代码</h2>
<pre><code class="language-java">package com.totoroay.config;

import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

   //定制请求的授权规则
   @Override
   protected void configure(HttpSecurity http) throws Exception {

       http.authorizeRequests().antMatchers(&quot;/&quot;).permitAll()
      .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)
      .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
      .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);


       //开启自动配置的登录功能：如果没有权限，就会跳转到登录页面！
           // /login 请求来到登录页
           // /login?error 重定向到这里表示登录失败
       http.formLogin()
          .usernameParameter(&quot;username&quot;)
          .passwordParameter(&quot;password&quot;)
          .loginPage(&quot;/toLogin&quot;)
          .loginProcessingUrl(&quot;/login&quot;); // 登陆表单提交请求

       //开启自动配置的注销的功能
           // /logout 注销请求
           // .logoutSuccessUrl(&quot;/&quot;); 注销成功来到首页

       http.csrf().disable();//关闭csrf功能:跨站请求伪造,默认只能通过post方式提交logout请求
       http.logout().logoutSuccessUrl(&quot;/&quot;);

       //记住我
       http.rememberMe().rememberMeParameter(&quot;remember&quot;);
  }

   //定义认证规则
   @Override
   protected void configure(AuthenticationManagerBuilder auth) throws Exception {
       //在内存中定义，也可以在jdbc中去拿....
       //Spring security 5.0中新增了多种加密方式，也改变了密码的格式。
       //要想我们的项目还能够正常登陆，需要修改一下configure中的代码。我们要将前端传过来的密码进行某种方式加密
       //spring security 官方推荐的是使用bcrypt加密方式。

       auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
              .withUser(&quot;totoroay&quot;).password(new BCryptPasswordEncoder().encode(&quot;totoroay&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
              .and()
              .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;root&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;)
              .and()
              .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;guest&quot;)).roles(&quot;vip1&quot;);
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot11：整合MyBatis]]></title>
        <id>https://totoroay.github.io/post/springboot11zheng-he-mybatis/</id>
        <link href="https://totoroay.github.io/post/springboot11zheng-he-mybatis/">
        </link>
        <updated>2020-05-15T13:35:14.000Z</updated>
        <content type="html"><![CDATA[<p>官方文档：http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</p>
<p>Maven仓库地址：https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/2.1.1</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589549768349.png" alt="" loading="lazy"></figure>
<h2 id="整合测试">整合测试</h2>
<p>1、导入 MyBatis 所需要的依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.21&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、配置数据库连接信息（不变）</p>
<pre><code class="language-yml">spring:
  datasource:
    username: root
    password: root
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #Spring Boot 默认是不注入这些属性值的，需要自己绑定
    #druid 数据源专有配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true

    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入
    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority
    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500

# 整合mybatis
mybatis:
  type-aliases-package: com.totoroay.pojo
  mapper-locations: classpath:mapper/*.xml
</code></pre>
<p><strong>3、测试数据库是否连接成功！</strong></p>
<p><strong>4、创建实体类，导入 Lombok！</strong></p>
<p>User.java</p>
<pre><code class="language-java">package com.totoroay.pojo;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    private Integer id;
    private String name;
    private String pwd;

}
</code></pre>
<p><strong>5、创建mapper目录以及对应的 Mapper 接口</strong></p>
<p>UserMapper.java</p>
<pre><code class="language-java">//@Mapper : 表示本类是一个 MyBatis 的 Mapper
@Mapper
@Repository
public interface UserMapper {
	// 获取所有用户信息
    List&lt;User&gt; queryUserList();

    // 通过id获得用户
    User queryUserById(Integer id);

    int addUser(User user);
    int updateUser(User user);
    int deleteUser(Integer id);
}
</code></pre>
<p><strong>6、对应的Mapper映射文件</strong></p>
<p>UserMapper.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.totoroay.mapper.UserMapper&quot;&gt;

    &lt;select id=&quot;queryUserList&quot; resultType=&quot;com.totoroay.pojo.User&quot;&gt;
        select * from user
    &lt;/select&gt;

    &lt;select id=&quot;queryUserById&quot; resultType=&quot;com.totoroay.pojo.User&quot;&gt;
        select * from user where id = #{id}
    &lt;/select&gt;

    &lt;insert id=&quot;addUser&quot;&gt;
        insert into user (id, name, pwd) values (#{id}, #{name}, #{pwd});
    &lt;/insert&gt;

    &lt;update id=&quot;updateUser&quot;&gt;
        update user set name = #{name}, pwd = #{pwd} where id = #{id};
    &lt;/update&gt;

    &lt;delete id=&quot;deleteUser&quot;&gt;
        delete from user where id = #{id}
    &lt;/delete&gt;

&lt;/mapper&gt;
</code></pre>
<p><strong>7、编写的 UserController 进行测试（实际开发中需要写service层）</strong></p>
<pre><code class="language-java">@RestController
public class UserController {
    @Resource
    private UserMapper userMapper;

    @GetMapping(&quot;/queryUserList&quot;)
    public List&lt;User&gt; queryUserList(){
        List&lt;User&gt; userList = userMapper.queryUserList();
        for (User user : userList) {
            System.out.println(user);
        }
        return userList;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ SpringBoot10：整合JDBC、Druid]]></title>
        <id>https://totoroay.github.io/post/springboot10zheng-he-jdbcdruid/</id>
        <link href="https://totoroay.github.io/post/springboot10zheng-he-jdbcdruid/">
        </link>
        <updated>2020-05-15T11:42:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="springdata简介">SpringData简介</h2>
<p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p>
<p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p>
<p>Sping Data 官网：https://spring.io/projects/spring-data</p>
<p>数据库相关的启动器 ：可以参考官方文档：</p>
<p>https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</p>
<h2 id="整合jdbc">整合JDBC</h2>
<h3 id="创建测试项目测试数据源">创建测试项目测试数据源</h3>
<p>1、我去新建一个项目测试：springboot-data-jdbc ; 引入相应的模块！基础模块</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589543058422.png" alt="" loading="lazy"></figure>
<p>2、项目建好之后，发现自动帮我们导入了如下的启动器：</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>3、编写yaml配置文件连接数据库；</p>
<pre><code class="language-yaml">spring:
  datasource:
    username: root
    password: root
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
</code></pre>
<p>4、配置完这一些东西后，我们就可以直接去使用了，因为SpringBoot已经默认帮我们进行了自动配置；去测试类测试一下</p>
<pre><code class="language-java">@SpringBootTest
class Springboot05DataApplicationTests {
    @Autowired
    DataSource dataSource;

    @Test
    void contextLoads() throws SQLException {
        //看一下默认数据源
        System.out.println(dataSource.getClass());
        //获得连接
        Connection connection = dataSource.getConnection();
        System.out.println(connection);
        //关闭连接
        connection.close();
    }

}
</code></pre>
<p>结果：我们可以看到他默认给我们配置的数据源为 : class com.zaxxer.hikari.HikariDataSource ， 我们并没有手动配置</p>
<p>我们来全局搜索一下，找到数据源的所有自动配置都在 ：DataSourceAutoConfiguration文件：</p>
<pre><code class="language-java">@Import(
    {Hikari.class, Tomcat.class, Dbcp2.class, Generic.class, DataSourceJmxConfiguration.class}
)
protected static class PooledDataSourceConfiguration {
    protected PooledDataSourceConfiguration() {
    }
}
</code></pre>
<p>这里导入的类都在 DataSourceConfiguration 配置类下，可以看出 Spring Boot 2.2.5 默认使用HikariDataSource 数据源，而以前版本，如 Spring Boot 1.5 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源；</p>
<p><strong>HikariDataSource 号称 Java WEB 当前速度最快的数据源，相比于传统的 C3P0 、DBCP、Tomcat jdbc 等连接池更加优秀；</strong></p>
<p><strong>可以使用 spring.datasource.type 指定自定义的数据源类型，值为 要使用的连接池实现的完全限定名。</strong></p>
<p>关于数据源我们并不做介绍，有了数据库连接，显然就可以 CRUD 操作数据库了。但是我们需要先了解一个对象 JdbcTemplate</p>
<h3 id="jdbctemplate">JDBCTemplate</h3>
<p>1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用原生的 JDBC 语句来操作数据库；</p>
<p>2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即JdbcTemplate。</p>
<p>3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p>
<p>4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p>
<p>5、JdbcTemplate 的自动配置是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 JdbcTemplateConfiguration 类</p>
<p><strong>JdbcTemplate主要提供以下几类方法：</strong></p>
<ul>
<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>
<li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li>
<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>
<li>call方法：用于执行存储过程、函数相关语句。</li>
</ul>
<h3 id="测试">测试</h3>
<p>编写一个Controller，注入 jdbcTemplate，编写测试方法进行访问测试；</p>
<pre><code class="language-java">package com.totoroay.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Date;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping(&quot;/jdbc&quot;)
public class JdbcController {

    /**
     * Spring Boot 默认提供了数据源，默认提供了 org.springframework.jdbc.core.JdbcTemplate
     * JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作
     * 还能避免一些常见的错误,使用起来也不用再自己来关闭数据库连接
     */
    @Autowired
    JdbcTemplate jdbcTemplate;

    //查询employee表中所有数据
    //List 中的1个 Map 对应数据库的 1行数据
    //Map 中的 key 对应数据库的字段名，value 对应数据库的字段值
    @GetMapping(&quot;/userList&quot;)
    public List&lt;Map&lt;String, Object&gt;&gt; userList(){
        String sql = &quot;select * from user&quot;;
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);
        return maps;
    }
    
    //新增一个用户
    @GetMapping(&quot;/add&quot;)
    public String addUser(){
        //插入语句，注意时间问题
        String sql = &quot;insert into user(id, name, pwd) values (8, 'shabi', 'shabi')&quot;;
        jdbcTemplate.update(sql);
        //查询
        return &quot;addOk&quot;;
    }

    //修改用户信息
    @GetMapping(&quot;/update/{id}&quot;)
    public String updateUser(@PathVariable(&quot;id&quot;) int id){
        //插入语句
        String sql = &quot;update user set name=?, pwd=? where id=&quot;+id;
        //数据
        Object[] objects = new Object[2];
        objects[0] = &quot;shabilibili&quot;;
        objects[1] = &quot;shabilibili&quot;;
        jdbcTemplate.update(sql,objects);
        //查询
        return &quot;updateOk&quot;;
    }

    //删除用户
    @GetMapping(&quot;/delete/{id}&quot;)
    public String delUser(@PathVariable(&quot;id&quot;) int id){
        //插入语句
        String sql = &quot;delete from user where id=?&quot;;
        jdbcTemplate.update(sql,id);
        //查询
        return &quot;deleteOk&quot;;
    }
    
}
</code></pre>
<p>测试请求，结果正常；</p>
<p>到此，CURD的基本操作，使用 JDBC 就搞定了。</p>
<h2 id="druid">Druid</h2>
<h3 id="druid简介">Druid简介</h3>
<p>Java程序很大一部分要操作数据库，为了提高性能操作数据库的时候，又不得不使用数据库连接池。</p>
<p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP 等 DB 池的优点，同时加入了日志监控。</p>
<p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p>
<p>Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。</p>
<p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p>
<p>Github地址：https://github.com/alibaba/druid/</p>
<p><strong>com.alibaba.druid.pool.DruidDataSource 基本配置参数如下：</strong></p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589543035853.png" alt="" loading="lazy"></figure>
<h3 id="配置数据源">配置数据源</h3>
<p>1、添加上 Druid 数据源依赖。</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.21&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>2、切换数据源；之前已经说过 Spring Boot 2.0 以上默认使用 com.zaxxer.hikari.HikariDataSource 数据源，但可以 通过 spring.datasource.type 指定数据源</p>
<pre><code class="language-yml">spring:
  datasource:
    username: root
    password: root
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource # 自定义数据源
</code></pre>
<p>3、数据源切换之后，在测试类中注入 DataSource，然后获取到它，输出一看便知是否成功切换；</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589543023867.png" alt="" loading="lazy"></figure>
<p>4、切换成功！既然切换成功，就可以设置数据源连接初始化大小、最大连接数、等待时间、最小连接数 等设置项；可以查看源码</p>
<pre><code class="language-yml">spring:
  datasource:
    username: root
    password: 123456
    #?serverTimezone=UTC解决时区的报错
    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #Spring Boot 默认是不注入这些属性值的，需要自己绑定
    #druid 数据源专有配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true

    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入
    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority
    #则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500
</code></pre>
<p>5、导入Log4j 的依赖</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>6、现在需要程序员自己为 DruidDataSource 绑定全局配置文件中的参数，再添加到容器中，而不再使用 Spring Boot 的自动生成了；我们需要 自己添加 DruidDataSource 组件到容器中，并绑定属性；</p>
<pre><code class="language-java">package com.totoroay.config;

import com.alibaba.druid.pool.DruidDataSource;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class DruidConfig {

    /*
       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建
       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效
       @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中
       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中
     */
    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    @Bean
    public DataSource druidDataSource() {
        return new DruidDataSource();
    }

}
</code></pre>
<p>7、去测试类中测试一下；看是否成功！</p>
<pre><code class="language-java">@SpringBootTest
class Springboot05DataApplicationTests {

    //DI注入数据源
    @Autowired
    DataSource dataSource;

    @Test
    public void contextLoads() throws SQLException {
        //看一下默认数据源
        System.out.println(dataSource.getClass());
        //获得连接
        Connection connection =   dataSource.getConnection();
        System.out.println(connection);

        DruidDataSource druidDataSource = (DruidDataSource) dataSource;
        System.out.println(&quot;druidDataSource 数据源最大连接数：&quot; + druidDataSource.getMaxActive());
        System.out.println(&quot;druidDataSource 数据源初始化连接数：&quot; + druidDataSource.getInitialSize());

        //关闭连接
        connection.close();
    }
}
</code></pre>
<p>输出结果 ：可见配置参数已经生效！</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589543010291.png" alt="" loading="lazy"></figure>
<h3 id="配置druid数据源监控">配置Druid数据源监控</h3>
<p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p>
<p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p>
<pre><code class="language-java">//配置 Druid 监控管理后台的Servlet；
//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式
@Bean
public ServletRegistrationBean statViewServlet() {
    ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);

    // 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet 
    // 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到
    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();
    initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;); //后台管理界面的登录账号
    initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;); //后台管理界面的登录密码

    //后台允许谁可以访问
    //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问
    //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问
    initParams.put(&quot;allow&quot;, &quot;&quot;);
    //deny：Druid 后台拒绝谁访问
    //initParams.put(&quot;kuangshen&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问

    //设置初始化参数
    bean.setInitParameters(initParams);
    return bean;
}
</code></pre>
<p>配置完毕后，我们可以选择访问 ：http://localhost:8080/druid/login.html</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589543000151.png" alt="" loading="lazy"></figure>
<p><strong>配置 Druid web 监控 filter 过滤器</strong></p>
<pre><code class="language-java">//配置 Druid 监控 之  web 监控的 filter
//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计
@Bean
public FilterRegistrationBean webStatFilter() {
    FilterRegistrationBean bean = new FilterRegistrationBean();
    bean.setFilter(new WebStatFilter());

    //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计
    Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();
    initParams.put(&quot;exclusions&quot;, &quot;*.js, *.css, /druid/*, /jdbc/*&quot;);
    bean.setInitParameters(initParams);

    //&quot;/*&quot; 表示过滤所有请求
    bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));
    return bean;
}
</code></pre>
<p>平时在工作中，按需求进行配置即可，主要用作监控！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot09：页面国际化]]></title>
        <id>https://totoroay.github.io/post/springboot09ye-mian-guo-ji-hua/</id>
        <link href="https://totoroay.github.io/post/springboot09ye-mian-guo-ji-hua/">
        </link>
        <updated>2020-05-13T11:02:37.000Z</updated>
        <content type="html"><![CDATA[<p>有的时候，我们的网站会去涉及中英文甚至多语言的切换，这时候我们就需要学习国际化了！</p>
<h2 id="准备工作">准备工作</h2>
<p>先在IDEA中统一设置properties的编码问题！</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589367893729.png" alt="" loading="lazy"></figure>
<p>编写国际化配置文件，抽取页面需要显示的国际化页面消息。我们可以去登录页面查看一下，哪些内容我们需要编写国际化的配置！</p>
<h2 id="配置文件编写">配置文件编写</h2>
<p>1、我们在resources资源文件下新建一个i18n目录，存放国际化配置文件</p>
<p>2、建立一个login.properties文件，还有一个login_zh_CN.properties；发现IDEA自动识别了我们要做国际化操作；文件夹自动合并了！</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589367886727.png" alt="" loading="lazy"></figure>
<p>3、我们可以在这上面去新建一个文件；</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589367880956.png" alt="" loading="lazy"></figure>
<p>弹出如下页面：我们再添加一个英文的；</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589367876189.png" alt="" loading="lazy"></figure>
<p><strong>4、接下来，我们就来编写配置，我们可以看到idea下面有另外一个视图；</strong></p>
<p>这个视图我们点击 + 号就可以直接添加属性了；我们新建一个login.tip，可以看到边上有三个文件框可以输入</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589367871076.png" alt="" loading="lazy"></figure>
<p>然后去查看我们的配置文件；</p>
<p>login.properties ：默认</p>
<pre><code class="language-properties">login.btn=登录
login.password=密码
login.remember=记住我
login.tip=请登录
login.username=用户名
</code></pre>
<p>英文：</p>
<pre><code class="language-properties">login.btn=sign in
login.password=password
login.remember=remember me
login.tip=Please sign in
login.username=username
</code></pre>
<p>中文：</p>
<pre><code class="language-properties">login.btn=登录
login.password=密码
login.remember=记住我
login.tip=请登录
login.username=用户名
</code></pre>
<p>OK，配置文件步骤搞定！</p>
<h2 id="配置文件生效探究">配置文件生效探究</h2>
<p>我们去看一下SpringBoot对国际化的自动配置！这里又涉及到一个类：MessageSourceAutoConfiguration</p>
<p>里面有一个方法，这里发现SpringBoot已经自动配置好了管理我们国际化资源文件的组件 ResourceBundleMessageSource；</p>
<pre><code class="language-java">@Bean
@ConfigurationProperties(prefix = &quot;spring.messages&quot;)
public MessageSourceProperties messageSourceProperties() {
	return new MessageSourceProperties();
}


// 获取 properties 传递过来的值进行判断
@Bean
public MessageSource messageSource(MessageSourceProperties properties) {
    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
    if (StringUtils.hasText(properties.getBasename())) {
        // 设置国际化文件的基础名（去掉语言国家代码的）
        messageSource.setBasenames(
            StringUtils.commaDelimitedListToStringArray(
                                       StringUtils.trimAllWhitespace(properties.getBasename())));
    }
    if (properties.getEncoding() != null) {
        messageSource.setDefaultEncoding(properties.getEncoding().name());
    }
    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
    Duration cacheDuration = properties.getCacheDuration();
    if (cacheDuration != null) {
        messageSource.setCacheMillis(cacheDuration.toMillis());
    }
    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
    return messageSource;
}
</code></pre>
<p>我们真实 的情况是放在了i18n目录下，所以我们要去配置这个messages的路径；</p>
<pre><code class="language-properties">spring.messages.basename=i18n/login
</code></pre>
<h2 id="配置页面国际化值">配置页面国际化值</h2>
<p>去页面获取国际化的值，查看Thymeleaf的文档，找到message取值操作为：#{...}。我们去页面测试下：</p>
<p>IDEA还有提示，非常智能的</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1589367857228.png" alt="" loading="lazy"></figure>
<p>我们可以去启动项目，访问一下，发现已经自动识别为中文的了！</p>
<figure data-type="image" tabindex="7"><img src="https://totoroay.github.io//post-images/1589367851133.png" alt="" loading="lazy"></figure>
<p><strong>但是我们想要更好！可以根据按钮自动切换中文英文！</strong></p>
<h2 id="配置国际化解析">配置国际化解析</h2>
<p>在Spring中有一个国际化的Locale （区域信息对象）；里面有一个叫做LocaleResolver （获取区域信息对象）的解析器！</p>
<p>我们去我们WebMvcAutoConfiguration自动配置文件，寻找一下！看到SpringBoot默认配置：</p>
<pre><code class="language-java">@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)
public LocaleResolver localeResolver() {
    // 容器中没有就自己配，有的话就用用户配置的
    if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {
        return new FixedLocaleResolver(this.mvcProperties.getLocale());
    }
    // 接收头国际化分解
    AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
    localeResolver.setDefaultLocale(this.mvcProperties.getLocale());
    return localeResolver;
}
</code></pre>
<p>AcceptHeaderLocaleResolver 这个类中有一个方法</p>
<pre><code class="language-java">public Locale resolveLocale(HttpServletRequest request) {
    Locale defaultLocale = this.getDefaultLocale();
    // 默认的就是根据请求头带来的区域信息获取Locale进行国际化
    if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) {
        return defaultLocale;
    } else {
        Locale requestLocale = request.getLocale();
        List&lt;Locale&gt; supportedLocales = this.getSupportedLocales();
        if (!supportedLocales.isEmpty() &amp;&amp; !supportedLocales.contains(requestLocale)) {
            Locale supportedLocale = this.findSupportedLocale(request, supportedLocales);
            if (supportedLocale != null) {
                return supportedLocale;
            } else {
                return defaultLocale != null ? defaultLocale : requestLocale;
            }
        } else {
            return requestLocale;
        }
    }
}
</code></pre>
<p>那假如我们现在想点击链接让我们的国际化资源生效，就需要让我们自己的Locale生效！</p>
<p>我们去自己写一个自己的LocaleResolver，可以在链接上携带区域信息！</p>
<p>修改一下前端页面的跳转连接：</p>
<pre><code class="language-html">&lt;!-- 这里传入参数不需要使用 ？使用 （key=value）--&gt;
&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html(language='zh_CN')}&quot;&gt;中文&lt;/a&gt;
&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html(language='en_US')}&quot;&gt;English&lt;/a&gt;
</code></pre>
<p>我们去写一个处理的组件类！</p>
<pre><code class="language-java">package com.totoroay.config;

import org.springframework.util.StringUtils;
import org.springframework.web.servlet.LocaleResolver;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Locale;

public class MyLocaleResolver implements LocaleResolver {
    // 解析请求
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        // 获取请求中的语言参数
        String language = request.getParameter(&quot;language&quot;);
        // 默认
        Locale locale = Locale.getDefault();
        // 如果请求中的链接携带了国际化的参数
        if (!StringUtils.isEmpty(language)) {
            // zh_CN
            String[] split = language.split(&quot;_&quot;);
            // 国家，地区
            locale = new Locale(split[0], split[1]);
        }
        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {

    }
}
</code></pre>
<p>为了让我们的区域化信息能够生效，我们需要再配置一下这个组件！在我们自己的MyMvcConfig下添加bean；</p>
<pre><code class="language-java">// 自定义国际化组件
@Bean
public LocaleResolver localeResolver(){
    return new MyLocaleResolver();
}
</code></pre>
<p><strong>我们重启项目，来访问一下，发现点击按钮可以实现成功切换！搞定收工！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[外观模式]]></title>
        <id>https://totoroay.github.io/post/wai-guan-mo-shi/</id>
        <link href="https://totoroay.github.io/post/wai-guan-mo-shi/">
        </link>
        <updated>2020-05-12T06:59:11.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589266822489.png" alt="" loading="lazy"></figure>
<p><strong>模式结构：主要角色</strong></p>
<ul>
<li>外观角色
<ul>
<li>为多个子系统对外提供一个共同的接口</li>
</ul>
</li>
<li>子系统角色
<ul>
<li>实现系统的部分功能，客户可以通过外观角色访问他</li>
</ul>
</li>
<li>客户角色
<ul>
<li>通过一个外观角色访问各个子系统的功能</li>
</ul>
</li>
</ul>
<pre><code class="language-java">package totoroay.facade;
// 子系统：cpu
public class CPU {
    public void startup() {
        System.out.println(&quot;cpu startup...&quot;);
    }

    public void shutdown() {
        System.out.println(&quot;cpu shutdown...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.facade;
// 子系统：memory
public class Memory {
    public void startup() {
        System.out.println(&quot;memory startup...&quot;);
    }

    public void shutdown() {
        System.out.println(&quot;memory shutdown...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.facade;
// 子系统：disk
public class Disk {
    public void startup() {
        System.out.println(&quot;disk startup...&quot;);
    }

    public void shutdown() {
        System.out.println(&quot;disk shutdown...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.facade;
// 外观角色：Computer
public class Computer {
    private CPU cpu;
    private Memory memory;
    private Disk disk;

    public Computer() {
        cpu = new CPU();
        memory = new Memory();
        disk = new Disk();
    }

    public void startup(){
        System.out.println(&quot;computer startup...&quot;);
        cpu.startup();
        memory.startup();
        disk.startup();
        System.out.println(&quot;computer start successful...&quot;);
    }

    public void shutdown() {
        System.out.println(&quot;computer shutdown...&quot;);
        cpu.shutdown();
        memory.shutdown();
        disk.shutdown();
        System.out.println(&quot;computer shutdown successful...&quot;);
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.facade;
// 客户角色：
public class ComputerFacade {
    public static void main(String[] args) {
        Computer computer = new Computer();
        computer.startup();
        System.out.println(&quot;电脑运行中...&quot;);

        computer.shutdown();
    }
}
</code></pre>
<p><strong>结果</strong></p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589266814798.png" alt="" loading="lazy"></figure>
<p><strong>结构分析</strong></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589266811218.png" alt="" loading="lazy"></figure>
<p><strong>应用场景</strong></p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589266806093.png" alt="" loading="lazy"></figure>
<p><strong>扩展：系统升级！！！</strong></p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589266801540.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[装饰模式]]></title>
        <id>https://totoroay.github.io/post/zhuang-shi-mo-shi/</id>
        <link href="https://totoroay.github.io/post/zhuang-shi-mo-shi/">
        </link>
        <updated>2020-05-12T06:56:33.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589266708394.png" alt="" loading="lazy"></figure>
<p><strong>模式结构：包含的角色</strong></p>
<ul>
<li>抽象构件角色：
<ul>
<li>定义一个抽象接口以规范准备接收附加责任的对象</li>
</ul>
</li>
<li>具体构件角色：
<ul>
<li>实现抽象构件，通过装饰角色为其添加一些职责</li>
</ul>
</li>
<li>抽象装饰角色：
<ul>
<li>继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能</li>
</ul>
</li>
<li>具体装饰角色：
<ul>
<li>实现抽象装饰的相关方法，并给具体构件对象添加附加的责任</li>
</ul>
</li>
</ul>
<pre><code class="language-java">package totoroay.decorator;
// 抽象构件：奶茶
public interface MilkTea {
    String milkTeaName();
    int milkTeaPrice();
}
</code></pre>
<pre><code class="language-java">package totoroay.decorator;
// 具体构件：珍珠奶茶
public class PearlMilkTea implements MilkTea {
    @Override
    public String milkTeaName() {
        return &quot;珍珠奶茶&quot;;
    }

    @Override
    public int milkTeaPrice() {
        return 10;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.decorator;
// 具体构件：港式奶茶
public class HongKongMilkTea implements MilkTea {
    @Override
    public String milkTeaName() {
        return &quot;港式奶茶&quot;;
    }

    @Override
    public int milkTeaPrice() {
        return 12;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.decorator;
// 抽象装饰：奶茶口味
public abstract class Taste implements MilkTea {
    @Override
    public String milkTeaName() {
        return null;
    }

    @Override
    public int milkTeaPrice() {
        return 0;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.decorator;
// 具体装饰：加椰果
public class AddYeGuoTaste extends Taste {
    private String description = &quot;加椰果&quot;;
    private MilkTea milkTea;

    public AddYeGuoTaste(MilkTea milkTea) {
        this.milkTea = milkTea;
    }

    @Override
    public String milkTeaName() {
        return milkTea.milkTeaName() + &quot;  &quot; + description;
    }

    @Override
    public int milkTeaPrice() {
        return milkTea.milkTeaPrice()+2;
    }
}
</code></pre>
<pre><code class="language-java">package totoroay.decorator;
// 具体装饰：加布丁
public class AddBuDingTaste extends Taste {
    private String description = &quot;加布丁&quot;;
    private MilkTea milkTea;

    public AddBuDingTaste(MilkTea milkTea) {
        this.milkTea = milkTea;
    }

    @Override
    public String milkTeaName() {
        return milkTea.milkTeaName() + &quot;  &quot; + description;
    }

    @Override
    public int milkTeaPrice() {
        return milkTea.milkTeaPrice()+2;
    }
}
</code></pre>
<p><strong>测试</strong></p>
<pre><code class="language-java">package totoroay.decorator;

public class test {
    public static void main(String[] args) {
        MilkTea pearlMilkTea = new PearlMilkTea();
        System.out.println(pearlMilkTea.milkTeaName()+&quot;  &quot;+pearlMilkTea.milkTeaPrice());
        MilkTea hongKongMilkTea = new HongKongMilkTea();
        System.out.println(hongKongMilkTea.milkTeaName()+&quot;  &quot;+hongKongMilkTea.milkTeaPrice());

        System.out.println(&quot;============&quot;);
        AddYeGuoTaste addYeGuoTaste = new AddYeGuoTaste(pearlMilkTea);
        System.out.println(addYeGuoTaste.milkTeaName()+&quot;  &quot;+addYeGuoTaste.milkTeaPrice());
        AddBuDingTaste addBuDingTaste = new AddBuDingTaste(hongKongMilkTea);
        System.out.println(addBuDingTaste.milkTeaName()+&quot;  &quot;+addBuDingTaste.milkTeaPrice());
    }
}
</code></pre>
<p><strong>结果</strong></p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589266697409.png" alt="" loading="lazy"></figure>
<p><strong>结构分析</strong></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589266693620.png" alt="" loading="lazy"></figure>
<p><strong>应用场景</strong></p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589266688028.png" alt="" loading="lazy"></figure>
<p><strong>扩展</strong></p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589266682246.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1589266673645.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot08：MVC自动配置原理]]></title>
        <id>https://totoroay.github.io/post/springboot08mvc-zi-dong-pei-zhi-yuan-li/</id>
        <link href="https://totoroay.github.io/post/springboot08mvc-zi-dong-pei-zhi-yuan-li/">
        </link>
        <updated>2020-05-10T12:50:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="官网阅读">官网阅读</h2>
<p>在进行项目编写前，我们还需要知道一个东西，就是SpringBoot对我们的SpringMVC还做了哪些配置，包括如何扩展，如何定制。</p>
<p>只有把这些都搞清楚了，我们在之后使用才会更加得心应手。途径一：源码分析，途径二：官方文档！</p>
<p>地址 ：https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</p>
<pre><code class="language-java">Spring MVC Auto-configuration
    
    
// Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。
Spring Boot provides auto-configuration for Spring MVC that works well with most applications.
// 自动配置在Spring默认设置的基础上添加了以下功能：
The auto-configuration adds the following features on top of Spring’s defaults:
// 包含视图解析器
Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.
// 支持静态资源文件夹的路径，以及webjars
Support for serving static resources, including support for WebJars 
// 自动注册了Converter：
// 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把&quot;1&quot;字符串自动转换为int类型
// Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】
Automatic registration of Converter, GenericConverter, and Formatter beans.
// HttpMessageConverters
// SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释；
Support for HttpMessageConverters (covered later in this document).
// 定义错误代码生成规则的
Automatic registration of MessageCodesResolver (covered later in this document).
// 首页定制
Static index.html support.
// 图标定制
Custom Favicon support (covered later in this document).
// 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！
Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).

/*
如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能），则可以添加自己
的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供
RequestMappingHandlerMapping、RequestMappingHandlerAdapter或ExceptionHandlerExceptionResolver的自定义
实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。
*/
If you want to keep Spring Boot MVC features and you want to add additional MVC configuration 
(interceptors, formatters, view controllers, and other features), you can add your own 
@Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide 
custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or 
ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.

// 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。
If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.
</code></pre>
<p>我们来仔细对照，看一下它怎么实现的，它告诉我们SpringBoot已经帮我们自动配置好了SpringMVC，然后自动配置了哪些东西呢？</p>
<h2 id="contentnegotiatingviewresolver-内容协商视图解析器"><strong>ContentNegotiatingViewResolver 内容协商视图解析器</strong></h2>
<p>自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器；</p>
<p>即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。</p>
<p>我们去看看这里的源码：我们找到 WebMvcAutoConfiguration ， 然后搜索ContentNegotiatingViewResolver。找到如下方法！</p>
<pre><code class="language-java">@Bean
@ConditionalOnBean(ViewResolver.class)
@ConditionalOnMissingBean(name = &quot;viewResolver&quot;, value = ContentNegotiatingViewResolver.class)
public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {
    ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
    resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class));
    // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级
    resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
    return resolver;
}
</code></pre>
<p>我们可以点进这类看看！找到对应的解析视图的代码；</p>
<pre><code class="language-java">@Nullable // 注解说明：@Nullable 即参数可为null
public View resolveViewName(String viewName, Locale locale) throws Exception {
    RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
    Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);
    List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest());
    if (requestedMediaTypes != null) {
        // 获取候选的视图对象
        List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);
        // 选择一个最适合的视图对象，然后把这个对象返回
        View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);
        if (bestView != null) {
            return bestView;
        }
    }
    // .....
}
</code></pre>
<p>我们继续点进去看，他是怎么获得候选的视图的呢？</p>
<p>getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！</p>
<pre><code> Iterator var5 = this.viewResolvers.iterator();
</code></pre>
<p>所以得出结论：<strong>ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的</strong></p>
<p>我们再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！</p>
<pre><code class="language-java">protected void initServletContext(ServletContext servletContext) {
    // 这里它是从beanFactory工具中获取容器中的所有视图解析器
    // ViewRescolver.class 把所有的视图解析器来组合的
    Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(this.obtainApplicationContext(), ViewResolver.class).values();
    ViewResolver viewResolver;
    if (this.viewResolvers == null) {
        this.viewResolvers = new ArrayList(matchingBeans.size());
    }
    // ...............
}
</code></pre>
<p>既然它是在容器中去找视图解析器，我们是否可以猜想，我们就可以去实现一个视图解析器了呢？</p>
<p>我们可以自己给容器中去添加一个视图解析器；这个类就会帮我们自动的将它组合进来；<strong>我们去实现一下</strong></p>
<p>1、我们在我们的主程序中去写一个视图解析器来试试；</p>
<pre><code class="language-java">@Bean //放到bean中
public ViewResolver myViewResolver(){
    return new MyViewResolver();
}

//我们写一个静态内部类，视图解析器就需要实现ViewResolver接口
private static class MyViewResolver implements ViewResolver{
    @Override
    public View resolveViewName(String s, Locale locale) throws Exception {
        return null;
    }
}
</code></pre>
<p>2、怎么看我们自己写的视图解析器有没有起作用呢？</p>
<p>我们给 DispatcherServlet 中的 doDispatch方法 加个断点进行调试一下，因为所有的请求都会走到这个方法中</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589115089253.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589115082896.png" alt="" loading="lazy"></figure>
<p>所以说，我们如果想要使用自己定制化的东西，我们只需要给容器中添加这个组件就好了！剩下的事情SpringBoot就会帮我们做了！</p>
<h2 id="转换器和格式化器">转换器和格式化器</h2>
<p>在WebMvcAutoConfiguration.java中找到格式化转换器：</p>
<pre><code class="language-java">@Bean
@Override
public FormattingConversionService mvcConversionService() {
    // 拿到配置文件中的格式化规则
    WebConversionService conversionService = 
        new WebConversionService(this.mvcProperties.getDateFormat());
    addFormatters(conversionService);
    return conversionService;
}
</code></pre>
<p>点击去：</p>
<pre><code class="language-java">public String getDateFormat() {
    return this.dateFormat;
}

/**
* Date format to use. For instance, `dd/MM/yyyy`. 默认的
 */
private String dateFormat;
</code></pre>
<p>可以看到在我们的Properties文件中，我们可以进行自动配置它！</p>
<p>如果配置了自己的格式化方式，就会注册到Bean中生效，我们可以在配置文件中配置日期格式化的规则：</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589115073930.png" alt="" loading="lazy"></figure>
<p>其余的就不一一举例了，大家可以下去多研究探讨即可！</p>
<h2 id="修改springboot的默认配置">修改SpringBoot的默认配置</h2>
<p>这么多的自动配置，原理都是一样的，通过这个WebMVC的自动配置原理分析，我们要学会一种学习方式，通过源码探究，得出结论；这个结论一定是属于自己的，而且一通百通。</p>
<p>SpringBoot的底层，大量用到了这些设计细节思想，所以，没事需要多阅读源码！得出结论；</p>
<p>SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（如果用户自己配置@bean），如果有就用用户配置的，如果没有就用自动配置的；</p>
<p>如果有些组件可以存在多个，比如我们的视图解析器，就将用户配置的和自己默认的组合起来！</p>
<p><strong>扩展使用SpringMVC</strong>  官方文档如下：</p>
<p>If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.</p>
<p>我们要做的就是编写一个@Configuration注解类，并且类型要为WebMvcConfigurer，还不能标注@EnableWebMvc注解；我们去自己写一个；我们新建一个包叫config，写一个类MyMvcConfig；</p>
<pre><code class="language-java">// 应为类型要求为WebMvcConfigurer，所以我们实现其接口
// 可以使用自定义类扩展MVC的功能
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // 浏览器发送/test ， 就会跳转到test页面；
        registry.addViewController(&quot;/totoroay&quot;).setViewName(&quot;test&quot;);
    }
}
</code></pre>
<p>我们去浏览器访问一下：</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589115065920.png" alt="" loading="lazy"></figure>
<p><strong>确实也跳转过来了！所以说，我们要扩展SpringMVC，官方就推荐我们这么去使用，既保SpringBoot留所有的自动配置，也能用我们扩展的配置！</strong></p>
<p>我们可以去分析一下原理：</p>
<p>1、WebMvcAutoConfiguration 是 SpringMVC的自动配置类，里面有一个类WebMvcAutoConfigurationAdapter</p>
<p>2、这个类上有一个注解，在做其他自动配置时会导入：@Import(EnableWebMvcConfiguration.class)</p>
<p>3、我们点进EnableWebMvcConfiguration这个类看一下，它继承了一个父类：DelegatingWebMvcConfiguration</p>
<p>这个父类中有这样一段代码：</p>
<pre><code class="language-java">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();
    
  // 从容器中获取所有的webmvcConfigurer
    @Autowired(required = false)
    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {
        if (!CollectionUtils.isEmpty(configurers)) {
            this.configurers.addWebMvcConfigurers(configurers);
        }
    }
}
</code></pre>
<p>4、我们可以在这个类中去寻找一个我们刚才设置的viewController当做参考，发现它调用了一个</p>
<pre><code class="language-java">protected void addViewControllers(ViewControllerRegistry registry) {
    this.configurers.addViewControllers(registry);
}
</code></pre>
<p>5、我们点进去看一下</p>
<pre><code class="language-java">public void addViewControllers(ViewControllerRegistry registry) {
    Iterator var2 = this.delegates.iterator();

    while(var2.hasNext()) {
        // 将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的
        WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();
        delegate.addViewControllers(registry);
    }

}
</code></pre>
<p>所以得出结论：所有的WebMvcConfiguration都会被作用，不止Spring自己的配置类，我们自己的配置类当然也会被调用；</p>
<h2 id="全面接管springmvc">全面接管SpringMVC</h2>
<p>官方文档：</p>
<pre><code>If you want to take complete control of Spring MVC
you can add your own @Configuration annotated with @EnableWebMvc.
</code></pre>
<p>全面接管即：SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己去配置！</p>
<p>只需在我们的配置类中要加一个@EnableWebMvc。</p>
<p>我们看下如果我们全面接管了SpringMVC了，我们之前SpringBoot给我们配置的静态资源映射一定会无效，我们可以去测试一下；</p>
<p>不加注解之前，访问首页：</p>
<figure data-type="image" tabindex="5"><img src="https://totoroay.github.io//post-images/1589115054327.png" alt="" loading="lazy"></figure>
<p>给配置类加上注解再重启：@EnableWebMvc</p>
<figure data-type="image" tabindex="6"><img src="https://totoroay.github.io//post-images/1589115048051.png" alt="" loading="lazy"></figure>
<p>我们发现所有的SpringMVC自动配置都失效了！回归到了最初的样子；</p>
<p><strong>当然，我们开发中，不推荐使用全面接管SpringMVC</strong></p>
<p>思考问题？为什么加了一个注解，自动配置就失效了！我们看下源码：</p>
<p>1、这里发现它是导入了一个类，我们可以继续进去看</p>
<pre><code class="language-java">@Import({DelegatingWebMvcConfiguration.class})
public @interface EnableWebMvc {
}
</code></pre>
<p>2、它继承了一个父类 WebMvcConfigurationSupport</p>
<pre><code class="language-java">public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport {
  // ......
}
</code></pre>
<p>3、我们来回顾一下Webmvc自动配置类</p>
<pre><code class="language-java">@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
// 这个注解的意思就是：容器中没有这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
    ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {
    
}
</code></pre>
<p>总结一句话：@EnableWebMvc将WebMvcConfigurationSupport组件导入进来了；</p>
<p>而导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能！</p>
<p><strong>在SpringBoot中会有非常多的扩展配置，只要看见了这个，我们就应该多留心注意~</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：声明事务]]></title>
        <id>https://totoroay.github.io/post/springsheng-ming-shi-wu/</id>
        <link href="https://totoroay.github.io/post/springsheng-ming-shi-wu/">
        </link>
        <updated>2020-05-10T03:18:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="声明式事务">声明式事务</h2>
<ul>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
<li>事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。</li>
</ul>
<p><mark>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</mark></p>
<p><strong>事务四个属性ACID</strong></p>
<ol>
<li>
<p>原子性（atomicity）</p>
</li>
<li>
<ul>
<li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</li>
</ul>
</li>
<li>
<p>一致性（consistency）</p>
</li>
<li>
<ul>
<li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</li>
</ul>
</li>
<li>
<p>隔离性（isolation）</p>
</li>
<li>
<ul>
<li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li>
</ul>
</li>
<li>
<p>持久性（durability）</p>
</li>
<li>
<ul>
<li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</li>
</ul>
</li>
</ol>
<h2 id="测试">测试</h2>
<p>将上面的代码拷贝到一个新项目中</p>
<p>在之前的案例中，我们给userDao接口新增两个方法，删除和增加用户；</p>
<pre><code class="language-java">//添加一个用户
int addUser(User user);

//根据id删除用户
int deleteUser(int id);
</code></pre>
<p>mapper文件，我们故意把 deletes 写错，测试！</p>
<pre><code class="language-java">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.totoroay.pojo.User&quot;&gt;
insert into user (id,name,pwd) values (#{id},#{name},#{pwd})
&lt;/insert&gt;

&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
deletes from user where id = #{id}
&lt;/delete
</code></pre>
<p>编写接口的实现类，在实现类中，我们去操作一波</p>
<pre><code class="language-java">public class UserDaoImpl extends SqlSessionDaoSupport implementsUserMapper {

   //增加一些操作
   public List&lt;User&gt; selectUser() {
       User user = new User(4,&quot;小明&quot;,&quot;123456&quot;);
       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
       mapper.addUser(user);
       mapper.deleteUser(4);
       return mapper.selectUser();
  }

   //新增
   public int addUser(User user) {
       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
       return mapper.addUser(user);
  }
   //删除
   public int deleteUser(int id) {
       UserMapper mapper = getSqlSession().getMapper(UserMapper.class);
       return mapper.deleteUser(id);
  }

}
</code></pre>
<p>测试：</p>
<pre><code class="language-java">@Test
public void test2(){
   ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);
   List&lt;User&gt; user = mapper.selectUser();
   System.out.println(user);
}
</code></pre>
<p>报错：sql异常，delete写错了</p>
<p>结果 ：插入成功！</p>
<p>没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要==<strong>事务！</strong>==</p>
<p>以前我们都需要自己手动管理事务，十分麻烦！</p>
<p>但是Spring给我们提供了事务管理，我们只需要配置即可；</p>
<h2 id="spring中的事务管理">Spring中的事务管理</h2>
<p>Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。</p>
<p><strong>编程式事务管理</strong></p>
<ul>
<li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li>
<li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li>
</ul>
<p><strong>声明式事务管理</strong></p>
<ul>
<li>一般情况下比编程式事务好用。</li>
<li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li>
<li>将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理。</li>
</ul>
<p><strong>使用Spring管理事务，注意头文件的约束导入 : tx</strong></p>
<pre><code class="language-xml">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;

http://www.springframework.org/schema/tx
http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
</code></pre>
<p><strong>事务管理器</strong></p>
<ul>
<li>无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</li>
<li>就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。</li>
</ul>
<p><strong>JDBC事务</strong></p>
<pre><code class="language-xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
</code></pre>
<p><strong>配置好事务管理器后我们需要去配置事务的通知</strong></p>
<pre><code class="language-xml">&lt;!--配置事务通知--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
   &lt;tx:attributes&gt;
       &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;
       &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
       &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
       &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
       &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt;
       &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt;
       &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
   &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<p><strong>spring事务传播特性：</strong></p>
<p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为：</p>
<ul>
<li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li>
<li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li>
<li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li>
<li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li>
<li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作</li>
</ul>
<p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p>
<p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p>
<p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p>
<p><strong>配置AOP</strong></p>
<p>导入aop的头文件！</p>
<pre><code class="language-xml">&lt;!--配置aop织入事务--&gt;
&lt;aop:config&gt;
   &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.totoroay.dao.*.*(..))&quot;/&gt;
   &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
<p><strong>进行测试</strong></p>
<p>删掉刚才插入的数据，再次测试！</p>
<pre><code class="language-java">@Test
public void test2(){
   ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
   UserMapper mapper = (UserMapper) context.getBean(&quot;userDao&quot;);
   List&lt;User&gt; user = mapper.selectUser();
   System.out.println(user);
}
</code></pre>
<blockquote>
<p>思考问题？</p>
</blockquote>
<p>为什么需要配置事务？</p>
<ul>
<li>如果不配置，就需要我们手动提交控制事务；</li>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ SpringBoot07：Thymeleaf模板引擎]]></title>
        <id>https://totoroay.github.io/post/springboot07thymeleaf-mo-ban-yin-qing/</id>
        <link href="https://totoroay.github.io/post/springboot07thymeleaf-mo-ban-yin-qing/">
        </link>
        <updated>2020-05-09T13:11:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="thymeleaf">Thymeleaf</h2>
<p>前端交给我们的页面，是html页面。如果是我们以前开发，我们需要把他们转成jsp页面，jsp好处就是当我们查出一些数据转发到JSP页面以后，我们可以用jsp轻松实现数据的显示，及交互等。</p>
<p>jsp支持非常强大的功能，包括能写Java代码，但是呢，我们现在的这种情况，SpringBoot这个项目首先是以jar的方式，不是war，像第二，我们用的还是嵌入式的Tomcat，所以呢，<strong>他现在默认是不支持jsp的</strong>。</p>
<p>那不支持jsp，如果我们直接用纯静态页面的方式，那给我们开发会带来非常大的麻烦，那怎么办呢？</p>
<p><strong>SpringBoot推荐你可以来使用模板引擎：</strong></p>
<p>模板引擎，我们其实大家听到很多，其实jsp就是一个模板引擎，还有用的比较多的freemarker，包括SpringBoot给我们推荐的Thymeleaf，模板引擎有非常多，但再多的模板引擎，他们的思想都是一样的，什么样一个思想呢我们来看一下这张图：</p>
<p><img src="https://totoroay.github.io//post-images/1589030049112.png" alt="" loading="lazy"><br>
模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他的这个语法更简单。而且呢，功能更强大。</p>
<p>我们呢，就来看一下这个模板引擎，那既然要看这个模板引擎。首先，我们来看SpringBoot里边怎么用。</p>
<h2 id="引入thymeleaf">引入Thymeleaf</h2>
<p>怎么引入呢，对于springboot来说，什么事情不都是一个start的事情嘛，我们去在项目中引入一下。给大家三个网址：</p>
<p>Thymeleaf 官网：https://www.thymeleaf.org/</p>
<p>Thymeleaf 在Github 的主页：https://github.com/thymeleaf/thymeleaf</p>
<p>Spring官方文档：找到我们对应的版本</p>
<p>https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/htmlsingle/#using-boot-starter</p>
<p>找到对应的pom依赖：可以适当点进源码看下本来的包！</p>
<pre><code class="language-xml">&lt;!--thymeleaf--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Maven会自动下载jar包，我们可以去看下下载的东西；</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589030040046.png" alt="" loading="lazy"></figure>
<h2 id="thymeleaf分析">Thymeleaf分析</h2>
<p>前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？</p>
<p>我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规则，我们进行使用。</p>
<p>我们去找一下Thymeleaf的自动配置类：ThymeleafProperties</p>
<pre><code class="language-java">@ConfigurationProperties(
    prefix = &quot;spring.thymeleaf&quot;
)
public class ThymeleafProperties {
    private static final Charset DEFAULT_ENCODING;
    public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;
    public static final String DEFAULT_SUFFIX = &quot;.html&quot;;
    private boolean checkTemplate = true;
    private boolean checkTemplateLocation = true;
    private String prefix = &quot;classpath:/templates/&quot;;
    private String suffix = &quot;.html&quot;;
    private String mode = &quot;HTML&quot;;
    private Charset encoding;
}
</code></pre>
<p>我们可以在其中看到默认的前缀和后缀！</p>
<p>我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。</p>
<p>使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！</p>
<h2 id="测试">测试</h2>
<p>1、编写一个TestController</p>
<pre><code class="language-java">@Controller
public class TestController {
    
    @RequestMapping(&quot;/t1&quot;)
    public String test1(){
        //classpath:/templates/test.html
        return &quot;test&quot;;
    }
    
}
</code></pre>
<p>2、编写一个测试页面  test.html 放在 templates 目录下</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;测试页面&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、启动项目请求测试</p>
<h2 id="thymeleaf-语法学习">Thymeleaf 语法学习</h2>
<p>要学习语法，还是参考官网文档最为准确，我们找到对应的版本看一下；</p>
<p>Thymeleaf 官网：https://www.thymeleaf.org/ ， 简单看一下官网！我们去下载Thymeleaf的官方文档！</p>
<p><strong>我们做个最简单的练习 ：我们需要查出一些数据，在页面中展示</strong></p>
<p>1、修改测试请求，增加数据传输；</p>
<pre><code class="language-java">@RequestMapping(&quot;/t1&quot;)
public String test1(Model model){
    //存入数据
    model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);
    //classpath:/templates/test.html
    return &quot;test&quot;;
}
</code></pre>
<p>2、我们要使用thymeleaf，需要在html文件中导入命名空间的约束，方便提示。</p>
<p>我们可以去官方文档的#3中看一下命名空间拿来过来：</p>
<pre><code> xmlns:th=&quot;http://www.thymeleaf.org&quot;
</code></pre>
<p>3、我们去编写下前端页面</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;test&lt;/h1&gt;
&lt;!--所有的html元素都可以被thymeleaf替换:   th:元素名--&gt;
&lt;!--th:text就是将div中的内容设置为它指定的值，和Vue一样--&gt;
&lt;div th:text=&quot;${msg}&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4、启动测试</p>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589030024666.png" alt="" loading="lazy"></figure>
<p><strong>OK，入门搞定，我们来认真研习一下Thymeleaf的使用语法！</strong></p>
<p><strong>1、我们可以使用任意的 th:attr 来替换Html中原生属性的值！</strong></p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589030016433.jpg" alt="" loading="lazy"></figure>
<p><strong>2、我们能写哪些表达式呢？</strong><br>
<img src="https://totoroay.github.io//post-images/1589379234610.png" alt="" loading="lazy"></p>
<pre><code>Simple expressions:（表达式语法）
Variable Expressions: ${...}：获取变量值；OGNL；
    1）、获取对象的属性、调用方法
    2）、使用内置的基本对象：#18
         #ctx : the context object.
         #vars: the context variables.
         #locale : the context locale.
         #request : (only in Web Contexts) the HttpServletRequest object.
         #response : (only in Web Contexts) the HttpServletResponse object.
         #session : (only in Web Contexts) the HttpSession object.
         #servletContext : (only in Web Contexts) the ServletContext object.

    3）、内置的一些工具对象：
　　　　　　#execInfo : information about the template being processed.
　　　　　　#uris : methods for escaping parts of URLs/URIs
　　　　　　#conversions : methods for executing the configured conversion service (if any).
　　　　　　#dates : methods for java.util.Date objects: formatting, component extraction, etc.
　　　　　　#calendars : analogous to #dates , but for java.util.Calendar objects.
　　　　　　#numbers : methods for formatting numeric objects.
　　　　　　#strings : methods for String objects: contains, startsWith, prepending/appending, etc.
　　　　　　#objects : methods for objects in general.
　　　　　　#bools : methods for boolean evaluation.
　　　　　　#arrays : methods for arrays.
　　　　　　#lists : methods for lists.
　　　　　　#sets : methods for sets.
　　　　　　#maps : methods for maps.
　　　　　　#aggregates : methods for creating aggregates on arrays or collections.
==================================================================================

  Selection Variable Expressions: *{...}：选择表达式：和${}在功能上是一样；
  Message Expressions: #{...}：获取国际化内容
  Link URL Expressions: @{...}：定义URL；
  Fragment Expressions: ~{...}：片段引用表达式

Literals（字面量）
      Text literals: 'one text' , 'Another one!' ,…
      Number literals: 0 , 34 , 3.0 , 12.3 ,…
      Boolean literals: true , false
      Null literal: null
      Literal tokens: one , sometext , main ,…
      
Text operations:（文本操作）
    String concatenation: +
    Literal substitutions: |The name is ${name}|
    
Arithmetic operations:（数学运算）
    Binary operators: + , - , * , / , %
    Minus sign (unary operator): -
    
Boolean operations:（布尔运算）
    Binary operators: and , or
    Boolean negation (unary operator): ! , not
    
Comparisons and equality:（比较运算）
    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )
    Equality operators: == , != ( eq , ne )
    
Conditional operators:条件运算（三元运算符）
    If-then: (if) ? (then)
    If-then-else: (if) ? (then) : (else)
    Default: (value) ?: (defaultvalue)
    
Special tokens:
    No-Operation: _
</code></pre>
<p><strong>练习测试：</strong></p>
<p>1、 我们编写一个Controller，放一些数据</p>
<pre><code class="language-java">@RequestMapping(&quot;/t2&quot;)
public String test2(Map&lt;String,Object&gt; map){
    //存入数据
    map.put(&quot;msg&quot;,&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;);
    map.put(&quot;users&quot;, Arrays.asList(&quot;qinjiang&quot;,&quot;kuangshen&quot;));
    //classpath:/templates/test.html
    return &quot;test&quot;;
}
</code></pre>
<p>2、测试页面取出数据</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;test&lt;/h1&gt;

&lt;div th:text=&quot;${msg}&quot;&gt;&lt;/div&gt;
&lt;!--不转义--&gt;
&lt;div th:utext=&quot;${msg}&quot;&gt;&lt;/div&gt;

&lt;!--遍历数据--&gt;
&lt;!--th:each每次遍历都会生成当前这个标签：官网#9--&gt;
&lt;h4 th:each=&quot;user :${users}&quot; th:text=&quot;${user}&quot;&gt;&lt;/h4&gt;

&lt;h4&gt;
    &lt;!--行内写法：官网#12--&gt;
    &lt;span th:each=&quot;user:${users}&quot;&gt;[[${user}]]&lt;/span&gt;
&lt;/h4&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3、启动项目测试</p>
<figure data-type="image" tabindex="4"><img src="https://totoroay.github.io//post-images/1589030000687.png" alt="" loading="lazy"></figure>
<p><strong>我们看完语法，很多样式，我们即使现在学习了，也会忘记，所以我们在学习过程中，需要使用什么，根据官方文档来查询，才是最重要的，要熟练使用官方文档！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring：AOP]]></title>
        <id>https://totoroay.github.io/post/springaop/</id>
        <link href="https://totoroay.github.io/post/springaop/">
        </link>
        <updated>2020-05-09T05:50:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是aop">什么是AOP</h2>
<p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<figure data-type="image" tabindex="1"><img src="https://totoroay.github.io//post-images/1589003489694.png" alt="" loading="lazy"></figure>
<h2 id="aop在spring中的作用">Aop在Spring中的作用</h2>
<p><mark>提供声明式事务；允许用户自定义切面</mark></p>
<p><mark>以下名词需要了解下：</mark></p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ....</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://totoroay.github.io//post-images/1589003480765.png" alt="" loading="lazy"></figure>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</p>
<figure data-type="image" tabindex="3"><img src="https://totoroay.github.io//post-images/1589003466003.png" alt="" loading="lazy"></figure>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .</p>
<h2 id="使用spring实现aop">使用Spring实现Aop</h2>
<p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
   &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="第一种方式通过-spring-api-实现">第一种方式通过 Spring API 实现</h3>
<p>首先编写我们的业务接口和实现类</p>
<pre><code class="language-java">public interface UserService {

   public void add();

   public void delete();

   public void update();

   public void search();

}
</code></pre>
<pre><code class="language-java">public class UserServiceImpl implements UserService{

   @Override
   public void add() {
       System.out.println(&quot;增加用户&quot;);
  }

   @Override
   public void delete() {
       System.out.println(&quot;删除用户&quot;);
  }

   @Override
   public void update() {
       System.out.println(&quot;更新用户&quot;);
  }

   @Override
   public void search() {
       System.out.println(&quot;查询用户&quot;);
  }
}
</code></pre>
<p>然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强</p>
<pre><code class="language-java">// 前置增强
public class Log implements MethodBeforeAdvice {

   //method : 要执行的目标对象的方法
   //objects : 被调用的方法的参数
   //Object : 目标对象
   @Override
   public void before(Method method, Object[] objects, Object target) throwsThrowable {
       System.out.println( target.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;);
  }
}
</code></pre>
<pre><code class="language-java">// 后置增强
public class AfterLog implements AfterReturningAdvice {
   //returnValue 返回值
   //method被调用的方法
   //args 被调用的方法的对象的参数
   //target 被调用的目标对象
   @Override
   public void afterReturning(Object returnValue, Method method, Object[] args,Object target) throws Throwable {
       System.out.println(&quot;执行了&quot; + target.getClass().getName()
       +&quot;的&quot;+method.getName()+&quot;方法,&quot;
       +&quot;返回值：&quot;+returnValue);
  }
}
</code></pre>
<p>最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 .</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

   &lt;!--注册bean--&gt;
   &lt;bean id=&quot;userService&quot; class=&quot;com.totoroay.service.UserServiceImpl&quot;/&gt;
   &lt;bean id=&quot;log&quot; class=&quot;com.totoroay.log.Log&quot;/&gt;
   &lt;bean id=&quot;afterLog&quot; class=&quot;com.totoroay.log.AfterLog&quot;/&gt;

   &lt;!--aop的配置--&gt;
   &lt;aop:config&gt;
       &lt;!--切入点 expression:表达式匹配要执行的方法--&gt;
       &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;
       &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
       &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;
</code></pre>
<p>测试</p>
<pre><code class="language-java">public class MyTest {
   @Test
   public void test(){
       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.search();
  }
}
</code></pre>
<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .</p>
<h3 id="第二种方式自定义类来实现aop">第二种方式自定义类来实现Aop</h3>
<p>目标业务类不变依旧是userServiceImpl</p>
<p>第一步 : 写我们自己的一个切入类</p>
<pre><code class="language-java">public class DiyPointcut {

   public void before(){
       System.out.println(&quot;---------方法执行前---------&quot;);
  }
   public void after(){
       System.out.println(&quot;---------方法执行后---------&quot;);
  }
   
}
</code></pre>
<p>去spring中配置</p>
<pre><code class="language-xml">&lt;!--第二种方式自定义实现--&gt;
&lt;!--注册bean--&gt;
&lt;bean id=&quot;diy&quot; class=&quot;com.totoroay.config.DiyPointcut&quot;/&gt;

&lt;!--aop的配置--&gt;
&lt;aop:config&gt;
   &lt;!--第二种方式：使用AOP的标签实现--&gt;
   &lt;aop:aspect ref=&quot;diy&quot;&gt;
       &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;/&gt;
       &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt;
       &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt;
   &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<p>测试：</p>
<pre><code class="language-java">public class MyTest {
   @Test
   public void test(){
       ApplicationContext context = newClassPathXmlApplicationContext(&quot;beans.xml&quot;);
       UserService userService = (UserService) context.getBean(&quot;userService&quot;);
       userService.add();
  }
}
</code></pre>
<h3 id="第三种方式使用注解实现">第三种方式使用注解实现</h3>
<p>第一步：编写一个注解实现的增强类</p>
<pre><code class="language-java">package com.totoroay.config;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect //标注这个类是一个切面
public class AnnotationPointcut {
   @Before(&quot;execution(* com.totoroay.service.UserServiceImpl.*(..))&quot;)
   public void before(){
       System.out.println(&quot;---------方法执行前---------&quot;);
  }

   @After(&quot;execution(* com.totoroay.service.UserServiceImpl.*(..))&quot;)
   public void after(){
       System.out.println(&quot;---------方法执行后---------&quot;);
  }

   @Around(&quot;execution(* com.totoroay.service.UserServiceImpl.*(..))&quot;)
   public void around(ProceedingJoinPoint jp) throws Throwable {
       System.out.println(&quot;环绕前&quot;);
       System.out.println(&quot;签名:&quot;+jp.getSignature());
       //执行目标方法proceed
       Object proceed = jp.proceed();
       System.out.println(&quot;环绕后&quot;);
       System.out.println(proceed);
  }
}
</code></pre>
<p>第二步：在Spring配置文件中，注册bean，并增加支持注解的配置</p>
<pre><code class="language-xml">&lt;!--第三种方式:注解实现--&gt;
&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.totoroay.config.AnnotationPointcut&quot;/&gt;
&lt;aop:aspectj-autoproxy/
</code></pre>
<p>aop:aspectj-autoproxy：说明</p>
<pre><code class="language-xml">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了

&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。
</code></pre>
]]></content>
    </entry>
</feed>